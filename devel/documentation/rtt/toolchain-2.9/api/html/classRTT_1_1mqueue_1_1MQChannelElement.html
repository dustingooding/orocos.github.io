<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Orocos Real-Time Toolkit: RTT::mqueue::MQChannelElement&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a></li><li class="navelem"><b>mqueue</b></li><li class="navelem"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">MQChannelElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRTT_1_1mqueue_1_1MQChannelElement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RTT::mqueue::MQChannelElement&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the a ChannelElement using message queues.  
 <a href="classRTT_1_1mqueue_1_1MQChannelElement.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MQChannelElement_8hpp_source.html">rtt/transports/mqueue/MQChannelElement.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTT::mqueue::MQChannelElement&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRTT_1_1mqueue_1_1MQChannelElement.png" usemap="#RTT::mqueue::MQChannelElement&lt; T &gt;_map" alt=""/>
  <map id="RTT::mqueue::MQChannelElement&lt; T &gt;_map" name="RTT::mqueue::MQChannelElement&lt; T &gt;_map">
<area href="classRTT_1_1base_1_1ChannelElement.html" title="A typed version of ChannelElementBase. " alt="RTT::base::ChannelElement&lt; T &gt;" shape="rect" coords="0,56,232,80"/>
<area href="classRTT_1_1mqueue_1_1MQSendRecv.html" title="Implements the sending/receiving of mqueue messages. " alt="RTT::mqueue::MQSendRecv" shape="rect" coords="242,56,474,80"/>
<area href="classRTT_1_1base_1_1ChannelElementBase.html" title="In the data flow implementation, a channel is created by chaining ChannelElementBase objects..." alt="RTT::base::ChannelElementBase" shape="rect" coords="0,0,232,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0dd2d513f8c406094c8a1e014d7c7aec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dd2d513f8c406094c8a1e014d7c7aec"></a>
typedef boost::intrusive_ptr<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">ChannelElement</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shared_ptr</b></td></tr>
<tr class="separator:a0dd2d513f8c406094c8a1e014d7c7aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade45ccb41aa5214ec4d8181305f1da1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aade45ccb41aa5214ec4d8181305f1da1"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_t</b></td></tr>
<tr class="separator:aade45ccb41aa5214ec4d8181305f1da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f0069d0143ebb53416110e7abd36df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02f0069d0143ebb53416110e7abd36df"></a>
typedef boost::call_traits&lt; T &gt;<br class="typebreak"/>
::param_type&#160;</td><td class="memItemRight" valign="bottom"><b>param_t</b></td></tr>
<tr class="separator:a02f0069d0143ebb53416110e7abd36df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da855b3b3636e479cf0fcd81cf2fe6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4da855b3b3636e479cf0fcd81cf2fe6f"></a>
typedef boost::call_traits&lt; T &gt;<br class="typebreak"/>
::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference_t</b></td></tr>
<tr class="separator:a4da855b3b3636e479cf0fcd81cf2fe6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a82b2be0bface24331d63a678d3973b8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html#a82b2be0bface24331d63a678d3973b8b">MQChannelElement</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *port, <a class="el" href="classRTT_1_1types_1_1TypeMarshaller.html">types::TypeMarshaller</a> const &amp;transport, const <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> &amp;policy, bool is_sender)</td></tr>
<tr class="memdesc:a82b2be0bface24331d63a678d3973b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a channel element for remote data exchange.  <a href="#a82b2be0bface24331d63a678d3973b8b">More...</a><br/></td></tr>
<tr class="separator:a82b2be0bface24331d63a678d3973b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ab319ed9ee5c9fa59ba4089ebe62c3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html#ae9ab319ed9ee5c9fa59ba4089ebe62c3">inputReady</a> (base::ChannelElementBase::shared_ptr const &amp;caller)</td></tr>
<tr class="memdesc:ae9ab319ed9ee5c9fa59ba4089ebe62c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called by an input port when it is ready to receive data.  <a href="#ae9ab319ed9ee5c9fa59ba4089ebe62c3">More...</a><br/></td></tr>
<tr class="separator:ae9ab319ed9ee5c9fa59ba4089ebe62c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c608cf3b8a7830f75df62def1007444"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c608cf3b8a7830f75df62def1007444"></a>
virtual <a class="el" href="namespaceRTT.html#a69b4aafe4f409edc68481d7429efe198">WriteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><b>data_sample</b> (typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::param_t sample, bool reset=true)</td></tr>
<tr class="separator:a9c608cf3b8a7830f75df62def1007444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bec196982377f40a7691b1854d8586"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html#a17bec196982377f40a7691b1854d8586">signal</a> ()</td></tr>
<tr class="memdesc:a17bec196982377f40a7691b1854d8586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal will cause a read-write cycle to transfer the data from the data/buffer element to the message queue and vice versa.  <a href="#a17bec196982377f40a7691b1854d8586">More...</a><br/></td></tr>
<tr class="separator:a17bec196982377f40a7691b1854d8586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2ffd366d9161f3e6087ad173adca60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html#a6c2ffd366d9161f3e6087ad173adca60">read</a> (typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::reference_t sample, bool copy_old_data)</td></tr>
<tr class="memdesc:a6c2ffd366d9161f3e6087ad173adca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from the message queue.  <a href="#a6c2ffd366d9161f3e6087ad173adca60">More...</a><br/></td></tr>
<tr class="separator:a6c2ffd366d9161f3e6087ad173adca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d32d8cd63a269e021d4f0cde39879d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRTT.html#a69b4aafe4f409edc68481d7429efe198">WriteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html#a2d32d8cd63a269e021d4f0cde39879d9">write</a> (typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::param_t sample)</td></tr>
<tr class="memdesc:a2d32d8cd63a269e021d4f0cde39879d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the message queue.  <a href="#a2d32d8cd63a269e021d4f0cde39879d9">More...</a><br/></td></tr>
<tr class="separator:a2d32d8cd63a269e021d4f0cde39879d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bfcee86c4f172889c6e4faecfdfcc8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html#a10bfcee86c4f172889c6e4faecfdfcc8">isRemoteElement</a> () const </td></tr>
<tr class="memdesc:a10bfcee86c4f172889c6e4faecfdfcc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function may be used to identify, if the current element uses a network transport, to send the data to the next Element in the logical chain.  <a href="#a10bfcee86c4f172889c6e4faecfdfcc8">More...</a><br/></td></tr>
<tr class="separator:a10bfcee86c4f172889c6e4faecfdfcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c1ccd3e23783738c942b72294f693a"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html#a63c1ccd3e23783738c942b72294f693a">getRemoteURI</a> () const </td></tr>
<tr class="memdesc:a63c1ccd3e23783738c942b72294f693a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the URI of the next channel element in the logical chain.  <a href="#a63c1ccd3e23783738c942b72294f693a">More...</a><br/></td></tr>
<tr class="separator:a63c1ccd3e23783738c942b72294f693a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92de07aadda7043a8ce1b74ad33774ad"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html#a92de07aadda7043a8ce1b74ad33774ad">getLocalURI</a> () const </td></tr>
<tr class="memdesc:a92de07aadda7043a8ce1b74ad33774ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return the URI of this element.  <a href="#a92de07aadda7043a8ce1b74ad33774ad">More...</a><br/></td></tr>
<tr class="separator:a92de07aadda7043a8ce1b74ad33774ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6014e7d5f669cf248922d7c943088c32"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html#a6014e7d5f669cf248922d7c943088c32">getElementName</a> () const </td></tr>
<tr class="memdesc:a6014e7d5f669cf248922d7c943088c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class name of this element.  <a href="#a6014e7d5f669cf248922d7c943088c32">More...</a><br/></td></tr>
<tr class="separator:a6014e7d5f669cf248922d7c943088c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8995494df01a2b71b4c1365ddd15696"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8995494df01a2b71b4c1365ddd15696"></a>
shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>getOutput</b> ()</td></tr>
<tr class="separator:ad8995494df01a2b71b4c1365ddd15696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e075866bf50078a5b1c8d564f567fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8e075866bf50078a5b1c8d564f567fe"></a>
shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>getInput</b> ()</td></tr>
<tr class="separator:ae8e075866bf50078a5b1c8d564f567fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b593435adb20eb2ce3b0d3a02d63519"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRTT.html#a69b4aafe4f409edc68481d7429efe198">WriteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElement.html#a5b593435adb20eb2ce3b0d3a02d63519">data_sample</a> (param_t sample, bool reset=true)</td></tr>
<tr class="memdesc:a5b593435adb20eb2ce3b0d3a02d63519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a data sample to initialize this connection.  <a href="#a5b593435adb20eb2ce3b0d3a02d63519">More...</a><br/></td></tr>
<tr class="separator:a5b593435adb20eb2ce3b0d3a02d63519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4d43ddf599240a5a209546c6c1980d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e4d43ddf599240a5a209546c6c1980d"></a>
virtual value_t&#160;</td><td class="memItemRight" valign="bottom"><b>data_sample</b> ()</td></tr>
<tr class="separator:a4e4d43ddf599240a5a209546c6c1980d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb94e4d3efe114af8a8360650b40635"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRTT.html#a69b4aafe4f409edc68481d7429efe198">WriteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElement.html#a3cb94e4d3efe114af8a8360650b40635">write</a> (param_t sample)</td></tr>
<tr class="memdesc:a3cb94e4d3efe114af8a8360650b40635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a new sample on this connection.  <a href="#a3cb94e4d3efe114af8a8360650b40635">More...</a><br/></td></tr>
<tr class="separator:a3cb94e4d3efe114af8a8360650b40635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea35c7c532583dc011f23513094ded03"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElement.html#aea35c7c532583dc011f23513094ded03">read</a> (reference_t sample, bool copy_old_data=true)</td></tr>
<tr class="memdesc:aea35c7c532583dc011f23513094ded03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a sample from the connection.  <a href="#aea35c7c532583dc011f23513094ded03">More...</a><br/></td></tr>
<tr class="separator:aea35c7c532583dc011f23513094ded03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e42c919f744c8e6a4ed952ad1e1c340"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3e42c919f744c8e6a4ed952ad1e1c340"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e42c919f744c8e6a4ed952ad1e1c340"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1ChannelElement.html">ChannelElement</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a3e42c919f744c8e6a4ed952ad1e1c340">narrow</a> ()</td></tr>
<tr class="memdesc:a3e42c919f744c8e6a4ed952ad1e1c340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the typed variant of this <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html" title="In the data flow implementation, a channel is created by chaining ChannelElementBase objects...">ChannelElementBase</a>. <br/></td></tr>
<tr class="separator:a3e42c919f744c8e6a4ed952ad1e1c340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e9f77c9197ba424d824ff44b38349f"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a63e9f77c9197ba424d824ff44b38349f">getInputEndPoint</a> ()</td></tr>
<tr class="memdesc:a63e9f77c9197ba424d824ff44b38349f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first input channel element of this connection.  <a href="#a63e9f77c9197ba424d824ff44b38349f">More...</a><br/></td></tr>
<tr class="separator:a63e9f77c9197ba424d824ff44b38349f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc45d26de98f37392cf01936f9ae2f6"><td class="memItemLeft" align="right" valign="top">virtual shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#aefc45d26de98f37392cf01936f9ae2f6">getOutputEndPoint</a> ()</td></tr>
<tr class="memdesc:aefc45d26de98f37392cf01936f9ae2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last output channel element of this connection.  <a href="#aefc45d26de98f37392cf01936f9ae2f6">More...</a><br/></td></tr>
<tr class="separator:aefc45d26de98f37392cf01936f9ae2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51bbede4b7cef19688822fea37ffdce"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#af51bbede4b7cef19688822fea37ffdce">connectTo</a> (ChannelElementBase::shared_ptr const &amp;output, bool mandatory=true)</td></tr>
<tr class="memdesc:af51bbede4b7cef19688822fea37ffdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects a new output to this element.  <a href="#af51bbede4b7cef19688822fea37ffdce">More...</a><br/></td></tr>
<tr class="separator:af51bbede4b7cef19688822fea37ffdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15af6f161fbbe7f9357cd5423367242e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a15af6f161fbbe7f9357cd5423367242e">connectFrom</a> (ChannelElementBase::shared_ptr const &amp;input)</td></tr>
<tr class="memdesc:a15af6f161fbbe7f9357cd5423367242e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects a new input to this element.  <a href="#a15af6f161fbbe7f9357cd5423367242e">More...</a><br/></td></tr>
<tr class="separator:a15af6f161fbbe7f9357cd5423367242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5c817d18837ffdd59eda9f9d02c2df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b5c817d18837ffdd59eda9f9d02c2df"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a4b5c817d18837ffdd59eda9f9d02c2df">connected</a> ()</td></tr>
<tr class="memdesc:a4b5c817d18837ffdd59eda9f9d02c2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if this channel element is connected on the input or output side. <br/></td></tr>
<tr class="separator:a4b5c817d18837ffdd59eda9f9d02c2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bde254d97586f315db880a8574bc0d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bde254d97586f315db880a8574bc0d5"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a3bde254d97586f315db880a8574bc0d5">signalFrom</a> (<a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html">ChannelElementBase</a> *caller)</td></tr>
<tr class="memdesc:a3bde254d97586f315db880a8574bc0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals that there is new data available on this channel Forwards to <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#aa985c67248dbe492db1f53b5b7c54c21">signal()</a> unless overwritten in a derived class. <br/></td></tr>
<tr class="separator:a3bde254d97586f315db880a8574bc0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec63f79d9ccff06c58c836697911b454"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#aec63f79d9ccff06c58c836697911b454">channelReady</a> (ChannelElementBase::shared_ptr const &amp;caller, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy, <a class="el" href="classRTT_1_1internal_1_1ConnID.html">internal::ConnID</a> *conn_id=0)</td></tr>
<tr class="memdesc:aec63f79d9ccff06c58c836697911b454"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called on the output half of a new connection by the connection factory in order to notify the output side of the new connection and check if it is ready to receive data.  <a href="#aec63f79d9ccff06c58c836697911b454">More...</a><br/></td></tr>
<tr class="separator:aec63f79d9ccff06c58c836697911b454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac280457e88649d5e78a76ef1a89df62a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#ac280457e88649d5e78a76ef1a89df62a">clear</a> ()</td></tr>
<tr class="memdesc:ac280457e88649d5e78a76ef1a89df62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears any data stored by the channel.  <a href="#ac280457e88649d5e78a76ef1a89df62a">More...</a><br/></td></tr>
<tr class="separator:ac280457e88649d5e78a76ef1a89df62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f604a6d6f285c35b0c82dad343af72c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a9f604a6d6f285c35b0c82dad343af72c">disconnect</a> (bool forward)</td></tr>
<tr class="memdesc:a9f604a6d6f285c35b0c82dad343af72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a disconnection of this channel's endpoints.  <a href="#a9f604a6d6f285c35b0c82dad343af72c">More...</a><br/></td></tr>
<tr class="separator:a9f604a6d6f285c35b0c82dad343af72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834646bd1af47979aa9d5f53142674de"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a834646bd1af47979aa9d5f53142674de">disconnect</a> (ChannelElementBase::shared_ptr const &amp;channel, bool forward)</td></tr>
<tr class="memdesc:a834646bd1af47979aa9d5f53142674de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a disconnection of a single input or output endpoint.  <a href="#a834646bd1af47979aa9d5f53142674de">More...</a><br/></td></tr>
<tr class="separator:a834646bd1af47979aa9d5f53142674de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1463d51bb5dc5ace823ae689c32935"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#ade1463d51bb5dc5ace823ae689c32935">getPort</a> () const </td></tr>
<tr class="memdesc:ade1463d51bb5dc5ace823ae689c32935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the port this channel element is connected to.  <a href="#ade1463d51bb5dc5ace823ae689c32935">More...</a><br/></td></tr>
<tr class="separator:ade1463d51bb5dc5ace823ae689c32935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b0d0d3b22eb597141eebae0401cf97"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a41b0d0d3b22eb597141eebae0401cf97">getConnPolicy</a> () const </td></tr>
<tr class="memdesc:a41b0d0d3b22eb597141eebae0401cf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the connection policy used to build this channel element, if available.  <a href="#a41b0d0d3b22eb597141eebae0401cf97">More...</a><br/></td></tr>
<tr class="separator:a41b0d0d3b22eb597141eebae0401cf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf12aec54e7a4e436e6608f35bcbc1d4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#abf12aec54e7a4e436e6608f35bcbc1d4">setBufferPolicy</a> (int policy, bool force=false)</td></tr>
<tr class="memdesc:abf12aec54e7a4e436e6608f35bcbc1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="group__Ports.html#gadc680c5e9ed12ee0889933483c89b7ea">BufferPolicy</a> of this channel element.  <a href="#abf12aec54e7a4e436e6608f35bcbc1d4">More...</a><br/></td></tr>
<tr class="separator:abf12aec54e7a4e436e6608f35bcbc1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877444985ef48ee5d3e9f1297d6239a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Ports.html#gadc680c5e9ed12ee0889933483c89b7ea">BufferPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a877444985ef48ee5d3e9f1297d6239a4">getBufferPolicy</a> () const </td></tr>
<tr class="memdesc:a877444985ef48ee5d3e9f1297d6239a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current <a class="el" href="group__Ports.html#gadc680c5e9ed12ee0889933483c89b7ea">BufferPolicy</a> of this channel element.  <a href="#a877444985ef48ee5d3e9f1297d6239a4">More...</a><br/></td></tr>
<tr class="separator:a877444985ef48ee5d3e9f1297d6239a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a516378722f20ae0e53a07064cea88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8a516378722f20ae0e53a07064cea88"></a>
RTT_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>setOutput</b> (const ChannelElementBase::shared_ptr &amp;output)</td></tr>
<tr class="separator:af8a516378722f20ae0e53a07064cea88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebc8c2edea8f72d58e376111132a4e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afebc8c2edea8f72d58e376111132a4e4"></a>
RTT_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>setInput</b> (const ChannelElementBase::shared_ptr &amp;input)</td></tr>
<tr class="separator:afebc8c2edea8f72d58e376111132a4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4696652bfcb390e883070346c3bb539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4696652bfcb390e883070346c3bb539"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setupStream</b> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> ds, <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy, bool is_sender)</td></tr>
<tr class="separator:ad4696652bfcb390e883070346c3bb539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36f355376cb21bd75af7fcc4ca2d0a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa36f355376cb21bd75af7fcc4ca2d0a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanupStream</b> ()</td></tr>
<tr class="separator:aa36f355376cb21bd75af7fcc4ca2d0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af687da2ce172b3ed6869eb877e09a954"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#af687da2ce172b3ed6869eb877e09a954">mqNewSample</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> ds)</td></tr>
<tr class="memdesc:af687da2ce172b3ed6869eb877e09a954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts the mq send/receive buffer size according to the data in mqdata_source, or the value set in mdata_size;.  <a href="#af687da2ce172b3ed6869eb877e09a954">More...</a><br/></td></tr>
<tr class="separator:af687da2ce172b3ed6869eb877e09a954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1131df7142246c91f3c6573471828908"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#a1131df7142246c91f3c6573471828908">mqReady</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> ds, <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html">base::ChannelElementBase</a> *chan)</td></tr>
<tr class="memdesc:a1131df7142246c91f3c6573471828908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Works only in receive mode, waits for a new sample and adapts the receive buffer to match it's size.  <a href="#a1131df7142246c91f3c6573471828908">More...</a><br/></td></tr>
<tr class="separator:a1131df7142246c91f3c6573471828908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5a32dfa0c2034666a37826a48f7210"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#aef5a32dfa0c2034666a37826a48f7210">mqRead</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> ds)</td></tr>
<tr class="memdesc:aef5a32dfa0c2034666a37826a48f7210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from the message queue.  <a href="#aef5a32dfa0c2034666a37826a48f7210">More...</a><br/></td></tr>
<tr class="separator:aef5a32dfa0c2034666a37826a48f7210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6725c130af22d7abe1035e88fa1b6e44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#a6725c130af22d7abe1035e88fa1b6e44">mqWrite</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> ds)</td></tr>
<tr class="memdesc:a6725c130af22d7abe1035e88fa1b6e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the message queue.  <a href="#a6725c130af22d7abe1035e88fa1b6e44">More...</a><br/></td></tr>
<tr class="separator:a6725c130af22d7abe1035e88fa1b6e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a15fc2c411c0de48b58c30f858d44e318"><td class="memTemplParams" colspan="2"><a class="anchor" id="a15fc2c411c0de48b58c30f858d44e318"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15fc2c411c0de48b58c30f858d44e318"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">ChannelElement</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a15fc2c411c0de48b58c30f858d44e318">narrow</a> (<a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html">ChannelElementBase</a> *e)</td></tr>
<tr class="memdesc:a15fc2c411c0de48b58c30f858d44e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the typed instance of a <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html" title="In the data flow implementation, a channel is created by chaining ChannelElementBase objects...">ChannelElementBase</a>. <br/></td></tr>
<tr class="separator:a15fc2c411c0de48b58c30f858d44e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0373df868f76e95e0672977c55a2a937"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0373df868f76e95e0672977c55a2a937"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a0373df868f76e95e0672977c55a2a937">ref</a> ()</td></tr>
<tr class="memdesc:a0373df868f76e95e0672977c55a2a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the reference count. <br/></td></tr>
<tr class="separator:a0373df868f76e95e0672977c55a2a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7de132a871f70881c182cbe4bef67b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a7de132a871f70881c182cbe4bef67b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a7a7de132a871f70881c182cbe4bef67b">deref</a> ()</td></tr>
<tr class="memdesc:a7a7de132a871f70881c182cbe4bef67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the reference count, and deletes the object if it is zero. <br/></td></tr>
<tr class="separator:a7a7de132a871f70881c182cbe4bef67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f85762914ae94498ce2ad7397d3f32"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a24f85762914ae94498ce2ad7397d3f32">addOutput</a> (shared_ptr const &amp;output, bool mandatory=true)</td></tr>
<tr class="memdesc:a24f85762914ae94498ce2ad7397d3f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the new output channel element of this element or adds a channel to the outputs list.  <a href="#a24f85762914ae94498ce2ad7397d3f32">More...</a><br/></td></tr>
<tr class="separator:a24f85762914ae94498ce2ad7397d3f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcc89cab2e2ddb78eb00262691325c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a7dcc89cab2e2ddb78eb00262691325c7">removeOutput</a> (shared_ptr const &amp;output)</td></tr>
<tr class="memdesc:a7dcc89cab2e2ddb78eb00262691325c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an output from the outputs list.  <a href="#a7dcc89cab2e2ddb78eb00262691325c7">More...</a><br/></td></tr>
<tr class="separator:a7dcc89cab2e2ddb78eb00262691325c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194d84e56b2a7876ec319b01daa81ddf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a194d84e56b2a7876ec319b01daa81ddf">addInput</a> (shared_ptr const &amp;input)</td></tr>
<tr class="memdesc:a194d84e56b2a7876ec319b01daa81ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the new input channel element of this element or adds a channel to the inputs list.  <a href="#a194d84e56b2a7876ec319b01daa81ddf">More...</a><br/></td></tr>
<tr class="separator:a194d84e56b2a7876ec319b01daa81ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f2b157dd0ff6a6f0159a782dc17771"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a07f2b157dd0ff6a6f0159a782dc17771">removeInput</a> (shared_ptr const &amp;input)</td></tr>
<tr class="memdesc:a07f2b157dd0ff6a6f0159a782dc17771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an input from the inputs list.  <a href="#a07f2b157dd0ff6a6f0159a782dc17771">More...</a><br/></td></tr>
<tr class="separator:a07f2b157dd0ff6a6f0159a782dc17771"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a42a23dd060035b3ecea0dcfb75f00c70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42a23dd060035b3ecea0dcfb75f00c70"></a>
shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>input</b></td></tr>
<tr class="separator:a42a23dd060035b3ecea0dcfb75f00c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4e2df1a665e53f0b707ad350364e19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c4e2df1a665e53f0b707ad350364e19"></a>
shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>output</b></td></tr>
<tr class="separator:a9c4e2df1a665e53f0b707ad350364e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba58aa5e0b72e3001661f8e616a29b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ba58aa5e0b72e3001661f8e616a29b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_policy</b></td></tr>
<tr class="separator:a2ba58aa5e0b72e3001661f8e616a29b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1011eaa2395edec94233771af5b974b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1011eaa2395edec94233771af5b974b"></a>
<a class="el" href="classRTT_1_1os_1_1SharedMutex.html">RTT::os::SharedMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>input_lock</b></td></tr>
<tr class="separator:ad1011eaa2395edec94233771af5b974b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee85e82db3d9c9df962b47206a72df10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee85e82db3d9c9df962b47206a72df10"></a>
<a class="el" href="classRTT_1_1os_1_1SharedMutex.html">RTT::os::SharedMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>output_lock</b></td></tr>
<tr class="separator:aee85e82db3d9c9df962b47206a72df10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dc4885ab041d802acb8b66dfbf2918"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92dc4885ab041d802acb8b66dfbf2918"></a>
<a class="el" href="classRTT_1_1os_1_1SharedMutex.html">RTT::os::SharedMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_policy_lock</b></td></tr>
<tr class="separator:a92dc4885ab041d802acb8b66dfbf2918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56e6832aae9920d4e74c1c71d75505c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae56e6832aae9920d4e74c1c71d75505c"></a>
<a class="el" href="classRTT_1_1types_1_1TypeMarshaller.html">types::TypeMarshaller</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#ae56e6832aae9920d4e74c1c71d75505c">mtransport</a></td></tr>
<tr class="memdesc:ae56e6832aae9920d4e74c1c71d75505c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport marshaller used for size calculations and data updates. <br/></td></tr>
<tr class="separator:ae56e6832aae9920d4e74c1c71d75505c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a0b2227bd4d9cccec2607227fecd59"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#a12a0b2227bd4d9cccec2607227fecd59">marshaller_cookie</a></td></tr>
<tr class="memdesc:a12a0b2227bd4d9cccec2607227fecd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">A private blob that is returned by mtransport.getCookie().  <a href="#a12a0b2227bd4d9cccec2607227fecd59">More...</a><br/></td></tr>
<tr class="separator:a12a0b2227bd4d9cccec2607227fecd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f846d13e42728e2ee35c424d0963907"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f846d13e42728e2ee35c424d0963907"></a>
mqd_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#a0f846d13e42728e2ee35c424d0963907">mqdes</a></td></tr>
<tr class="memdesc:a0f846d13e42728e2ee35c424d0963907"><td class="mdescLeft">&#160;</td><td class="mdescRight">MQueue file descriptor. <br/></td></tr>
<tr class="separator:a0f846d13e42728e2ee35c424d0963907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191d2d7bcc44bb99ba59f5a95c6be678"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#a191d2d7bcc44bb99ba59f5a95c6be678">buf</a></td></tr>
<tr class="memdesc:a191d2d7bcc44bb99ba59f5a95c6be678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send/Receive buffer.  <a href="#a191d2d7bcc44bb99ba59f5a95c6be678">More...</a><br/></td></tr>
<tr class="separator:a191d2d7bcc44bb99ba59f5a95c6be678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df88d069c8752c4042d5a903d45182d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0df88d069c8752c4042d5a903d45182d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#a0df88d069c8752c4042d5a903d45182d">mis_sender</a></td></tr>
<tr class="memdesc:a0df88d069c8752c4042d5a903d45182d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this object is a sender. <br/></td></tr>
<tr class="separator:a0df88d069c8752c4042d5a903d45182d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468417ba1e1f6a7dac18e1724f673cc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a468417ba1e1f6a7dac18e1724f673cc0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#a468417ba1e1f6a7dac18e1724f673cc0">minit_done</a></td></tr>
<tr class="memdesc:a468417ba1e1f6a7dac18e1724f673cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if setupStream() was called, false after cleanupStream(). <br/></td></tr>
<tr class="separator:a468417ba1e1f6a7dac18e1724f673cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aca65de383ce108853ebc43140f6e8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9aca65de383ce108853ebc43140f6e8a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#a9aca65de383ce108853ebc43140f6e8a">max_size</a></td></tr>
<tr class="memdesc:a9aca65de383ce108853ebc43140f6e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of buf. <br/></td></tr>
<tr class="separator:a9aca65de383ce108853ebc43140f6e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e319487b31e83d288038bebc80d30c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66e319487b31e83d288038bebc80d30c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#a66e319487b31e83d288038bebc80d30c">mqname</a></td></tr>
<tr class="memdesc:a66e319487b31e83d288038bebc80d30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the queue, as specified in the <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> when creating the stream, or self-calculated when that name was empty. <br/></td></tr>
<tr class="separator:a66e319487b31e83d288038bebc80d30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e3f05929bc35ed308ebfe9b30352fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29e3f05929bc35ed308ebfe9b30352fe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1mqueue_1_1MQSendRecv.html#a29e3f05929bc35ed308ebfe9b30352fe">mdata_size</a></td></tr>
<tr class="memdesc:a29e3f05929bc35ed308ebfe9b30352fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the data, as specified in the <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> when creating the stream, or calculated using the transport when that size was zero. <br/></td></tr>
<tr class="separator:a29e3f05929bc35ed308ebfe9b30352fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class RTT::mqueue::MQChannelElement&lt; T &gt;</h3>

<p>Implements the a ChannelElement using message queues. </p>
<p>It converts the C++ calls into MQ messages and vice versa. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd><p class="startdd">This class can be refactored into a base class with generic mqueue code and a subclass with type specific info. </p>
<p class="enddd">This is an inspiration for a generic, transport independent channel element. </p>
</dd></dl>

<p>Definition at line <a class="el" href="MQChannelElement_8hpp_source.html#l00062">62</a> of file <a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a82b2be0bface24331d63a678d3973b8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">RTT::mqueue::MQChannelElement</a>&lt; T &gt;::<a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">MQChannelElement</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1types_1_1TypeMarshaller.html">types::TypeMarshaller</a> const &amp;&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a channel element for remote data exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The type specific object that will be used to marshal the data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MQChannelElement_8hpp_source.html#l00074">74</a> of file <a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a194d84e56b2a7876ec319b01daa81ddf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChannelElementBase::addInput </td>
          <td>(</td>
          <td class="paramtype">shared_ptr const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the new input channel element of this element or adds a channel to the inputs list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the previous element in chain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the input was set or false if this element does not support multiple inputs and the input is already set. </dd></dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1base_1_1MultipleInputsChannelElementBase.html#a7d3feee807fa6c2639ac375be5f7ad6b">RTT::base::MultipleInputsChannelElementBase</a>.</p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00108">108</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="ChannelInterface_8cpp_source.html#l00098">RTT::base::ChannelElementBase::connectFrom()</a>.</p>

</div>
</div>
<a class="anchor" id="a24f85762914ae94498ce2ad7397d3f32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChannelElementBase::addOutput </td>
          <td>(</td>
          <td class="paramtype">shared_ptr const &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mandatory</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the new output channel element of this element or adds a channel to the outputs list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the next element in chain. </td></tr>
    <tr><td class="paramname">mandatory</td><td>whether the added output is mandatory for a write to succeed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the output was set or false if this element does not support multiple outputs and the output is already set. </dd></dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1base_1_1MultipleOutputsChannelElementBase.html#a7d8b962f5a5fe1fa58d68ce5189e9e8d">RTT::base::MultipleOutputsChannelElementBase</a>.</p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00081">81</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="ChannelInterface_8cpp_source.html#l00071">RTT::base::ChannelElementBase::connectTo()</a>.</p>

</div>
</div>
<a class="anchor" id="aec63f79d9ccff06c58c836697911b454"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChannelElementBase::channelReady </td>
          <td>(</td>
          <td class="paramtype">ChannelElementBase::shared_ptr const &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1ConnID.html">internal::ConnID</a> *&#160;</td>
          <td class="paramname"><em>conn_id</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called on the output half of a new connection by the connection factory in order to notify the output side of the new connection and check if it is ready to receive data. </p>
<p>Each channel element has the responsibility to pass this notification on to the next, in the direction of the input. The ConnOutputEndPoint then calls back the inputReady() method in reverse direction to notify the output that the connection was successfully established. </p>
<dl class="section return"><dt>Returns</dt><dd>false if a fatal connection failure was encountered and the channel needs to be destroyed. </dd></dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1base_1_1MultipleOutputsChannelElementBase.html#a99ba11be6c99d97ff16e75aaac2aa812">RTT::base::MultipleOutputsChannelElementBase</a>, <a class="el" href="classRTT_1_1corba_1_1RemoteChannelElement.html#a9eb5dcafa4fac5aa84e5ec8d91b00e7e">RTT::corba::RemoteChannelElement&lt; T &gt;</a>, and <a class="el" href="classRTT_1_1internal_1_1ConnOutputEndpoint.html#a2b4f01dea288f6fb7dd6dc98739464fc">RTT::internal::ConnOutputEndpoint&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00171">171</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>References <a class="el" href="ChannelInterface_8cpp_source.html#l00065">RTT::base::ChannelElementBase::getOutput()</a>.</p>

<p>Referenced by <a class="el" href="RemoteChannelElement_8hpp_source.html#l00477">RTT::corba::RemoteChannelElement&lt; T &gt;::channelReady()</a>.</p>

</div>
</div>
<a class="anchor" id="ac280457e88649d5e78a76ef1a89df62a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChannelElementBase::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears any data stored by the channel. </p>
<p>It means that <a class="el" href="classRTT_1_1base_1_1ChannelElement.html#aea35c7c532583dc011f23513094ded03" title="Reads a sample from the connection. ">ChannelElement::read()</a> will return false afterwards (provided that no new data has been written on the meantime of course)</p>
<p>By default, the channel element forwards the calls to its input </p>

<p>Reimplemented in <a class="el" href="classRTT_1_1base_1_1MultipleInputsChannelElementBase.html#a8454306ab8349b42cb1e5ed29c8becfc">RTT::base::MultipleInputsChannelElementBase</a>, <a class="el" href="classRTT_1_1internal_1_1ChannelBufferElement.html#a766e9a0251cc25682d14e84c54fb7545">RTT::internal::ChannelBufferElement&lt; T &gt;</a>, and <a class="el" href="classRTT_1_1internal_1_1ChannelDataElement.html#ab9014c1217fce59552a19c929881a856">RTT::internal::ChannelDataElement&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00190">190</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>References <a class="el" href="ChannelInterface_8cpp_source.html#l00059">RTT::base::ChannelElementBase::getInput()</a>.</p>

<p>Referenced by <a class="el" href="ChannelDataElement_8hpp_source.html#l00083">RTT::internal::ChannelDataElement&lt; T &gt;::clear()</a>, and <a class="el" href="ChannelBufferElement_8hpp_source.html#l00140">RTT::internal::ChannelBufferElement&lt; T &gt;::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a15af6f161fbbe7f9357cd5423367242e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChannelElementBase::connectFrom </td>
          <td>(</td>
          <td class="paramtype">ChannelElementBase::shared_ptr const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects a new input to this element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the previous element in chain. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00098">98</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>References <a class="el" href="ChannelInterface_8cpp_source.html#l00108">RTT::base::ChannelElementBase::addInput()</a>, and <a class="el" href="ChannelInterface_8cpp_source.html#l00117">RTT::base::ChannelElementBase::removeInput()</a>.</p>

</div>
</div>
<a class="anchor" id="af51bbede4b7cef19688822fea37ffdce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChannelElementBase::connectTo </td>
          <td>(</td>
          <td class="paramtype">ChannelElementBase::shared_ptr const &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mandatory</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects a new output to this element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the next element in chain. </td></tr>
    <tr><td class="paramname">mandatory</td><td>whether the added output is mandatory for a write operation to succeed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00071">71</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>References <a class="el" href="ChannelInterface_8cpp_source.html#l00081">RTT::base::ChannelElementBase::addOutput()</a>, and <a class="el" href="ChannelInterface_8cpp_source.html#l00090">RTT::base::ChannelElementBase::removeOutput()</a>.</p>

<p>Referenced by <a class="el" href="ConnFactory_8hpp_source.html#l00224">RTT::internal::ConnFactory::buildChannelInput()</a>, and <a class="el" href="ConnFactory_8hpp_source.html#l00310">RTT::internal::ConnFactory::buildChannelOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b593435adb20eb2ce3b0d3a02d63519"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRTT.html#a69b4aafe4f409edc68481d7429efe198">WriteStatus</a> <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">RTT::base::ChannelElement</a>&lt; T &gt;::data_sample </td>
          <td>(</td>
          <td class="paramtype">param_t&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reset</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a data sample to initialize this connection. </p>
<p>This is used before the first <a class="el" href="classRTT_1_1base_1_1ChannelElement.html#a3cb94e4d3efe114af8a8360650b40635" title="Writes a new sample on this connection. ">write()</a> in order to inform this connection of the size of the data. As such enough storage space can be allocated before the actual writing begins.</p>
<dl class="section return"><dt>Returns</dt><dd>false if an error occured that requires the channel to be invalidated. </dd></dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1base_1_1MultipleOutputsChannelElement.html#ab6768af7afc7f11d6ac93aaeaa2a3a9b">RTT::base::MultipleOutputsChannelElement&lt; T &gt;</a>, <a class="el" href="classRTT_1_1internal_1_1ChannelBufferElement.html#a02e7efcf7eedeb474e4980b4c4619c75">RTT::internal::ChannelBufferElement&lt; T &gt;</a>, and <a class="el" href="classRTT_1_1internal_1_1ChannelDataElement.html#afee95171766cf507c8bdcce6894be8c7">RTT::internal::ChannelDataElement&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="ChannelElement_8hpp_source.html#l00087">87</a> of file <a class="el" href="ChannelElement_8hpp_source.html">ChannelElement.hpp</a>.</p>

<p>References <a class="el" href="ChannelElement_8hpp_source.html#l00087">RTT::base::ChannelElement&lt; T &gt;::data_sample()</a>.</p>

<p>Referenced by <a class="el" href="ChannelElement_8hpp_source.html#l00087">RTT::base::ChannelElement&lt; T &gt;::data_sample()</a>, <a class="el" href="ChannelElement_8hpp_source.html#l00149">RTT::base::MultipleInputsChannelElement&lt; T &gt;::data_sample()</a>, <a class="el" href="ChannelElement_8hpp_source.html#l00283">RTT::base::MultipleOutputsChannelElement&lt; T &gt;::data_sample()</a>, and <a class="el" href="MQChannelElement_8hpp_source.html#l00089">RTT::mqueue::MQChannelElement&lt; T &gt;::inputReady()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f604a6d6f285c35b0c82dad343af72c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChannelElementBase::disconnect </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a disconnection of this channel's endpoints. </p>
<p>If <em>forward</em> is true, then the disconnection is initiated by the input endpoint. Otherwise, it has been initiated by the output endpoint. </p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00132">132</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="RemoteChannelElement_8hpp_source.html#l00213">RTT::corba::RemoteChannelElement&lt; T &gt;::disconnect()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00293">RTT::base::MultipleInputsChannelElementBase::disconnect()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00397">RTT::base::MultipleOutputsChannelElementBase::disconnect()</a>, <a class="el" href="ConnectionManager_8cpp_source.html#l00078">RTT::internal::ConnectionManager::eraseConnection()</a>, and <a class="el" href="RemoteChannelElement_8hpp_source.html#l00194">RTT::corba::RemoteChannelElement&lt; T &gt;::remoteDisconnect()</a>.</p>

</div>
</div>
<a class="anchor" id="a834646bd1af47979aa9d5f53142674de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RTT::base::ChannelElementBase::disconnect </td>
          <td>(</td>
          <td class="paramtype">ChannelElementBase::shared_ptr const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a disconnection of a single input or output endpoint. </p>
<p>If <em>forward</em> is true, then the disconnection is initiated by the input endpoint and channel must be a connected input. Otherwise, it has been initiated by the output endpoint and channel must be a connected output. The disconnect call is only forwarded to the opposite side of the channel element after the last input/output element on either side has been removed.</p>
<p>The <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html" title="In the data flow implementation, a channel is created by chaining ChannelElementBase objects...">ChannelElementBase</a> implementation ignores the given channel and disconnects unconditinally. </p>

<p>Reimplemented in <a class="el" href="classRTT_1_1base_1_1MultipleInputsMultipleOutputsChannelElementBase.html#ae4507e4e15a465fa998ff28211e4f024">RTT::base::MultipleInputsMultipleOutputsChannelElementBase</a>, <a class="el" href="classRTT_1_1base_1_1MultipleOutputsChannelElementBase.html#a4beff83f9ce436c6cf735442af06ad94">RTT::base::MultipleOutputsChannelElementBase</a>, <a class="el" href="classRTT_1_1base_1_1MultipleInputsChannelElementBase.html#a945bfe45dde582af7ac21406dbf97d94">RTT::base::MultipleInputsChannelElementBase</a>, <a class="el" href="classRTT_1_1corba_1_1RemoteChannelElement.html#a3e40d14ded7504e28762e69170cffdee">RTT::corba::RemoteChannelElement&lt; T &gt;</a>, <a class="el" href="classRTT_1_1internal_1_1ConnOutputEndpoint.html#a55fe3b37f6a64c92719cb9b0203283e3">RTT::internal::ConnOutputEndpoint&lt; T &gt;</a>, and <a class="el" href="classRTT_1_1internal_1_1ConnInputEndpoint.html#ad80ca37ac3b94360f5db0f62ec088aad">RTT::internal::ConnInputEndpoint&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a877444985ef48ee5d3e9f1297d6239a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ports.html#gadc680c5e9ed12ee0889933483c89b7ea">BufferPolicy</a> ChannelElementBase::getBufferPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current <a class="el" href="group__Ports.html#gadc680c5e9ed12ee0889933483c89b7ea">BufferPolicy</a> of this channel element. </p>
<dl class="section return"><dt>Returns</dt><dd>a BufferPolicy instance </dd></dl>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00223">223</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="ConnFactory_8hpp_source.html#l00224">RTT::internal::ConnFactory::buildChannelInput()</a>, and <a class="el" href="ConnFactory_8hpp_source.html#l00310">RTT::internal::ConnFactory::buildChannelOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="a41b0d0d3b22eb597141eebae0401cf97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> * ChannelElementBase::getConnPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the connection policy used to build this channel element, if available. </p>
<p>This method will be overwritten for data and buffer elements. </p>
<dl class="section return"><dt>Returns</dt><dd>null if there is no <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> associated with this element, a pointer to an instance of <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1internal_1_1ChannelBufferElement.html#a25e5f0ace3c191c7a572535da9b558d5">RTT::internal::ChannelBufferElement&lt; T &gt;</a>, <a class="el" href="classRTT_1_1internal_1_1SharedConnectionBase.html#a7dddf93435491502aaabf8083d2115e7">RTT::internal::SharedConnectionBase</a>, and <a class="el" href="classRTT_1_1internal_1_1ChannelDataElement.html#a4b9da624116295f1fe5d4d8b100cecaa">RTT::internal::ChannelDataElement&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00209">209</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="ConnFactory_8hpp_source.html#l00224">RTT::internal::ConnFactory::buildChannelInput()</a>, and <a class="el" href="ConnFactory_8hpp_source.html#l00310">RTT::internal::ConnFactory::buildChannelOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="a6014e7d5f669cf248922d7c943088c32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">RTT::mqueue::MQChannelElement</a>&lt; T &gt;::getElementName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the class name of this element. </p>
<p>This is primary useful for special case handling in the connection tracking. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the class of the ChannelElement </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#aa2bc1d9562c6b1a2797a144997a2c54f">RTT::base::ChannelElementBase</a>.</p>

<p>Definition at line <a class="el" href="MQChannelElement_8hpp_source.html#l00196">196</a> of file <a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63e9f77c9197ba424d824ff44b38349f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChannelElementBase::shared_ptr ChannelElementBase::getInputEndPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first input channel element of this connection. </p>
<p>Will return the channel element the furthest away from the input port, or <em>this</em> if none. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a7abd277448530efc8817ca36cf0238f8" title="Returns the current input channel element. ">getInput()</a> ? <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a7abd277448530efc8817ca36cf0238f8" title="Returns the current input channel element. ">getInput()</a>-&gt;<a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a63e9f77c9197ba424d824ff44b38349f" title="Returns the first input channel element of this connection. ">getInputEndPoint()</a> : this </dd></dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1internal_1_1ConnInputEndpoint.html#a779fa399a4cf186a86fffc43fa5fd838">RTT::internal::ConnInputEndpoint&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00159">159</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>References <a class="el" href="ChannelInterface_8cpp_source.html#l00059">RTT::base::ChannelElementBase::getInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a92de07aadda7043a8ce1b74ad33774ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">RTT::mqueue::MQChannelElement</a>&lt; T &gt;::getLocalURI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function return the URI of this element. </p>
<p>The URI must be unique. </p>
<dl class="section return"><dt>Returns</dt><dd>URI of this element. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a017def07a5edc5d4d088bbc1ccb6873a">RTT::base::ChannelElementBase</a>.</p>

<p>Definition at line <a class="el" href="MQChannelElement_8hpp_source.html#l00186">186</a> of file <a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a>.</p>

<p>References <a class="el" href="ChannelInterface_8cpp_source.html#l00059">RTT::base::ChannelElementBase::getInput()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00241">RTT::base::ChannelElementBase::getLocalURI()</a>, and <a class="el" href="MQSendRecv_8hpp_source.html#l00096">RTT::mqueue::MQSendRecv::mqname</a>.</p>

</div>
</div>
<a class="anchor" id="aefc45d26de98f37392cf01936f9ae2f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChannelElementBase::shared_ptr ChannelElementBase::getOutputEndPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last output channel element of this connection. </p>
<p>Will return the channel element the furthest away from the output port, or <em>this</em> if none. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a17b16a344228234a2f6d51559c7522c8" title="Returns the next channel element in the channel&#39;s propagation direction. ">getOutput()</a> ? <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a17b16a344228234a2f6d51559c7522c8" title="Returns the next channel element in the channel&#39;s propagation direction. ">getOutput()</a>-&gt;<a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a63e9f77c9197ba424d824ff44b38349f" title="Returns the first input channel element of this connection. ">getInputEndPoint()</a> : this </dd></dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1internal_1_1ConnOutputEndpoint.html#ac58cc3e00affe83e1992ca8b27828d5e">RTT::internal::ConnOutputEndpoint&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00165">165</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>References <a class="el" href="ChannelInterface_8cpp_source.html#l00065">RTT::base::ChannelElementBase::getOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="ade1463d51bb5dc5ace823ae689c32935"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> * ChannelElementBase::getPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the port this channel element is connected to. </p>
<dl class="section return"><dt>Returns</dt><dd>null if no port is connected to this element, the port (or a proxy representing the port) otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1internal_1_1ConnOutputEndpoint.html#a4184200033a0953f57ac8e1d8cfc5dbd">RTT::internal::ConnOutputEndpoint&lt; T &gt;</a>, and <a class="el" href="classRTT_1_1internal_1_1ConnInputEndpoint.html#ab67f67007cdb4c655aa195ed69a9da12">RTT::internal::ConnInputEndpoint&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00205">205</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63c1ccd3e23783738c942b72294f693a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">RTT::mqueue::MQChannelElement</a>&lt; T &gt;::getRemoteURI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the URI of the next channel element in the logical chain. </p>
<p>The URI must be unique. E.g: In the local case output-&gt;<a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html#a92de07aadda7043a8ce1b74ad33774ad" title="This function return the URI of this element. ">getLocalURI()</a> In the remote case the URI of the remote channel element.</p>
<dl class="section return"><dt>Returns</dt><dd>URI of the next element. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a1d4eab0475a5e1e42963a89661d9d12f">RTT::base::ChannelElementBase</a>.</p>

<p>Definition at line <a class="el" href="MQChannelElement_8hpp_source.html#l00176">176</a> of file <a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a>.</p>

<p>References <a class="el" href="ChannelInterface_8cpp_source.html#l00065">RTT::base::ChannelElementBase::getOutput()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00233">RTT::base::ChannelElementBase::getRemoteURI()</a>, and <a class="el" href="MQSendRecv_8hpp_source.html#l00096">RTT::mqueue::MQSendRecv::mqname</a>.</p>

</div>
</div>
<a class="anchor" id="ae9ab319ed9ee5c9fa59ba4089ebe62c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">RTT::mqueue::MQChannelElement</a>&lt; T &gt;::inputReady </td>
          <td>(</td>
          <td class="paramtype">base::ChannelElementBase::shared_ptr const &amp;&#160;</td>
          <td class="paramname"><em>caller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called by an input port when it is ready to receive data. </p>
<p>Each channel element has the responsibility to pass this notification on to the next, in the direction of the output. </p>
<dl class="section return"><dt>Returns</dt><dd>false if a fatal connection failure was encountered and the channel needs to be destroyed. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a1d5804375c6925e005af865deb89869b">RTT::base::ChannelElementBase</a>.</p>

<p>Definition at line <a class="el" href="MQChannelElement_8hpp_source.html#l00089">89</a> of file <a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a>.</p>

<p>References <a class="el" href="ChannelElement_8hpp_source.html#l00087">RTT::base::ChannelElement&lt; T &gt;::data_sample()</a>, and <a class="el" href="MQSendRecv_8cpp_source.html#l00198">RTT::mqueue::MQSendRecv::mqReady()</a>.</p>

</div>
</div>
<a class="anchor" id="a10bfcee86c4f172889c6e4faecfdfcc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">RTT::mqueue::MQChannelElement</a>&lt; T &gt;::isRemoteElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function may be used to identify, if the current element uses a network transport, to send the data to the next Element in the logical chain. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a network transport is used. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#a2237a004c5db9ff66ed81c5e87b2baaf">RTT::base::ChannelElementBase</a>.</p>

<p>Definition at line <a class="el" href="MQChannelElement_8hpp_source.html#l00171">171</a> of file <a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af687da2ce172b3ed6869eb877e09a954"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MQSendRecv::mqNewSample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adapts the mq send/receive buffer size according to the data in mqdata_source, or the value set in mdata_size;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MQSendRecv_8cpp_source.html#l00188">188</a> of file <a class="el" href="MQSendRecv_8cpp_source.html">MQSendRecv.cpp</a>.</p>

<p>References <a class="el" href="MQSendRecv_8hpp_source.html#l00079">RTT::mqueue::MQSendRecv::buf</a>, <a class="el" href="classRTT_1_1types_1_1TypeMarshaller.html#a0aabb6cb6611806502df0752c83cdf72">RTT::types::TypeMarshaller::getSampleSize()</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00091">RTT::mqueue::MQSendRecv::max_size</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00102">RTT::mqueue::MQSendRecv::mdata_size</a>, and <a class="el" href="MQSendRecv_8hpp_source.html#l00061">RTT::mqueue::MQSendRecv::mtransport</a>.</p>

</div>
</div>
<a class="anchor" id="aef5a32dfa0c2034666a37826a48f7210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MQSendRecv::mqRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>stores the resulting data sample. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an item could be read. </dd></dl>

<p>Definition at line <a class="el" href="MQSendRecv_8cpp_source.html#l00276">276</a> of file <a class="el" href="MQSendRecv_8cpp_source.html">MQSendRecv.cpp</a>.</p>

<p>References <a class="el" href="MQSendRecv_8hpp_source.html#l00079">RTT::mqueue::MQSendRecv::buf</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00067">RTT::mqueue::MQSendRecv::marshaller_cookie</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00091">RTT::mqueue::MQSendRecv::max_size</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00071">RTT::mqueue::MQSendRecv::mqdes</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00061">RTT::mqueue::MQSendRecv::mtransport</a>, and <a class="el" href="classRTT_1_1types_1_1TypeMarshaller.html#aa35cc5d6eaa9d60cd0bf24e73590c622">RTT::types::TypeMarshaller::updateFromBlob()</a>.</p>

<p>Referenced by <a class="el" href="MQChannelElement_8hpp_source.html#l00128">RTT::mqueue::MQChannelElement&lt; T &gt;::signal()</a>.</p>

</div>
</div>
<a class="anchor" id="a1131df7142246c91f3c6573471828908"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MQSendRecv::mqReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html">base::ChannelElementBase</a> *&#160;</td>
          <td class="paramname"><em>chan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Works only in receive mode, waits for a new sample and adapts the receive buffer to match it's size. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="MQSendRecv_8cpp_source.html#l00198">198</a> of file <a class="el" href="MQSendRecv_8cpp_source.html">MQSendRecv.cpp</a>.</p>

<p>References <a class="el" href="MQSendRecv_8hpp_source.html#l00079">RTT::mqueue::MQSendRecv::buf</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00067">RTT::mqueue::MQSendRecv::marshaller_cookie</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00091">RTT::mqueue::MQSendRecv::max_size</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00087">RTT::mqueue::MQSendRecv::minit_done</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00083">RTT::mqueue::MQSendRecv::mis_sender</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00071">RTT::mqueue::MQSendRecv::mqdes</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00061">RTT::mqueue::MQSendRecv::mtransport</a>, and <a class="el" href="classRTT_1_1types_1_1TypeMarshaller.html#aa35cc5d6eaa9d60cd0bf24e73590c622">RTT::types::TypeMarshaller::updateFromBlob()</a>.</p>

<p>Referenced by <a class="el" href="MQChannelElement_8hpp_source.html#l00089">RTT::mqueue::MQChannelElement&lt; T &gt;::inputReady()</a>.</p>

</div>
</div>
<a class="anchor" id="a6725c130af22d7abe1035e88fa1b6e44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MQSendRecv::mqWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write to the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ds</td><td>the data sample to write </td></tr>
    <tr><td class="paramname">is_data_sample</td><td>true if the sample is used for initialization, false if it is a proper write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it could be sent. </dd></dl>

<p>Definition at line <a class="el" href="MQSendRecv_8cpp_source.html#l00291">291</a> of file <a class="el" href="MQSendRecv_8cpp_source.html">MQSendRecv.cpp</a>.</p>

<p>References <a class="el" href="MQSendRecv_8hpp_source.html#l00079">RTT::mqueue::MQSendRecv::buf</a>, <a class="el" href="classRTT_1_1types_1_1TypeMarshaller.html#acb946c48dd52e635847105bccdcc0234">RTT::types::TypeMarshaller::fillBlob()</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00067">RTT::mqueue::MQSendRecv::marshaller_cookie</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00091">RTT::mqueue::MQSendRecv::max_size</a>, <a class="el" href="MQSendRecv_8hpp_source.html#l00071">RTT::mqueue::MQSendRecv::mqdes</a>, and <a class="el" href="MQSendRecv_8hpp_source.html#l00061">RTT::mqueue::MQSendRecv::mtransport</a>.</p>

<p>Referenced by <a class="el" href="MQChannelElement_8hpp_source.html#l00162">RTT::mqueue::MQChannelElement&lt; T &gt;::write()</a>.</p>

</div>
</div>
<a class="anchor" id="aea35c7c532583dc011f23513094ded03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a> <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">RTT::base::ChannelElement</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">reference_t&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_old_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a sample from the connection. </p>
<p><em>sample</em> is a reference which will get updated if a sample is available. The method returns true if a sample was available, and false otherwise. If false is returned, then <em>sample</em> is not modified by the method </p>

<p>Reimplemented in <a class="el" href="classRTT_1_1base_1_1MultipleInputsChannelElement.html#a619f4de76f479a1b410e645cc9507e11">RTT::base::MultipleInputsChannelElement&lt; T &gt;</a>, <a class="el" href="classRTT_1_1internal_1_1ChannelBufferElement.html#a25ab43756bedb550a5084804bae936e2">RTT::internal::ChannelBufferElement&lt; T &gt;</a>, and <a class="el" href="classRTT_1_1internal_1_1ChannelDataElement.html#aafb8b2b04e13eff6b11ed23388b6a2d9">RTT::internal::ChannelDataElement&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="ChannelElement_8hpp_source.html#l00121">121</a> of file <a class="el" href="ChannelElement_8hpp_source.html">ChannelElement.hpp</a>.</p>

<p>References <a class="el" href="ChannelElement_8hpp_source.html#l00121">RTT::base::ChannelElement&lt; T &gt;::read()</a>.</p>

<p>Referenced by <a class="el" href="ChannelElement_8hpp_source.html#l00121">RTT::base::ChannelElement&lt; T &gt;::read()</a>, <a class="el" href="RemoteChannelElement_8hpp_source.html#l00293">RTT::corba::RemoteChannelElement&lt; T &gt;::read()</a>, and <a class="el" href="MQChannelElement_8hpp_source.html#l00128">RTT::mqueue::MQChannelElement&lt; T &gt;::signal()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c2ffd366d9161f3e6087ad173adca60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a> <a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">RTT::mqueue::MQChannelElement</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::reference_t&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_old_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>stores the resulting data sample. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an item could be read. </dd></dl>

<p>Definition at line <a class="el" href="MQChannelElement_8hpp_source.html#l00152">152</a> of file <a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07f2b157dd0ff6a6f0159a782dc17771"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChannelElementBase::removeInput </td>
          <td>(</td>
          <td class="paramtype">shared_ptr const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an input from the inputs list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the element to be removed, or null to remove unconditionally </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1base_1_1MultipleInputsChannelElementBase.html#a804a858994f4106f83ca4d1a94fff6e1">RTT::base::MultipleInputsChannelElementBase</a>, and <a class="el" href="classRTT_1_1base_1_1MultipleInputsChannelElement.html#a6a2c92c5af6549213121e7ad63ec4987">RTT::base::MultipleInputsChannelElement&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00117">117</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="ChannelInterface_8cpp_source.html#l00098">RTT::base::ChannelElementBase::connectFrom()</a>.</p>

</div>
</div>
<a class="anchor" id="a7dcc89cab2e2ddb78eb00262691325c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChannelElementBase::removeOutput </td>
          <td>(</td>
          <td class="paramtype">shared_ptr const &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an output from the outputs list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the element to be removed, or null to remove unconditionally </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1base_1_1MultipleOutputsChannelElementBase.html#a449d523dbcd940e8645d2a3b7afa5f06">RTT::base::MultipleOutputsChannelElementBase</a>.</p>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00090">90</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="ChannelInterface_8cpp_source.html#l00071">RTT::base::ChannelElementBase::connectTo()</a>.</p>

</div>
</div>
<a class="anchor" id="abf12aec54e7a4e436e6608f35bcbc1d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChannelElementBase::setBufferPolicy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="group__Ports.html#gadc680c5e9ed12ee0889933483c89b7ea">BufferPolicy</a> of this channel element. </p>
<p>The BufferPolicy controls how reads and writes are handled for channel elements which have multiple connections. The policy can only be set once unless the force argument is set to true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>the new buffer policy </td></tr>
    <tr><td class="paramname">force</td><td>overwrite a buffer policy set previously </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given policy was successfully applied </dd></dl>

<p>Definition at line <a class="el" href="ChannelInterface_8cpp_source.html#l00213">213</a> of file <a class="el" href="ChannelInterface_8cpp_source.html">ChannelInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="ConnFactory_8hpp_source.html#l00224">RTT::internal::ConnFactory::buildChannelInput()</a>, <a class="el" href="ConnFactory_8hpp_source.html#l00310">RTT::internal::ConnFactory::buildChannelOutput()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00263">RTT::base::MultipleInputsChannelElementBase::removeInput()</a>, and <a class="el" href="ChannelInterface_8cpp_source.html#l00367">RTT::base::MultipleOutputsChannelElementBase::removeOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="a17bec196982377f40a7691b1854d8586"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">RTT::mqueue::MQChannelElement</a>&lt; T &gt;::signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal will cause a read-write cycle to transfer the data from the data/buffer element to the message queue and vice versa. </p>
<p>Note: this virtual function is a bit abused. For a sending MQ, signal triggers a direct read on the data element. For a receiving MQ, signal is used by the dispatcher thread to provoque a read from the MQ and forward it to the next channel element.</p>
<p>In the sending case, signal could trigger a dispatcher thread that does the read/write cycle, but that seems only causing overhead. The receiving case must use a thread which blocks on all mq file descriptors. </p>
<dl class="section return"><dt>Returns</dt><dd>true in case the forwarding could be done, false otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#aa985c67248dbe492db1f53b5b7c54c21">RTT::base::ChannelElementBase</a>.</p>

<p>Definition at line <a class="el" href="MQChannelElement_8hpp_source.html#l00128">128</a> of file <a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a>.</p>

<p>References <a class="el" href="MQSendRecv_8hpp_source.html#l00083">RTT::mqueue::MQSendRecv::mis_sender</a>, <a class="el" href="MQSendRecv_8cpp_source.html#l00276">RTT::mqueue::MQSendRecv::mqRead()</a>, <a class="el" href="ChannelElement_8hpp_source.html#l00121">RTT::base::ChannelElement&lt; T &gt;::read()</a>, <a class="el" href="ChannelElement_8hpp_source.html#l00108">RTT::base::ChannelElement&lt; T &gt;::write()</a>, and <a class="el" href="MQChannelElement_8hpp_source.html#l00162">RTT::mqueue::MQChannelElement&lt; T &gt;::write()</a>.</p>

</div>
</div>
<a class="anchor" id="a3cb94e4d3efe114af8a8360650b40635"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRTT.html#a69b4aafe4f409edc68481d7429efe198">WriteStatus</a> <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">RTT::base::ChannelElement</a>&lt; T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">param_t&#160;</td>
          <td class="paramname"><em>sample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a new sample on this connection. </p>
<p><em>sample</em> is the sample to write.</p>
<dl class="section return"><dt>Returns</dt><dd>false if an error occured that requires the channel to be invalidated. In no ways it indicates that the sample has been received by the other side of the channel. </dd></dl>

<p>Reimplemented in <a class="el" href="classRTT_1_1base_1_1MultipleOutputsChannelElement.html#a9aa73bd66a7d93dbc313bd0f279b1844">RTT::base::MultipleOutputsChannelElement&lt; T &gt;</a>, <a class="el" href="classRTT_1_1internal_1_1ConnOutputEndpoint.html#a1697a322cf9b6a807066ac828bd18ec7">RTT::internal::ConnOutputEndpoint&lt; T &gt;</a>, <a class="el" href="classRTT_1_1internal_1_1ChannelBufferElement.html#ae9483913f07d21ef2194b620b8553222">RTT::internal::ChannelBufferElement&lt; T &gt;</a>, and <a class="el" href="classRTT_1_1internal_1_1ChannelDataElement.html#a47f370009b877a8eb57cd51b1d90fe05">RTT::internal::ChannelDataElement&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="ChannelElement_8hpp_source.html#l00108">108</a> of file <a class="el" href="ChannelElement_8hpp_source.html">ChannelElement.hpp</a>.</p>

<p>References <a class="el" href="ChannelElement_8hpp_source.html#l00108">RTT::base::ChannelElement&lt; T &gt;::write()</a>.</p>

<p>Referenced by <a class="el" href="MQChannelElement_8hpp_source.html#l00128">RTT::mqueue::MQChannelElement&lt; T &gt;::signal()</a>, <a class="el" href="ChannelElement_8hpp_source.html#l00108">RTT::base::ChannelElement&lt; T &gt;::write()</a>, <a class="el" href="ConnOutputEndPoint_8hpp_source.html#l00110">RTT::internal::ConnOutputEndpoint&lt; T &gt;::write()</a>, <a class="el" href="ChannelElement_8hpp_source.html#l00324">RTT::base::MultipleOutputsChannelElement&lt; T &gt;::write()</a>, and <a class="el" href="RemoteChannelElement_8hpp_source.html#l00371">RTT::corba::RemoteChannelElement&lt; T &gt;::write()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d32d8cd63a269e021d4f0cde39879d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRTT.html#a69b4aafe4f409edc68481d7429efe198">WriteStatus</a> <a class="el" href="classRTT_1_1mqueue_1_1MQChannelElement.html">RTT::mqueue::MQChannelElement</a>&lt; T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::param_t&#160;</td>
          <td class="paramname"><em>sample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write to the message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>the data sample to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it could be sent. </dd></dl>

<p>Definition at line <a class="el" href="MQChannelElement_8hpp_source.html#l00162">162</a> of file <a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a>.</p>

<p>References <a class="el" href="MQSendRecv_8cpp_source.html#l00291">RTT::mqueue::MQSendRecv::mqWrite()</a>.</p>

<p>Referenced by <a class="el" href="MQChannelElement_8hpp_source.html#l00128">RTT::mqueue::MQChannelElement&lt; T &gt;::signal()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a191d2d7bcc44bb99ba59f5a95c6be678"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* RTT::mqueue::MQSendRecv::buf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send/Receive buffer. </p>
<p>It is initialized to the size of the value provided by the <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> or, if the policy has a zero data size, the sample given to setupStream</p>
<p>Its size is saved in max_size </p>

<p>Definition at line <a class="el" href="MQSendRecv_8hpp_source.html#l00079">79</a> of file <a class="el" href="MQSendRecv_8hpp_source.html">MQSendRecv.hpp</a>.</p>

<p>Referenced by <a class="el" href="MQSendRecv_8cpp_source.html#l00188">RTT::mqueue::MQSendRecv::mqNewSample()</a>, <a class="el" href="MQSendRecv_8cpp_source.html#l00276">RTT::mqueue::MQSendRecv::mqRead()</a>, <a class="el" href="MQSendRecv_8cpp_source.html#l00198">RTT::mqueue::MQSendRecv::mqReady()</a>, and <a class="el" href="MQSendRecv_8cpp_source.html#l00291">RTT::mqueue::MQSendRecv::mqWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="a12a0b2227bd4d9cccec2607227fecd59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* RTT::mqueue::MQSendRecv::marshaller_cookie</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A private blob that is returned by mtransport.getCookie(). </p>
<p>It is used by the marshallers if they need private internal data to do the marshalling </p>

<p>Definition at line <a class="el" href="MQSendRecv_8hpp_source.html#l00067">67</a> of file <a class="el" href="MQSendRecv_8hpp_source.html">MQSendRecv.hpp</a>.</p>

<p>Referenced by <a class="el" href="MQSendRecv_8cpp_source.html#l00276">RTT::mqueue::MQSendRecv::mqRead()</a>, <a class="el" href="MQSendRecv_8cpp_source.html#l00198">RTT::mqueue::MQSendRecv::mqReady()</a>, and <a class="el" href="MQSendRecv_8cpp_source.html#l00291">RTT::mqueue::MQSendRecv::mqWrite()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>rtt/transports/mqueue/<a class="el" href="MQChannelElement_8hpp_source.html">MQChannelElement.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 5 2017 17:46:01 for Orocos Real-Time Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
