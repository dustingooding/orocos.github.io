<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Orocos Real-Time Toolkit: RTT::internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a></li><li class="navelem"><a class="el" href="namespaceRTT_1_1internal.html">internal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">RTT::internal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes which contain all implementation code for the <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute. ">RTT</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ArrayPartDataSource.html">ArrayPartDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to manipulate a reference to a part of a data source holding a C-style array of elements.  <a href="classRTT_1_1internal_1_1ArrayPartDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AssignCommand.html">AssignCommand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a command that will assign the value of an expression to another at runtime.  <a href="classRTT_1_1internal_1_1AssignCommand.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AtomicMWMRQueue.html">AtomicMWMRQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an atomic, non-blocking single ended queue (FIFO) for storing a <b>pointer</b> to <em>T</em>.  <a href="classRTT_1_1internal_1_1AtomicMWMRQueue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AtomicMWSRQueue.html">AtomicMWSRQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an atomic, non-blocking Multi-Writer Single-Reader FIFO for storing a pointer <em>T</em> by value.  <a href="classRTT_1_1internal_1_1AtomicMWSRQueue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AtomicQueue.html">AtomicQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic, non-blocking single ended queue (FIFO) for storing a <b>pointer</b> to <em>T</em>.  <a href="classRTT_1_1internal_1_1AtomicQueue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1AStore.html">AStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a bound argument which may be a reference, const reference or any other type.  <a href="structRTT_1_1internal_1_1AStore.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1RStore.html">RStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a return value which may be a void, reference, const reference or any other type.  <a href="structRTT_1_1internal_1_1RStore.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1is__arg__return.html">is_arg_return</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper struct is required to filter out the <a class="el" href="structRTT_1_1internal_1_1AStore.html" title="Store a bound argument which may be a reference, const reference or any other type. ">AStore</a> elements that don't need to be returned to the user when collect or return is called.  <a href="structRTT_1_1internal_1_1is__arg__return.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1is__out__arg.html">is_out_arg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outargs are of type <a class="el" href="structRTT_1_1internal_1_1AStore.html" title="Store a bound argument which may be a reference, const reference or any other type. ">AStore</a> and contain a pure reference.  <a href="structRTT_1_1internal_1_1is__out__arg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1BindStorageImpl_3_010_00_01ToBind_01_4.html">BindStorageImpl&lt; 0, ToBind &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When no arguments are to be stored, the implementation stores the function in a boost::function object.  <a href="structRTT_1_1internal_1_1BindStorageImpl_3_010_00_01ToBind_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1BindStorageImpl_3_011_00_01ToBind_01_4.html">BindStorageImpl&lt; 1, ToBind &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a pointer to a function and its arguments.  <a href="structRTT_1_1internal_1_1BindStorageImpl_3_011_00_01ToBind_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1BindStorage.html">BindStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper-class for the Command implementation which stores the command and collition function objects.  <a href="structRTT_1_1internal_1_1BindStorage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ChannelBufferElement.html">ChannelBufferElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A connection element that can store a fixed number of data samples.  <a href="classRTT_1_1internal_1_1ChannelBufferElement.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ChannelDataElement.html">ChannelDataElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A connection element that stores a single data sample.  <a href="classRTT_1_1internal_1_1ChannelDataElement.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1Collect.html">Collect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct takes the user's Function signature <em>F</em> and transforms it to the form required in the CollectImpl template specialisations.  <a href="structRTT_1_1internal_1_1Collect.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1CollectBaseImpl.html">CollectBaseImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collection signature is formed by Ft, which is a transformed form of F.  <a href="structRTT_1_1internal_1_1CollectBaseImpl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1CollectBase.html">CollectBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct takes the user's Function signature <em>F</em> and transforms it to the form required in the <a class="el" href="structRTT_1_1internal_1_1CollectBaseImpl.html" title="The collection signature is formed by Ft, which is a transformed form of F. ">CollectBaseImpl</a> template specialisations.  <a href="structRTT_1_1internal_1_1CollectBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1CollectType.html">CollectType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper struct decomposes F and creates Ft, as required by <a class="el" href="structRTT_1_1internal_1_1CollectBaseImpl.html" title="The collection signature is formed by Ft, which is a transformed form of F. ">CollectBaseImpl</a>.  <a href="structRTT_1_1internal_1_1CollectType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1CollectSignature.html">CollectSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to implement collect(), given a Function Signature.  <a href="structRTT_1_1internal_1_1CollectSignature.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnectionManager.html">ConnectionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages connections between ports.  <a href="classRTT_1_1internal_1_1ConnectionManager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1LocalConnID.html">LocalConnID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a local connection created by the <a class="el" href="classRTT_1_1internal_1_1ConnFactory.html" title="This class provides the basic tools to create channels that represent connections between two ports...">ConnFactory</a>.  <a href="structRTT_1_1internal_1_1LocalConnID.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1StreamConnID.html">StreamConnID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Stream connection created by the <a class="el" href="classRTT_1_1internal_1_1ConnFactory.html" title="This class provides the basic tools to create channels that represent connections between two ports...">ConnFactory</a>.  <a href="structRTT_1_1internal_1_1StreamConnID.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html">ConnFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the basic tools to create channels that represent connections between two ports.  <a href="classRTT_1_1internal_1_1ConnFactory.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnID.html">ConnID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used in places where a permanent representation of a reference to a connection is needed.  <a href="classRTT_1_1internal_1_1ConnID.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1SimpleConnID.html">SimpleConnID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simplistic id that is only same with its own clones (and clones of clones).  <a href="classRTT_1_1internal_1_1SimpleConnID.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnInputEndpoint.html">ConnInputEndpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a channel element that represents the input endpoint of a connection, i.e.  <a href="classRTT_1_1internal_1_1ConnInputEndpoint.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnOutputEndpoint.html">ConnOutputEndpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a channel element that represents the output endpoint of a connection, i.e.  <a href="classRTT_1_1internal_1_1ConnOutputEndpoint.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataStore.html">DataStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a bound argument which may be a reference, const reference or any other type.  <a href="structRTT_1_1internal_1_1DataStore.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1GetArgument.html">GetArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for extracting the bare pointer from a shared_ptr data source.  <a href="structRTT_1_1internal_1_1GetArgument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1GetArgument_3_01Seq_00_01Data_00_01typename_01boost_1_1enable__if_3_01i22dd4b1e6d13d9a6954ee3e459085881.html">GetArgument&lt; Seq, Data, typename boost::enable_if&lt; is_pure_reference&lt; Data &gt; &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this case, Data is a pure reference and the first element of Seq is an <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html" title="A DataSource which has set() methods. ">AssignableDataSource</a>.  <a href="structRTT_1_1internal_1_1GetArgument_3_01Seq_00_01Data_00_01typename_01boost_1_1enable__if_3_01i22dd4b1e6d13d9a6954ee3e459085881.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1AssignHelper.html">AssignHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for avoiding assigning a bare pointer to a shared_ptr data source.  <a href="structRTT_1_1internal_1_1AssignHelper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1UpdateHelper.html">UpdateHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to only update data sources that hold references.  <a href="structRTT_1_1internal_1_1UpdateHelper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1create__sequence__helper.html">create_sequence_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to convert a single data source base to a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> or <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html" title="A DataSource which has set() methods. ">AssignableDataSource</a>.  <a href="structRTT_1_1internal_1_1create__sequence__helper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1create__sequence.html">create_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can create three kinds of Boost Fusion Sequences.  <a href="structRTT_1_1internal_1_1create__sequence.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1DataObjectDataSource.html">DataObjectDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to read a DataObject.  <a href="classRTT_1_1internal_1_1DataObjectDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1bad__assignment.html">bad_assignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown if the target and source type of an assignment of a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> with a <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html" title="The base class for all internal data representations. ">base::DataSourceBase</a> differ.  <a href="structRTT_1_1internal_1_1bad__assignment.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">DataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> is a base class representing a generic way to read data of type <em>T</em>.  <a href="classRTT_1_1internal_1_1DataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html">AssignableDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which has <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html#a3fbb0b9564941923b5776b413bf75813" title="Get a reference to the value of this DataSource. ">set()</a> methods.  <a href="classRTT_1_1internal_1_1AssignableDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1DataSourceCommand.html">DataSourceCommand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that wraps a Command in a internal::DataSource&lt;bool&gt; interface.  <a href="classRTT_1_1internal_1_1DataSourceCommand.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1GenerateDataSource.html">GenerateDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function object which returns a vector of DataSources.  <a href="structRTT_1_1internal_1_1GenerateDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ValueDataSource.html">ValueDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple, yet very useful <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a>, which keeps a value, and returns it in its <a class="el" href="classRTT_1_1internal_1_1ValueDataSource.html#a49beaea7df1ad6bfa31bcb15e47299cc" title="Return the data as type T. ">get()</a> method.  <a href="classRTT_1_1internal_1_1ValueDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConstantDataSource.html">ConstantDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which holds a constant value and returns it in its <a class="el" href="classRTT_1_1internal_1_1ConstantDataSource.html#a274b252292bcf3ae47b41128fb05cd45" title="Return the data as type T. ">get()</a> method.  <a href="classRTT_1_1internal_1_1ConstantDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConstReferenceDataSource.html">ConstReferenceDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to read a const reference to an external value.  <a href="classRTT_1_1internal_1_1ConstReferenceDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ReferenceDataSource.html">ReferenceDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to manipulate a reference to an external value.  <a href="classRTT_1_1internal_1_1ReferenceDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AliasDataSource.html">AliasDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to mirror another datasource.  <a href="classRTT_1_1internal_1_1AliasDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ArrayDataSource.html">ArrayDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> that holds a fixed size array, using the <a class="el" href="classRTT_1_1types_1_1carray.html" title="Wraps a C array such that we can return a C array from a DataSource. ">types::carray</a> class.  <a href="classRTT_1_1internal_1_1ArrayDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1LateReferenceDataSource.html">LateReferenceDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to manipulate a reference to an external value, by means of a pointer, which can be set after the data source was created.  <a href="classRTT_1_1internal_1_1LateReferenceDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1LateConstReferenceDataSource.html">LateConstReferenceDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to manipulate a const reference to an external value, by means of a pointer, which can be set after the data source was created.  <a href="classRTT_1_1internal_1_1LateConstReferenceDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ActionAliasDataSource.html">ActionAliasDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to execute an action and then return the value of another <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a>.  <a href="classRTT_1_1internal_1_1ActionAliasDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ActionAliasAssignableDataSource.html">ActionAliasAssignableDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html" title="A DataSource which has set() methods. ">AssignableDataSource</a> which is used to execute an action and then return the value of another <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a>.  <a href="classRTT_1_1internal_1_1ActionAliasAssignableDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1UnboundDataSource.html">UnboundDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> only to be used for if you understand the copy()/clone() semantics very well.  <a href="classRTT_1_1internal_1_1UnboundDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1BinaryDataSource.html">BinaryDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic binary composite <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a>.  <a href="classRTT_1_1internal_1_1BinaryDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1UnaryDataSource.html">UnaryDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which returns the return value of a unary function.  <a href="classRTT_1_1internal_1_1UnaryDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1NArityDataSource.html">NArityDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic N-arity composite <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a>.  <a href="classRTT_1_1internal_1_1NArityDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DSRStore.html">DSRStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="structRTT_1_1internal_1_1RStore.html" title="Store a return value which may be a void, reference, const reference or any other type...">RStore</a>, but specific for <a class="el" href="structRTT_1_1internal_1_1DataSourceStorage.html" title="A helper-class for the Command implementation which stores the command and condition function objects...">DataSourceStorage</a>.  <a href="structRTT_1_1internal_1_1DSRStore.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceResultStorage.html">DataSourceResultStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisations for storing a void, not a void or reference Wraps around <a class="el" href="structRTT_1_1internal_1_1RStore.html" title="Store a return value which may be a void, reference, const reference or any other type...">RStore</a>.  <a href="structRTT_1_1internal_1_1DataSourceResultStorage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceResultStorage_3_01R_01const_01_6_01_4.html">DataSourceResultStorage&lt; R const &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceArgStorage.html">DataSourceArgStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisations for storing a (const) reference or not reference The trick here is to take a (const) reference data source to something that was already a reference, and copy to a value data source for something that is plain value.  <a href="structRTT_1_1internal_1_1DataSourceArgStorage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceArgStorage_3_01A_01_6_01_4.html">DataSourceArgStorage&lt; A &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisations for storing a reference.  <a href="structRTT_1_1internal_1_1DataSourceArgStorage_3_01A_01_6_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceArgStorage_3_01A_01const_01_6_01_4.html">DataSourceArgStorage&lt; A const &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisations for storing a const reference.  <a href="structRTT_1_1internal_1_1DataSourceArgStorage_3_01A_01const_01_6_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceStorageImpl_3_010_00_01DataType_01_4.html">DataSourceStorageImpl&lt; 0, DataType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When no arguments are to be stored.  <a href="structRTT_1_1internal_1_1DataSourceStorageImpl_3_010_00_01DataType_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceStorageImpl_3_011_00_01DataType_01_4.html">DataSourceStorageImpl&lt; 1, DataType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores one data source.  <a href="structRTT_1_1internal_1_1DataSourceStorageImpl_3_011_00_01DataType_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceStorage.html">DataSourceStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper-class for the Command implementation which stores the command and condition function objects.  <a href="structRTT_1_1internal_1_1DataSourceStorage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceTypeInfo.html">DataSourceTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> of type T has a type info class which it can ask type information.  <a href="structRTT_1_1internal_1_1DataSourceTypeInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceTypeInfo_3_01UnknownType_01_4.html">DataSourceTypeInfo&lt; UnknownType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers the default implementation of type information for an unknown type.  <a href="structRTT_1_1internal_1_1DataSourceTypeInfo_3_01UnknownType_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceTypeInfo_3_01const_01T_01_6_01_4.html">DataSourceTypeInfo&lt; const T &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These specialisations only serve to find out if a type T is a pointer, or reference, or...  <a href="structRTT_1_1internal_1_1DataSourceTypeInfo_3_01const_01T_01_6_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceTypeInfo_3_01types_1_1carray_3_01T_01_4_01_4.html">DataSourceTypeInfo&lt; types::carray&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for a types::carray&lt;T&gt; type info object.  <a href="structRTT_1_1internal_1_1DataSourceTypeInfo_3_01types_1_1carray_3_01T_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceTypeInfo_3_01void_01_4.html">DataSourceTypeInfo&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(void) is a special case.  <a href="structRTT_1_1internal_1_1DataSourceTypeInfo_3_01void_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1FusedFunctorDataSource.html">FusedFunctorDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> that calls a functor of signature <em>Signature</em> which gets its arguments from other data sources.  <a href="structRTT_1_1internal_1_1FusedFunctorDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1FusedMCallDataSource.html">FusedMCallDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> that calls a method which gets its arguments from other data sources.  <a href="structRTT_1_1internal_1_1FusedMCallDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1FusedMSendDataSource.html">FusedMSendDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> that sends a method which gets its arguments from other data sources.  <a href="structRTT_1_1internal_1_1FusedMSendDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1FusedMCollectDataSource.html">FusedMCollectDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> that collects the result of an asynchronous method which store its results in other data sources.  <a href="structRTT_1_1internal_1_1FusedMCollectDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1FusedMSignal.html">FusedMSignal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Function object that reacts to a <a class="el" href="classRTT_1_1internal_1_1Signal.html" title="Very lightweight wrapper around the signalN classes that allows signals to be created where the numbe...">Signal</a> by writing the arguments in data sources and calling an action object.  <a href="structRTT_1_1internal_1_1FusedMSignal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1GetSignature.html">GetSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function signature from a C or C++ member function pointer type.  <a href="structRTT_1_1internal_1_1GetSignature.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1GetSignatureDS.html">GetSignatureDS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function signature from a C or C++ member function pointer type, suitable for DS operations.  <a href="structRTT_1_1internal_1_1GetSignatureDS.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1GlobalEngine.html">GlobalEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A process-wide execution engine that processes every asynchronous operation that is not being processed by a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>.  <a href="classRTT_1_1internal_1_1GlobalEngine.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1GlobalService.html">GlobalService</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A process-wide services that hosts services not local to a single component.  <a href="classRTT_1_1internal_1_1GlobalService.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1InputPortSource.html">InputPortSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a read port using the data source interface.  <a href="classRTT_1_1internal_1_1InputPortSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1Invoker.html">Invoker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an invocation object with a function signature to invoke and an implementation in which an operator(args) is available which has this signature.  <a href="structRTT_1_1internal_1_1Invoker.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1InvokerBaseImpl.html">InvokerBaseImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which converts a function type signature <em>F</em> to a virtual send()/call() interface.  <a href="structRTT_1_1internal_1_1InvokerBaseImpl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1InvokerBase.html">InvokerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class that defines the interface of all invocable method implementations.  <a href="structRTT_1_1internal_1_1InvokerBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1InvokerSignature.html">InvokerSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by various classes to define operator(), given a Signature.  <a href="structRTT_1_1internal_1_1InvokerSignature.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1List.html">List</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object represents the default queue implementation used by <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> objects.  <a href="classRTT_1_1internal_1_1List.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ListLocked.html">ListLocked</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>simple</em> lock-based list implementation to <em>append</em> or <em>erase</em> data of type <em>T</em>.  <a href="classRTT_1_1internal_1_1ListLocked.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ListLockFree.html">ListLockFree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>simple</em> lock-free list implementation to <em>append</em> or <em>erase</em> data of type <em>T</em>.  <a href="classRTT_1_1internal_1_1ListLockFree.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html">LocalOperationCallerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements call, send, collect, collectIfDone for all function arities.  <a href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1LocalOperationCaller.html">LocalOperationCaller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method which executes a local function.  <a href="structRTT_1_1internal_1_1LocalOperationCaller.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1LockedQueue.html">LockedQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock-based queue implementation to <em>enqueue</em> or <em>dequeue</em> a pointer of type <em>T</em>.  <a href="classRTT_1_1internal_1_1LockedQueue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1MWSRQueue.html">MWSRQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object represents the default Multi-Writer, Single-Reader queue implementation used by <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> objects.  <a href="classRTT_1_1internal_1_1MWSRQueue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1NA.html">NA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to return a 'default' value when no value is available ('Not Available').  <a href="structRTT_1_1internal_1_1NA.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1NA_3_01void_01_4.html">NA&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation to return a void.  <a href="structRTT_1_1internal_1_1NA_3_01void_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1OperationCallerBinder.html">OperationCallerBinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very simple <b>factory</b> class to bind a member function to an object pointer and leave the arguments open.  <a href="structRTT_1_1internal_1_1OperationCallerBinder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1OperationCallerC.html">OperationCallerC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template-less manager for <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> calls.  <a href="classRTT_1_1internal_1_1OperationCallerC.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1OperationInterfacePartFused.html">OperationInterfacePartFused</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1OperationInterfacePart.html" title="This class defines the interface for creating operation objects without using C++ templates...">OperationInterfacePart</a> implementation that uses boost::fusion to produce items.  <a href="classRTT_1_1internal_1_1OperationInterfacePartFused.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1SynchronousOperationInterfacePartFused.html">SynchronousOperationInterfacePartFused</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1OperationInterfacePart.html" title="This class defines the interface for creating operation objects without using C++ templates...">OperationInterfacePart</a> implementation that only provides synchronous access to an operation.  <a href="classRTT_1_1internal_1_1SynchronousOperationInterfacePartFused.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1OperationInterfacePartFusedDS.html">OperationInterfacePartFusedDS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1OperationInterfacePart.html" title="This class defines the interface for creating operation objects without using C++ templates...">OperationInterfacePart</a> implementation that uses boost::fusion to produce items.  <a href="classRTT_1_1internal_1_1OperationInterfacePartFusedDS.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1PartDataSource.html">PartDataSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to manipulate a reference to a part of a data source.  <a href="classRTT_1_1internal_1_1PartDataSource.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1PartDataSource_3_01types_1_1carray_3_01T_01_4_01_4.html">PartDataSource&lt; types::carray&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of <a class="el" href="classRTT_1_1internal_1_1PartDataSource.html" title="A DataSource which is used to manipulate a reference to a part of a data source. ">PartDataSource</a> for carray&lt;T&gt; types.  <a href="classRTT_1_1internal_1_1PartDataSource_3_01types_1_1carray_3_01T_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1Queue.html">Queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object represents the default Multi-Writer/Multi-Reader queue implementation used by <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> objects.  <a href="classRTT_1_1internal_1_1Queue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1Reference.html">Reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object that may receive a reference to some data by means of a pointer or data source.  <a href="classRTT_1_1internal_1_1Reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1RemoteOperationCallerImpl.html">RemoteOperationCallerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> implementation which executes a remote function which is encapsulated in a <a class="el" href="classRTT_1_1internal_1_1OperationCallerC.html" title="A template-less manager for OperationCaller calls. ">OperationCallerC</a> and <a class="el" href="classRTT_1_1internal_1_1SendHandleC.html" title="A template-less SendHandle manager. ">SendHandleC</a> object.  <a href="classRTT_1_1internal_1_1RemoteOperationCallerImpl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1RemoteOperationCaller.html">RemoteOperationCaller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> implementation which delegates C++ to datasource conversions when C++ code tries to call remote operations, only available in an <a class="el" href="classRTT_1_1OperationInterfacePart.html" title="This class defines the interface for creating operation objects without using C++ templates...">OperationInterfacePart</a>, and not through an OperationBase.  <a href="classRTT_1_1internal_1_1RemoteOperationCaller.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1ReturnImpl.html">ReturnImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of ret() which takes the same signature as call().  <a href="structRTT_1_1internal_1_1ReturnImpl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1ReturnBaseImpl.html">ReturnBaseImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of ret() which takes the same signature as call().  <a href="structRTT_1_1internal_1_1ReturnBaseImpl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1ReturnBase.html">ReturnBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class that defines the interface of returning data from method invocations.  <a href="structRTT_1_1internal_1_1ReturnBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1ReturnSignature.html">ReturnSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines ret(), given a Signature.  <a href="structRTT_1_1internal_1_1ReturnSignature.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1Signal.html">Signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very lightweight wrapper around the signalN classes that allows signals to be created where the number of arguments does not need to be part of the class name.  <a href="classRTT_1_1internal_1_1Signal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AddMember.html">AddMember</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of <a class="el" href="classRTT_1_1internal_1_1UnMember.html" title="This class converts a member function type R (X::)(Args) to a plain function type R (Args) which can ...">UnMember</a>.  <a href="classRTT_1_1internal_1_1AddMember.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ArgMember.html">ArgMember</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A complexer variant of <a class="el" href="classRTT_1_1internal_1_1UnMember.html" title="This class converts a member function type R (X::)(Args) to a plain function type R (Args) which can ...">UnMember</a>: Convert a member function type to a function type which contains the object as first argument.  <a href="classRTT_1_1internal_1_1ArgMember.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1UnMember.html">UnMember</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class converts a member function type R (X::)(Args) to a plain function type R (Args) which can be used by a boost::function or similar.  <a href="classRTT_1_1internal_1_1UnMember.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1UnPointer.html">UnPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a function R (X::)(Args) to a plain function signature R(X::,Args)  <a href="classRTT_1_1internal_1_1UnPointer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1TsPool.html">TsPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-reader multi-writer MemoryPool implementation.  <a href="classRTT_1_1internal_1_1TsPool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1SendHandleC.html">SendHandleC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template-less <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation. ">SendHandle</a> manager.  <a href="classRTT_1_1internal_1_1SendHandleC.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1SharedConnID.html">SharedConnID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shared connection created by the <a class="el" href="classRTT_1_1internal_1_1ConnFactory.html" title="This class provides the basic tools to create channels that represent connections between two ports...">ConnFactory</a>.  <a href="structRTT_1_1internal_1_1SharedConnID.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1SharedConnectionBase.html">SharedConnectionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for shared connection elements.  <a href="classRTT_1_1internal_1_1SharedConnectionBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1SharedConnectionRepository.html">SharedConnectionRepository</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A repository which stores pointers to all shared connections within the process.  <a href="classRTT_1_1internal_1_1SharedConnectionRepository.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnectionBase.html">ConnectionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A connection 'memorises' the connection between an event and an event handler function.  <a href="classRTT_1_1internal_1_1ConnectionBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1SignalBase.html">SignalBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base signal class which stores connection objects.  <a href="classRTT_1_1internal_1_1SignalBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adb1333f58dba27cc82f0979aa38e1779"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb1333f58dba27cc82f0979aa38e1779"></a>
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1internal_1_1ConnFactory.html">ConnFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConnFactoryPtr</b></td></tr>
<tr class="separator:adb1333f58dba27cc82f0979aa38e1779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c804133917d07cdd5c2ae148e5467b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c804133917d07cdd5c2ae148e5467b6"></a>
typedef <br class="typebreak"/>
boost::enable_shared_from_this<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1Service.html">Service</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shared_from_raw</b></td></tr>
<tr class="separator:a9c804133917d07cdd5c2ae148e5467b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a116779cd1720013c123a0e085d2814e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a116779cd1720013c123a0e085d2814e9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a116779cd1720013c123a0e085d2814e9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, <a class="el" href="structRTT_1_1internal_1_1AStore.html">AStore</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a116779cd1720013c123a0e085d2814e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1011ece335eacfba9ed091a309dd91"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e1011ece335eacfba9ed091a309dd91"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9e1011ece335eacfba9ed091a309dd91"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, <a class="el" href="structRTT_1_1internal_1_1RStore.html">RStore</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a9e1011ece335eacfba9ed091a309dd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983e88dd436f624e90b48e75fbe9f164"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a983e88dd436f624e90b48e75fbe9f164"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>catch_exception</b> ()</td></tr>
<tr class="separator:a983e88dd436f624e90b48e75fbe9f164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a9e49d4f3c57bdd09353cc6d7bd076"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a34a9e49d4f3c57bdd09353cc6d7bd076"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1internal.html#a34a9e49d4f3c57bdd09353cc6d7bd076">newFunctorDataSource</a> (Function f, const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;args)</td></tr>
<tr class="memdesc:a34a9e49d4f3c57bdd09353cc6d7bd076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data source that returns the result of a given function.  <a href="#a34a9e49d4f3c57bdd09353cc6d7bd076">More...</a><br/></td></tr>
<tr class="separator:a34a9e49d4f3c57bdd09353cc6d7bd076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f0b09ad0e0acb35ada47d98bb98420"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5f0b09ad0e0acb35ada47d98bb98420"></a>
void RTT_API&#160;</td><td class="memItemRight" valign="bottom"><b>intrusive_ptr_add_ref</b> (RTT::internal::IntrusiveStorage *p)</td></tr>
<tr class="separator:ae5f0b09ad0e0acb35ada47d98bb98420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71f04c06994cdd830e9b3bf9976dbea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af71f04c06994cdd830e9b3bf9976dbea"></a>
void RTT_API&#160;</td><td class="memItemRight" valign="bottom"><b>intrusive_ptr_release</b> (RTT::internal::IntrusiveStorage *p)</td></tr>
<tr class="separator:af71f04c06994cdd830e9b3bf9976dbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c852043ef185ffe215db7fb2ea34f1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c852043ef185ffe215db7fb2ea34f1d"></a>
template&lt;typename MapT &gt; </td></tr>
<tr class="memitem:a7c852043ef185ffe215db7fb2ea34f1d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
MapT::mapped_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>values</b> (const MapT &amp;map)</td></tr>
<tr class="separator:a7c852043ef185ffe215db7fb2ea34f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae738cae12b3c0c74046181622cc34ea7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae738cae12b3c0c74046181622cc34ea7"></a>
template&lt;typename MapT &gt; </td></tr>
<tr class="memitem:ae738cae12b3c0c74046181622cc34ea7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <br class="typebreak"/>
MapT::key_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keys</b> (const MapT &amp;map)</td></tr>
<tr class="separator:ae738cae12b3c0c74046181622cc34ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac066dbf9a5516507e896674e23da2448"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac066dbf9a5516507e896674e23da2448"></a>
template&lt;typename ResultT , typename Arg1T , typename Arg2T , typename Arg3T &gt; </td></tr>
<tr class="memitem:ac066dbf9a5516507e896674e23da2448"><td class="memTemplItemLeft" align="right" valign="top">pointer_to_ternary_function<br class="typebreak"/>
&lt; ResultT, Arg1T, Arg2T, Arg3T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ptr_fun</b> (ResultT(*fun)(Arg1T, Arg2T, Arg3T))</td></tr>
<tr class="separator:ac066dbf9a5516507e896674e23da2448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a13cae1049392d42c67b1b05e8ca8d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a91a13cae1049392d42c67b1b05e8ca8d"></a>
template&lt;typename ResultT , typename Arg1T , typename Arg2T , typename Arg3T , typename Arg4T , typename Arg5T , typename Arg6T &gt; </td></tr>
<tr class="memitem:a91a13cae1049392d42c67b1b05e8ca8d"><td class="memTemplItemLeft" align="right" valign="top">pointer_to_sixary_function<br class="typebreak"/>
&lt; ResultT, Arg1T, Arg2T, Arg3T, <br class="typebreak"/>
Arg4T, Arg5T, Arg6T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ptr_fun</b> (ResultT(*fun)(Arg1T, Arg2T, Arg3T, Arg4T, Arg5T, Arg6T))</td></tr>
<tr class="separator:a91a13cae1049392d42c67b1b05e8ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf7b29696801a19586c0a8f172217e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cf7b29696801a19586c0a8f172217e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>intrusive_ptr_add_ref</b> (<a class="el" href="classRTT_1_1internal_1_1ConnectionBase.html">ConnectionBase</a> *p)</td></tr>
<tr class="separator:a3cf7b29696801a19586c0a8f172217e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198771eb159952110c03696dedca0e01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a198771eb159952110c03696dedca0e01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>intrusive_ptr_release</b> (<a class="el" href="classRTT_1_1internal_1_1ConnectionBase.html">ConnectionBase</a> *p)</td></tr>
<tr class="separator:a198771eb159952110c03696dedca0e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d317c2b04a8db75bc62d4b84b6453d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d317c2b04a8db75bc62d4b84b6453d5"></a>
<a class="el" href="classRTT_1_1internal_1_1ConnectionBase.html">ConnectionBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPointer</b> (ConnectionBase::shared_ptr c)</td></tr>
<tr class="separator:a3d317c2b04a8db75bc62d4b84b6453d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a25e042379097111623ca13a952b2ccc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25e042379097111623ca13a952b2ccc9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_catch_exception</b> =-1</td></tr>
<tr class="separator:a25e042379097111623ca13a952b2ccc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Classes which contain all implementation code for the <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute. ">RTT</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a34a9e49d4f3c57bdd09353cc6d7bd076"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a>* RTT::internal::newFunctorDataSource </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; base::DataSourceBase::shared_ptr &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data source that returns the result of a given function. </p>
<p>Use <a class="el" href="structRTT_1_1internal_1_1GenerateDataSource.html" title="A function object which returns a vector of DataSources. ">GenerateDataSource</a> to create the arguments args from given data sources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to embed in a data source. The return type of this function will be the return type of the created data source. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments given to the function <em>f</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new data source. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td>when args.size() is not equal to the arity of <em>f</em>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td>when one or more types in args do not match the expected types in f. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="FusedFunctorDataSource_8hpp_source.html#l00240">240</a> of file <a class="el" href="FusedFunctorDataSource_8hpp_source.html">FusedFunctorDataSource.hpp</a>.</p>

<p>References <a class="el" href="FusedFunctorDataSource_8hpp_source.html#l00240">newFunctorDataSource()</a>.</p>

<p>Referenced by <a class="el" href="FusedFunctorDataSource_8hpp_source.html#l00240">newFunctorDataSource()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 16 2016 19:25:30 for Orocos Real-Time Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
