<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Orocos Real-Time Toolkit: RTT::InputPort&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a></li><li class="navelem"><a class="el" href="classRTT_1_1InputPort.html">InputPort</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classRTT_1_1InputPort-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RTT::InputPort&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Ports.html">Data Flow Ports</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A component's data input port.  
 <a href="classRTT_1_1InputPort.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="InputPort_8hpp_source.html">rtt/InputPort.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTT::InputPort&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRTT_1_1InputPort.png" usemap="#RTT::InputPort&lt; T &gt;_map" alt=""/>
  <map id="RTT::InputPort&lt; T &gt;_map" name="RTT::InputPort&lt; T &gt;_map">
<area href="classRTT_1_1base_1_1InputPortInterface.html" title="The base class of the InputPort. " alt="RTT::base::InputPortInterface" shape="rect" coords="0,56,173,80"/>
<area href="classRTT_1_1base_1_1PortInterface.html" title="The base class of every data flow port. " alt="RTT::base::PortInterface" shape="rect" coords="0,0,173,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a73b96103b09672346bcb21c5da3695ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73b96103b09672346bcb21c5da3695ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InputPort</b> (std::string const &amp;name=&quot;unnamed&quot;, ConnPolicy const &amp;default_policy=<a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a>())</td></tr>
<tr class="separator:a73b96103b09672346bcb21c5da3695ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d60c8f15d5f728e90d021e78ddcd05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4d60c8f15d5f728e90d021e78ddcd05"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#af4d60c8f15d5f728e90d021e78ddcd05">clear</a> ()</td></tr>
<tr class="memdesc:af4d60c8f15d5f728e90d021e78ddcd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the input buffer (or all input buffers), so that <a class="el" href="classRTT_1_1InputPort.html#a8167df81370f58c85603820f97310251">read()</a> will return NoData before a new sample has been written. <br/></td></tr>
<tr class="separator:af4d60c8f15d5f728e90d021e78ddcd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8167df81370f58c85603820f97310251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#a8167df81370f58c85603820f97310251">read</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source)</td></tr>
<tr class="separator:a8167df81370f58c85603820f97310251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270efcef40b55f9c5192665d34d04fcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#a270efcef40b55f9c5192665d34d04fcf">read</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source, bool copy_old_data)</td></tr>
<tr class="memdesc:a270efcef40b55f9c5192665d34d04fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the port and updates the value hold by the given data source.  <a href="#a270efcef40b55f9c5192665d34d04fcf">More...</a><br/></td></tr>
<tr class="separator:a270efcef40b55f9c5192665d34d04fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f3b2b72ac22a1a39f24eae29015298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#af5f3b2b72ac22a1a39f24eae29015298">readNewest</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source, bool copy_old_data=true)</td></tr>
<tr class="memdesc:af5f3b2b72ac22a1a39f24eae29015298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all new samples that are available on this port, and returns the last one.  <a href="#af5f3b2b72ac22a1a39f24eae29015298">More...</a><br/></td></tr>
<tr class="separator:af5f3b2b72ac22a1a39f24eae29015298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b4999024273fd728de1dd988550069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#a95b4999024273fd728de1dd988550069">read</a> (typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::reference_t sample)</td></tr>
<tr class="separator:a95b4999024273fd728de1dd988550069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e98125fb587c31b7663d635d43eb2a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#a1e98125fb587c31b7663d635d43eb2a8">read</a> (typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::reference_t sample, bool copy_old_data)</td></tr>
<tr class="memdesc:a1e98125fb587c31b7663d635d43eb2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a sample from the connection.  <a href="#a1e98125fb587c31b7663d635d43eb2a8">More...</a><br/></td></tr>
<tr class="separator:a1e98125fb587c31b7663d635d43eb2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8640bae13f2b85bffd473b8a76169f19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#a8640bae13f2b85bffd473b8a76169f19">readNewest</a> (typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::reference_t sample, bool copy_old_data=true)</td></tr>
<tr class="memdesc:a8640bae13f2b85bffd473b8a76169f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all new samples that are available on this port, and returns the last one.  <a href="#a8640bae13f2b85bffd473b8a76169f19">More...</a><br/></td></tr>
<tr class="separator:a8640bae13f2b85bffd473b8a76169f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaf0a04b9e7090eb662c7d91de47120"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#affaf0a04b9e7090eb662c7d91de47120">getDataSample</a> (T &amp;sample)</td></tr>
<tr class="memdesc:affaf0a04b9e7090eb662c7d91de47120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sample of the data on this port, without actually reading the port's data.  <a href="#affaf0a04b9e7090eb662c7d91de47120">More...</a><br/></td></tr>
<tr class="separator:affaf0a04b9e7090eb662c7d91de47120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaad05cd96e5f2d9128f5446e1d16771"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaad05cd96e5f2d9128f5446e1d16771"></a>
virtual const <a class="el" href="classRTT_1_1types_1_1TypeInfo.html">types::TypeInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#acaad05cd96e5f2d9128f5446e1d16771">getTypeInfo</a> () const </td></tr>
<tr class="memdesc:acaad05cd96e5f2d9128f5446e1d16771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type. ...">types::TypeInfo</a> object for the port's type. <br/></td></tr>
<tr class="separator:acaad05cd96e5f2d9128f5446e1d16771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8028ae5951d994536c51889975baad1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8028ae5951d994536c51889975baad1c"></a>
virtual <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#a8028ae5951d994536c51889975baad1c">clone</a> () const </td></tr>
<tr class="memdesc:a8028ae5951d994536c51889975baad1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a clone of this port with the same name. <br/></td></tr>
<tr class="separator:a8028ae5951d994536c51889975baad1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01f161bdd68dea7fe9fd8918668ec35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa01f161bdd68dea7fe9fd8918668ec35"></a>
virtual <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#aa01f161bdd68dea7fe9fd8918668ec35">antiClone</a> () const </td></tr>
<tr class="memdesc:aa01f161bdd68dea7fe9fd8918668ec35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the anti-clone (inverse port) of this port with the same name A port for reading will return a new port for writing and vice versa. <br/></td></tr>
<tr class="separator:aa01f161bdd68dea7fe9fd8918668ec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0aafca2988526f61cdde6cd473f56c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#a3e0aafca2988526f61cdde6cd473f56c">getDataSource</a> ()</td></tr>
<tr class="memdesc:a3e0aafca2988526f61cdde6cd473f56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html" title="The base class for all internal data representations. ">base::DataSourceBase</a> interface to read this port.  <a href="#a3e0aafca2988526f61cdde6cd473f56c">More...</a><br/></td></tr>
<tr class="separator:a3e0aafca2988526f61cdde6cd473f56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49af94675fe1711dfb9c7607077d107e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#a49af94675fe1711dfb9c7607077d107e">createStream</a> (<a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="memdesc:a49af94675fe1711dfb9c7607077d107e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data stream from or to this port using connection-less transports.  <a href="#a49af94675fe1711dfb9c7607077d107e">More...</a><br/></td></tr>
<tr class="separator:a49af94675fe1711dfb9c7607077d107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd981129bffa516bca0e3cef0935aff4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd981129bffa516bca0e3cef0935aff4"></a>
virtual <a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#abd981129bffa516bca0e3cef0935aff4">createPortObject</a> ()</td></tr>
<tr class="memdesc:abd981129bffa516bca0e3cef0935aff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create accessor Object for this Port, for addition to a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> Object interface. <br/></td></tr>
<tr class="separator:abd981129bffa516bca0e3cef0935aff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96f706f941d8cefa9576c25b1a221f2"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1internal_1_1ConnOutputEndpoint.html">internal::ConnOutputEndpoint</a><br class="typebreak"/>
&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1InputPort.html#ab96f706f941d8cefa9576c25b1a221f2">getEndpoint</a> () const </td></tr>
<tr class="memdesc:ab96f706f941d8cefa9576c25b1a221f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input or output endpoint of this port (if any).  <a href="#ab96f706f941d8cefa9576c25b1a221f2">More...</a><br/></td></tr>
<tr class="separator:ab96f706f941d8cefa9576c25b1a221f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720ca1ef3cce1788bca468f18adf4b19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a720ca1ef3cce1788bca468f18adf4b19"></a>
virtual <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a><br class="typebreak"/>
&lt; T &gt;::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>getSharedBuffer</b> () const </td></tr>
<tr class="separator:a720ca1ef3cce1788bca468f18adf4b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7c3ffe5568763ab09310f0ba1acbc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f7c3ffe5568763ab09310f0ba1acbc1"></a>
<a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultPolicy</b> () const </td></tr>
<tr class="separator:a5f7c3ffe5568763ab09310f0ba1acbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20f60ec3122fa54fd1b823c76b5627a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#af20f60ec3122fa54fd1b823c76b5627a">addConnection</a> (<a class="el" href="classRTT_1_1internal_1_1ConnID.html">internal::ConnID</a> *port_id, ChannelElementBase::shared_ptr channel, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="memdesc:af20f60ec3122fa54fd1b823c76b5627a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a user created connection to this port.  <a href="#af20f60ec3122fa54fd1b823c76b5627a">More...</a><br/></td></tr>
<tr class="separator:af20f60ec3122fa54fd1b823c76b5627a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70be1ab5a8f69c102bea50b47dad4c6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70be1ab5a8f69c102bea50b47dad4c6c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#a70be1ab5a8f69c102bea50b47dad4c6c">disconnect</a> ()</td></tr>
<tr class="memdesc:a70be1ab5a8f69c102bea50b47dad4c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any connection that either go to or come from this port <em>and</em> removes all callbacks and cleans up the NewDataOnPortEvent. <br/></td></tr>
<tr class="separator:a70be1ab5a8f69c102bea50b47dad4c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af506a1db9628755fa8b31a6325637a13"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#af506a1db9628755fa8b31a6325637a13">disconnect</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> *port)</td></tr>
<tr class="memdesc:af506a1db9628755fa8b31a6325637a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the channel that connects this port to <code>port</code>.  <a href="#af506a1db9628755fa8b31a6325637a13">More...</a><br/></td></tr>
<tr class="separator:af506a1db9628755fa8b31a6325637a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d36f261f7f5464b112b4d164ac0374"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27d36f261f7f5464b112b4d164ac0374"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#a27d36f261f7f5464b112b4d164ac0374">connected</a> () const </td></tr>
<tr class="memdesc:a27d36f261f7f5464b112b4d164ac0374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this port is connected. <br/></td></tr>
<tr class="separator:a27d36f261f7f5464b112b4d164ac0374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95d54ee56886bdab20eca3dc4017df8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab95d54ee56886bdab20eca3dc4017df8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#ab95d54ee56886bdab20eca3dc4017df8">signalInterface</a> (bool true_false)</td></tr>
<tr class="memdesc:ab95d54ee56886bdab20eca3dc4017df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called with <b>true</b>, will signal the <a class="el" href="classRTT_1_1DataFlowInterface.html" title="The Interface of a TaskContext which exposes its data-flow ports. ">DataFlowInterface</a> when new data is available. <br/></td></tr>
<tr class="separator:ab95d54ee56886bdab20eca3dc4017df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6473f26ea0a6bfc6669ce2ae861850e9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#a6473f26ea0a6bfc6669ce2ae861850e9">connectTo</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> *other, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="memdesc:a6473f26ea0a6bfc6669ce2ae861850e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects this port with <em>other</em>, using the given policy.  <a href="#a6473f26ea0a6bfc6669ce2ae861850e9">More...</a><br/></td></tr>
<tr class="separator:a6473f26ea0a6bfc6669ce2ae861850e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d23ccfc567f217127b83ea822b9910"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#a42d23ccfc567f217127b83ea822b9910">connectTo</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> *other)</td></tr>
<tr class="memdesc:a42d23ccfc567f217127b83ea822b9910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects this port with <em>other</em>, using the default policy of the input.  <a href="#a42d23ccfc567f217127b83ea822b9910">More...</a><br/></td></tr>
<tr class="separator:a42d23ccfc567f217127b83ea822b9910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc36dbc50b0ea3d3639369633640631"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affc36dbc50b0ea3d3639369633640631"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#affc36dbc50b0ea3d3639369633640631">createConnection</a> (internal::SharedConnectionBase::shared_ptr shared_connection, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy=<a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a>())</td></tr>
<tr class="memdesc:affc36dbc50b0ea3d3639369633640631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects the port to an existing shared connection instance. <br/></td></tr>
<tr class="separator:affc36dbc50b0ea3d3639369633640631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91b3e2733b8928f41eb96b5b8794fe8"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#af91b3e2733b8928f41eb96b5b8794fe8">buildRemoteChannelOutput</a> (<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> &amp;output_port, <a class="el" href="classRTT_1_1types_1_1TypeInfo.html">types::TypeInfo</a> const *type_info, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;input, const <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> &amp;policy)</td></tr>
<tr class="memdesc:af91b3e2733b8928f41eb96b5b8794fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is analoguous to the static <a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a201dd38c725e5e3de7c9a3465f8b8797" title="Creates the output endpoint of a communication channel and adds it to an InputPort. ">ConnFactory::buildChannelOutput</a>.  <a href="#af91b3e2733b8928f41eb96b5b8794fe8">More...</a><br/></td></tr>
<tr class="separator:af91b3e2733b8928f41eb96b5b8794fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4120c928e760540bd17fee8c7c8722f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4120c928e760540bd17fee8c7c8722f"></a>
virtual <a class="el" href="classRTT_1_1internal_1_1ConnID.html">internal::ConnID</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#aa4120c928e760540bd17fee8c7c8722f">getPortID</a> () const </td></tr>
<tr class="memdesc:aa4120c928e760540bd17fee8c7c8722f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identity of this port in a ConnID object. <br/></td></tr>
<tr class="separator:aa4120c928e760540bd17fee8c7c8722f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bc3d97cfcb408a4452334323df7ffd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2bc3d97cfcb408a4452334323df7ffd"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#ad2bc3d97cfcb408a4452334323df7ffd">getName</a> () const </td></tr>
<tr class="memdesc:ad2bc3d97cfcb408a4452334323df7ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this Port. <br/></td></tr>
<tr class="separator:ad2bc3d97cfcb408a4452334323df7ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc00aa5b85d1d8aa9b5f2b105809b89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#a2bc00aa5b85d1d8aa9b5f2b105809b89">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2bc00aa5b85d1d8aa9b5f2b105809b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the name of this unconnected Port.  <a href="#a2bc00aa5b85d1d8aa9b5f2b105809b89">More...</a><br/></td></tr>
<tr class="separator:a2bc00aa5b85d1d8aa9b5f2b105809b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6d640f7a6f5c3485b70bb2672e13e1"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#a6d6d640f7a6f5c3485b70bb2672e13e1">getDescription</a> () const </td></tr>
<tr class="memdesc:a6d6d640f7a6f5c3485b70bb2672e13e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the documentation of this port.  <a href="#a6d6d640f7a6f5c3485b70bb2672e13e1">More...</a><br/></td></tr>
<tr class="separator:a6d6d640f7a6f5c3485b70bb2672e13e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bed453e1d7211b72d81707efe1bd192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#a4bed453e1d7211b72d81707efe1bd192">doc</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:a4bed453e1d7211b72d81707efe1bd192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the documentation of this port.  <a href="#a4bed453e1d7211b72d81707efe1bd192">More...</a><br/></td></tr>
<tr class="separator:a4bed453e1d7211b72d81707efe1bd192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac700cd806a5dfc2e8923177c376544e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac700cd806a5dfc2e8923177c376544e0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#ac700cd806a5dfc2e8923177c376544e0">connectedTo</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> *port)</td></tr>
<tr class="memdesc:ac700cd806a5dfc2e8923177c376544e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this port is connected to the given port. <br/></td></tr>
<tr class="separator:ac700cd806a5dfc2e8923177c376544e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32595f49031daead1d5c98d28b91c32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae32595f49031daead1d5c98d28b91c32"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#ae32595f49031daead1d5c98d28b91c32">isLocal</a> () const </td></tr>
<tr class="memdesc:ae32595f49031daead1d5c98d28b91c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this port is located on this process, and false otherwise. <br/></td></tr>
<tr class="separator:ae32595f49031daead1d5c98d28b91c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0a475868cc8387eb05c116c572a192"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a0a475868cc8387eb05c116c572a192"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#a9a0a475868cc8387eb05c116c572a192">serverProtocol</a> () const </td></tr>
<tr class="memdesc:a9a0a475868cc8387eb05c116c572a192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the protocol over which this port can be accessed. <br/></td></tr>
<tr class="separator:a9a0a475868cc8387eb05c116c572a192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20940635dea5904477c5170b7ca71fd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#ae20940635dea5904477c5170b7ca71fd">removeConnection</a> (<a class="el" href="classRTT_1_1internal_1_1ConnID.html">internal::ConnID</a> *cid)</td></tr>
<tr class="memdesc:ae20940635dea5904477c5170b7ca71fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a user created connection from this port.  <a href="#ae20940635dea5904477c5170b7ca71fd">More...</a><br/></td></tr>
<tr class="separator:ae20940635dea5904477c5170b7ca71fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963599af7a0eb16cca2d4cdda9ba9fe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#a963599af7a0eb16cca2d4cdda9ba9fe4">setInterface</a> (<a class="el" href="classRTT_1_1DataFlowInterface.html">DataFlowInterface</a> *iface)</td></tr>
<tr class="memdesc:a963599af7a0eb16cca2d4cdda9ba9fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once a port is added to a <a class="el" href="classRTT_1_1DataFlowInterface.html" title="The Interface of a TaskContext which exposes its data-flow ports. ">DataFlowInterface</a>, it gets a pointer to that interface.  <a href="#a963599af7a0eb16cca2d4cdda9ba9fe4">More...</a><br/></td></tr>
<tr class="separator:a963599af7a0eb16cca2d4cdda9ba9fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53d9ec4f148fd83cc6cd1819e0d451b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae53d9ec4f148fd83cc6cd1819e0d451b"></a>
<a class="el" href="classRTT_1_1DataFlowInterface.html">DataFlowInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#ae53d9ec4f148fd83cc6cd1819e0d451b">getInterface</a> () const </td></tr>
<tr class="memdesc:ae53d9ec4f148fd83cc6cd1819e0d451b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classRTT_1_1DataFlowInterface.html" title="The Interface of a TaskContext which exposes its data-flow ports. ">DataFlowInterface</a> this port belongs to or null if it was not added to such an interface. <br/></td></tr>
<tr class="separator:ae53d9ec4f148fd83cc6cd1819e0d451b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dee8b31490b0ed69d6403622a4a1103"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="classRTT_1_1internal_1_1ConnectionManager.html">internal::ConnectionManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#a5dee8b31490b0ed69d6403622a4a1103">getManager</a> ()</td></tr>
<tr class="memdesc:a5dee8b31490b0ed69d6403622a4a1103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connection manager of this port (if any).  <a href="#a5dee8b31490b0ed69d6403622a4a1103">More...</a><br/></td></tr>
<tr class="separator:a5dee8b31490b0ed69d6403622a4a1103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9affe57d417800aae5ee2ec5baeca578"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9affe57d417800aae5ee2ec5baeca578"></a>
virtual <br class="typebreak"/>
internal::SharedConnectionBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1PortInterface.html#a9affe57d417800aae5ee2ec5baeca578">getSharedConnection</a> () const </td></tr>
<tr class="memdesc:a9affe57d417800aae5ee2ec5baeca578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the shared connection element this port may be connected to. <br/></td></tr>
<tr class="separator:a9affe57d417800aae5ee2ec5baeca578"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a36785fa5f76e8967be971e080a4980fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36785fa5f76e8967be971e080a4980fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#a36785fa5f76e8967be971e080a4980fa">signal</a> ()</td></tr>
<tr class="memdesc:a36785fa5f76e8967be971e080a4980fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ConnOutputEndpoint signals that new data is available. <br/></td></tr>
<tr class="separator:a36785fa5f76e8967be971e080a4980fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae349f154f173ce329803f46f82c6ec9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae349f154f173ce329803f46f82c6ec9a"></a>
<a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><b>default_policy</b></td></tr>
<tr class="separator:ae349f154f173ce329803f46f82c6ec9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add145fc36fc1e92acd44dd3cc9b9e678"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add145fc36fc1e92acd44dd3cc9b9e678"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>msignal_interface</b></td></tr>
<tr class="separator:add145fc36fc1e92acd44dd3cc9b9e678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443f4f4190553cb557fc793506d77a4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a443f4f4190553cb557fc793506d77a4a"></a>
<a class="el" href="classRTT_1_1DataFlowInterface.html">DataFlowInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>iface</b></td></tr>
<tr class="separator:a443f4f4190553cb557fc793506d77a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37ae51a012ccb9aeed756e55333eec6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac37ae51a012ccb9aeed756e55333eec6"></a>
<a class="el" href="classRTT_1_1internal_1_1ConnectionManager.html">internal::ConnectionManager</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cmanager</b></td></tr>
<tr class="separator:ac37ae51a012ccb9aeed756e55333eec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:adc45a5b4692959ada5c1f6d2655afbe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc45a5b4692959ada5c1f6d2655afbe8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>internal::ConnOutputEndpoint&lt; T &gt;</b></td></tr>
<tr class="separator:adc45a5b4692959ada5c1f6d2655afbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class RTT::InputPort&lt; T &gt;</h3>

<p>A component's data input port. </p>
<p>An <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> input port is used to receive data samples from a distant publisher. The <a class="el" href="classRTT_1_1InputPort.html" title="A component&#39;s data input port. ">InputPort</a> is <a class="el" href="classRTT_1_1InputPort.html#a8167df81370f58c85603820f97310251">read()</a> and returns true if a sample is available.</p>
<p>Ideally, your algorithm should not assume a certain connection policy being used from output to input. So it should work on data connections and buffer connections. </p>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00063">63</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af20f60ec3122fa54fd1b823c76b5627a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool InputPortInterface::addConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1ConnID.html">internal::ConnID</a> *&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChannelElementBase::shared_ptr&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a user created connection to this port. </p>
<p>This is an advanced method, prefer to use connectTo and createStream. </p>

<p>Implements <a class="el" href="classRTT_1_1base_1_1PortInterface.html#afd0a2f0f27d5575c27b9515c88af0c85">RTT::base::PortInterface</a>.</p>

<p>Reimplemented in <a class="el" href="classRTT_1_1corba_1_1RemoteInputPort.html#ae28b009417586ab394aa31d3b7a8e9f6">RTT::corba::RemoteInputPort</a>.</p>

<p>Definition at line <a class="el" href="InputPortInterface_8cpp_source.html#l00100">100</a> of file <a class="el" href="InputPortInterface_8cpp_source.html">InputPortInterface.cpp</a>.</p>

<p>References <a class="el" href="ConnectionManager_8cpp_source.html#l00122">RTT::internal::ConnectionManager::addConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="af91b3e2733b8928f41eb96b5b8794fe8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">base::ChannelElementBase::shared_ptr InputPortInterface::buildRemoteChannelOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>output_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html">types::TypeInfo</a> const *&#160;</td>
          <td class="paramname"><em>type_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is analoguous to the static <a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a201dd38c725e5e3de7c9a3465f8b8797" title="Creates the output endpoint of a communication channel and adds it to an InputPort. ">ConnFactory::buildChannelOutput</a>. </p>
<p>It is provided for remote connection building: for these connections, no template can be used and therefore the connection setup should be done based on the <a class="el" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type. ...">types::TypeInfo</a> object </p>

<p>Reimplemented in <a class="el" href="classRTT_1_1corba_1_1RemoteInputPort.html#a95ca04580a87413e3751b16cd145d078">RTT::corba::RemoteInputPort</a>.</p>

<p>Definition at line <a class="el" href="InputPortInterface_8cpp_source.html#l00138">138</a> of file <a class="el" href="InputPortInterface_8cpp_source.html">InputPortInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6473f26ea0a6bfc6669ce2ae861850e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool InputPortInterface::connectTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects this port with <em>other</em>, using the given policy. </p>
<p>Unlike <a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html#a5c8858d877b53d2b89156e254a8b8834" title="Connects this write port to the given read port, using as policy the default policy of the sink port...">OutputPortInterface::createConnection</a>, <em>other</em> can be the write port and <code>this</code> the read port.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

<p>Implements <a class="el" href="classRTT_1_1base_1_1PortInterface.html#a1ff55db413f3ff6c944eb4249d559af7">RTT::base::PortInterface</a>.</p>

<p>Definition at line <a class="el" href="InputPortInterface_8cpp_source.html#l00085">85</a> of file <a class="el" href="InputPortInterface_8cpp_source.html">InputPortInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html#a5c8858d877b53d2b89156e254a8b8834">RTT::base::OutputPortInterface::createConnection()</a>, and <a class="el" href="PortInterface_8hpp_source.html#l00079">RTT::base::PortInterface::getName()</a>.</p>

<p>Referenced by <a class="el" href="InputPortInterface_8cpp_source.html#l00095">RTT::base::InputPortInterface::connectTo()</a>.</p>

</div>
</div>
<a class="anchor" id="a42d23ccfc567f217127b83ea822b9910"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool InputPortInterface::connectTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects this port with <em>other</em>, using the default policy of the input. </p>
<p>Unlike <a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html#a5c8858d877b53d2b89156e254a8b8834" title="Connects this write port to the given read port, using as policy the default policy of the sink port...">OutputPortInterface::createConnection</a>, <em>other</em> can be the write port and <code>this</code> the read port.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

<p>Implements <a class="el" href="classRTT_1_1base_1_1PortInterface.html#af2f4b28e71d40e6df027ffff924e909e">RTT::base::PortInterface</a>.</p>

<p>Definition at line <a class="el" href="InputPortInterface_8cpp_source.html#l00095">95</a> of file <a class="el" href="InputPortInterface_8cpp_source.html">InputPortInterface.cpp</a>.</p>

<p>References <a class="el" href="InputPortInterface_8cpp_source.html#l00085">RTT::base::InputPortInterface::connectTo()</a>.</p>

</div>
</div>
<a class="anchor" id="a49af94675fe1711dfb9c7607077d107e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classRTT_1_1InputPort.html">RTT::InputPort</a>&lt; T &gt;::createStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a data stream from or to this port using connection-less transports. </p>
<p>Typically, policy.transport and policy.name_id must be properly filled in such that the data stream can be set up and input and output port can find each other. You need to call this method on two ports (input and output) using the same transport and (probably) same name_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The connection policy describing how the stream must be set up. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRTT_1_1base_1_1PortInterface.html#a1599147a15dbfbb62defbee0c51b65f6">RTT::base::PortInterface</a>.</p>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00205">205</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>

<p>References <a class="el" href="ConnFactory_8hpp_source.html#l00545">RTT::internal::ConnFactory::createStream()</a>.</p>

</div>
</div>
<a class="anchor" id="af506a1db9628755fa8b31a6325637a13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool InputPortInterface::disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> *&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the channel that connects this port to <code>port</code>. </p>
<p>All other ports or callbacks remain unaffected. </p>

<p>Implements <a class="el" href="classRTT_1_1base_1_1PortInterface.html#affbe1e1e7320acf6e85402858f28ee1f">RTT::base::PortInterface</a>.</p>

<p>Reimplemented in <a class="el" href="classRTT_1_1corba_1_1RemoteInputPort.html#a05f6fa01d8c610b7b2d446013f9afd6c">RTT::corba::RemoteInputPort</a>.</p>

<p>Definition at line <a class="el" href="InputPortInterface_8cpp_source.html#l00128">128</a> of file <a class="el" href="InputPortInterface_8cpp_source.html">InputPortInterface.cpp</a>.</p>

<p>References <a class="el" href="ConnectionManager_8cpp_source.html#l00101">RTT::internal::ConnectionManager::disconnect()</a>.</p>

</div>
</div>
<a class="anchor" id="a4bed453e1d7211b72d81707efe1bd192"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> &amp; PortInterface::doc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the documentation of this port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>The description of the port </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

<p>Definition at line <a class="el" href="PortInterface_8cpp_source.html#l00060">60</a> of file <a class="el" href="PortInterface_8cpp_source.html">PortInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8cpp_source.html#l00229">RTT::DataFlowInterface::setPortDescription()</a>.</p>

<p>Referenced by <a class="el" href="InputPort_8hpp_source.html#l00215">RTT::InputPort&lt; T &gt;::createPortObject()</a>.</p>

</div>
</div>
<a class="anchor" id="affaf0a04b9e7090eb662c7d91de47120"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRTT_1_1InputPort.html">RTT::InputPort</a>&lt; T &gt;::getDataSample </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a sample of the data on this port, without actually reading the port's data. </p>
<p>It's the complement of <a class="el" href="classRTT_1_1OutputPort.html#a9ba3e7b6c569e312923a075f79bb92b4" title="Provides this port a data sample that is representative for the samples being used in write()...">OutputPort::setDataSample()</a> and serves to retrieve the size of a variable sized data type T. Returns default T if !connected() or if the <a class="el" href="classRTT_1_1OutputPort.html" title="A component&#39;s data output port. ">OutputPort</a> did not use setDataSample(). Returns an example T otherwise. In case multiple inputs are connected to this port a sample from the currently read connection will be returned. </p>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00174">174</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>

<p>References <a class="el" href="InputPort_8hpp_source.html#l00227">RTT::InputPort&lt; T &gt;::getEndpoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e0aafca2988526f61cdde6cd473f56c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a>* <a class="el" href="classRTT_1_1InputPort.html">RTT::InputPort</a>&lt; T &gt;::getDataSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html" title="The base class for all internal data representations. ">base::DataSourceBase</a> interface to read this port. </p>
<p>The returned data source is always a new object. </p>

<p>Implements <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#afd46e9b26cb9db8b9b117f6ab5e268f7">RTT::base::InputPortInterface</a>.</p>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00200">200</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d6d640f7a6f5c3485b70bb2672e13e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; RTT::base::PortInterface::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the documentation of this port. </p>
<dl class="section return"><dt>Returns</dt><dd>A description. </dd></dl>

<p>Definition at line <a class="el" href="PortInterface_8hpp_source.html#l00093">93</a> of file <a class="el" href="PortInterface_8hpp_source.html">PortInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab96f706f941d8cefa9576c25b1a221f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRTT_1_1internal_1_1ConnOutputEndpoint.html">internal::ConnOutputEndpoint</a>&lt;T&gt;* <a class="el" href="classRTT_1_1InputPort.html">RTT::InputPort</a>&lt; T &gt;::getEndpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the input or output endpoint of this port (if any). </p>
<p>This method provides access to the internals of this port in order to access connected channel objects directly. </p>

<p>Implements <a class="el" href="classRTT_1_1base_1_1PortInterface.html#af8d42fb68c00a6be39f2da0e57a8f47c">RTT::base::PortInterface</a>.</p>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00227">227</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>

<p>Referenced by <a class="el" href="ConnFactory_8hpp_source.html#l00310">RTT::internal::ConnFactory::buildChannelOutput()</a>, <a class="el" href="InputPort_8hpp_source.html#l00091">RTT::InputPort&lt; T &gt;::clear()</a>, <a class="el" href="InputPort_8hpp_source.html#l00174">RTT::InputPort&lt; T &gt;::getDataSample()</a>, and <a class="el" href="InputPort_8hpp_source.html#l00145">RTT::InputPort&lt; T &gt;::read()</a>.</p>

</div>
</div>
<a class="anchor" id="a5dee8b31490b0ed69d6403622a4a1103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRTT_1_1internal_1_1ConnectionManager.html">internal::ConnectionManager</a>* RTT::base::PortInterface::getManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the connection manager of this port (if any). </p>
<p>This method provides access to the internals of this port in order to allow connection introspection. </p>
<dl class="section return"><dt>Returns</dt><dd>null if no such manager is available, or the manager otherwise. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>ConnectionManager::getChannels() for a list of all connections of this port. </dd></dl>

<p>Definition at line <a class="el" href="PortInterface_8hpp_source.html#l00222">222</a> of file <a class="el" href="PortInterface_8hpp_source.html">PortInterface.hpp</a>.</p>

<p>Referenced by <a class="el" href="ConnInputEndPoint_8hpp_source.html#l00072">RTT::internal::ConnInputEndpoint&lt; T &gt;::disconnect()</a>, and <a class="el" href="ConnOutputEndPoint_8hpp_source.html#l00129">RTT::internal::ConnOutputEndpoint&lt; T &gt;::disconnect()</a>.</p>

</div>
</div>
<a class="anchor" id="a8167df81370f58c85603820f97310251"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a> <a class="el" href="classRTT_1_1InputPort.html">RTT::InputPort</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00097">97</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>

<p>Referenced by <a class="el" href="InputPortSource_8hpp_source.html#l00081">RTT::internal::InputPortSource&lt; T &gt;::evaluate()</a>, <a class="el" href="InputPort_8hpp_source.html#l00100">RTT::InputPort&lt; T &gt;::read()</a>, and <a class="el" href="InputPort_8hpp_source.html#l00156">RTT::InputPort&lt; T &gt;::readNewest()</a>.</p>

</div>
</div>
<a class="anchor" id="a270efcef40b55f9c5192665d34d04fcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a> <a class="el" href="classRTT_1_1InputPort.html">RTT::InputPort</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_old_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the port and updates the value hold by the given data source. </p>
<p>This is only valid for local ports.</p>
<p><em>source</em> has to be an assignable data source </p>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html#a41ffcb4d860f510b7e3c0b4f187a3ed0">RTT::base::InputPortInterface</a>.</p>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00100">100</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>

<p>References <a class="el" href="InputPort_8hpp_source.html#l00097">RTT::InputPort&lt; T &gt;::read()</a>, and <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html#a8d8768e83fae929586428a6cd66ca75a">RTT::internal::AssignableDataSource&lt; T &gt;::set()</a>.</p>

</div>
</div>
<a class="anchor" id="a95b4999024273fd728de1dd988550069"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a> <a class="el" href="classRTT_1_1InputPort.html">RTT::InputPort</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::reference_t&#160;</td>
          <td class="paramname"><em>sample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00131">131</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>

<p>References <a class="el" href="InputPort_8hpp_source.html#l00097">RTT::InputPort&lt; T &gt;::read()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e98125fb587c31b7663d635d43eb2a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a> <a class="el" href="classRTT_1_1InputPort.html">RTT::InputPort</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::reference_t&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_old_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a sample from the connection. </p>
<p><em>sample</em> is a reference which will get updated if a new sample is available.</p>
<p>The method returns an enum FlowStatus, which describes what type of sample (old or new data) or if a sample was returned (no data)</p>
<p>With the argument </p>
<ul>
<li>copy_old_data one can specify, if sample should be updated in the case that the return type is equal to RTT::OldData. In case </li>
<li>copy_old_data is false and an old sample is available, the method will still return RTT::OldData but the sample will not be updated. </li>
</ul>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00145">145</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>

<p>References <a class="el" href="InputPort_8hpp_source.html#l00227">RTT::InputPort&lt; T &gt;::getEndpoint()</a>.</p>

</div>
</div>
<a class="anchor" id="af5f3b2b72ac22a1a39f24eae29015298"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a> <a class="el" href="classRTT_1_1InputPort.html">RTT::InputPort</a>&lt; T &gt;::readNewest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_old_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read all new samples that are available on this port, and returns the last one. </p>
<p>Returns RTT::NewData if at least one new sample was available, and either RTT::OldData or RTT::NoData otherwise. </p>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00118">118</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html#a8d8768e83fae929586428a6cd66ca75a">RTT::internal::AssignableDataSource&lt; T &gt;::set()</a>.</p>

</div>
</div>
<a class="anchor" id="a8640bae13f2b85bffd473b8a76169f19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRTT.html#aa92dce4aa147272a093143330ef11ab6">FlowStatus</a> <a class="el" href="classRTT_1_1InputPort.html">RTT::InputPort</a>&lt; T &gt;::readNewest </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt;::reference_t&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_old_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read all new samples that are available on this port, and returns the last one. </p>
<p>Returns RTT::NewData if at least one new sample was available, and either RTT::OldData or RTT::NoData otherwise. </p>

<p>Definition at line <a class="el" href="InputPort_8hpp_source.html#l00156">156</a> of file <a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a>.</p>

<p>References <a class="el" href="InputPort_8hpp_source.html#l00097">RTT::InputPort&lt; T &gt;::read()</a>.</p>

</div>
</div>
<a class="anchor" id="ae20940635dea5904477c5170b7ca71fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PortInterface::removeConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1ConnID.html">internal::ConnID</a> *&#160;</td>
          <td class="paramname"><em>cid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a user created connection from this port. </p>
<p>This is an advanced method, prefer to use <a class="el" href="classRTT_1_1base_1_1PortInterface.html#aa9f3cecab5a948799111fc2671f5057c" title="Removes any connection that either go to or come from this port. ">disconnect()</a> or a method from a subclass of <a class="el" href="classRTT_1_1base_1_1PortInterface.html" title="The base class of every data flow port. ">PortInterface</a>. </p>

<p>Definition at line <a class="el" href="PortInterface_8cpp_source.html#l00095">95</a> of file <a class="el" href="PortInterface_8cpp_source.html">PortInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a963599af7a0eb16cca2d4cdda9ba9fe4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PortInterface::setInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1DataFlowInterface.html">DataFlowInterface</a> *&#160;</td>
          <td class="paramname"><em>iface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Once a port is added to a <a class="el" href="classRTT_1_1DataFlowInterface.html" title="The Interface of a TaskContext which exposes its data-flow ports. ">DataFlowInterface</a>, it gets a pointer to that interface. </p>
<p>This allows advanced ports to track back to which component they belong. </p>

<p>Definition at line <a class="el" href="PortInterface_8cpp_source.html#l00100">100</a> of file <a class="el" href="PortInterface_8cpp_source.html">PortInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00082">RTT::DataFlowInterface::addLocalPort()</a>.</p>

</div>
</div>
<a class="anchor" id="a2bc00aa5b85d1d8aa9b5f2b105809b89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PortInterface::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the name of this unconnected Port. </p>
<p>One can only change the name when it is not yet connected. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if !this-&gt;<a class="el" href="classRTT_1_1base_1_1PortInterface.html#a6751d5bbe9196013651b34294f72452c" title="Returns true if this port is connected. ">connected()</a>, the name has changed. </td></tr>
    <tr><td class="paramname">false</td><td>if this-&gt;<a class="el" href="classRTT_1_1base_1_1PortInterface.html#a6751d5bbe9196013651b34294f72452c" title="Returns true if this port is connected. ">connected()</a>, the name has not been changed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PortInterface_8cpp_source.html#l00051">51</a> of file <a class="el" href="PortInterface_8cpp_source.html">PortInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1PortInterface.html#a6751d5bbe9196013651b34294f72452c">RTT::base::PortInterface::connected()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8hpp_source.html#l00117">RTT::DataFlowInterface::addEventPort()</a>, <a class="el" href="TaskContext_8hpp_source.html#l00536">RTT::TaskContext::addEventPort()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00089">RTT::DataFlowInterface::addPort()</a>, and <a class="el" href="TaskContext_8hpp_source.html#l00512">RTT::TaskContext::addPort()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>rtt/<a class="el" href="InputPort_8hpp_source.html">InputPort.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 10 2017 22:54:00 for Orocos Real-Time Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
