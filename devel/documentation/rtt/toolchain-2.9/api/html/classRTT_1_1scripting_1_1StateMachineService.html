<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Orocos Real-Time Toolkit: RTT::scripting::StateMachineService Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a></li><li class="navelem"><a class="el" href="namespaceRTT_1_1scripting.html">scripting</a></li><li class="navelem"><a class="el" href="classRTT_1_1scripting_1_1StateMachineService.html">StateMachineService</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRTT_1_1scripting_1_1StateMachineService-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RTT::scripting::StateMachineService Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents a stateMachine as a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> in the <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> system.  
 <a href="classRTT_1_1scripting_1_1StateMachineService.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StateMachineService_8hpp_source.html">rtt/scripting/StateMachineService.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTT::scripting::StateMachineService:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRTT_1_1scripting_1_1StateMachineService.png" usemap="#RTT::scripting::StateMachineService_map" alt=""/>
  <map id="RTT::scripting::StateMachineService_map" name="RTT::scripting::StateMachineService_map">
<area href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a..." alt="RTT::Service" shape="rect" coords="225,56,440,80"/>
<area href="classRTT_1_1OperationInterface.html" title="Holds all exported operations of a component and is able to produce callers for these operations..." alt="RTT::OperationInterface" shape="rect" coords="0,0,215,24"/>
<area href="classRTT_1_1ConfigurationInterface.html" title="A class for keeping track of Attribute, Constant and Property objects of a TaskContext. " alt="RTT::ConfigurationInterface" shape="rect" coords="225,0,440,24"/>
<area href="classRTT_1_1DataFlowInterface.html" title="The Interface of a TaskContext which exposes its data-flow ports. " alt="RTT::DataFlowInterface" shape="rect" coords="450,0,665,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af4ef65336f84ec67356f9d4b487b3485"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4ef65336f84ec67356f9d4b487b3485"></a>
typedef <a class="el" href="classRTT_1_1OperationInterface.html">OperationInterface</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Factory</b></td></tr>
<tr class="separator:af4ef65336f84ec67356f9d4b487b3485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586d9dd29235367b735264a01867e93d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a586d9dd29235367b735264a01867e93d"></a>
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1Service.html">Service</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shared_ptr</b></td></tr>
<tr class="separator:a586d9dd29235367b735264a01867e93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9072856a66f8fc747334c7cf385203c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9072856a66f8fc747334c7cf385203c6"></a>
typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classRTT_1_1Service.html">Service</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shared_constptr</b></td></tr>
<tr class="separator:a9072856a66f8fc747334c7cf385203c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63941b38ffce04187aeab4ff638651d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa63941b38ffce04187aeab4ff638651d"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ProviderNames</b></td></tr>
<tr class="separator:aa63941b38ffce04187aeab4ff638651d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09243638f9e56f5322ccf49cc67ca4bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09243638f9e56f5322ccf49cc67ca4bb"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a></td></tr>
<tr class="memdesc:a09243638f9e56f5322ccf49cc67ca4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The arguments for an operation. <br/></td></tr>
<tr class="separator:a09243638f9e56f5322ccf49cc67ca4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33038c30f37f51ba4e0f71ffa3dd78db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33038c30f37f51ba4e0f71ffa3dd78db"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="structRTT_1_1ArgumentDescription.html">ArgumentDescription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a33038c30f37f51ba4e0f71ffa3dd78db">Descriptions</a></td></tr>
<tr class="memdesc:a33038c30f37f51ba4e0f71ffa3dd78db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The descriptions of an argumentlist. <br/></td></tr>
<tr class="separator:a33038c30f37f51ba4e0f71ffa3dd78db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc82babd19360e500b6b335a8d6c83d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc82babd19360e500b6b335a8d6c83d2"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#abc82babd19360e500b6b335a8d6c83d2">AttributeNames</a></td></tr>
<tr class="memdesc:abc82babd19360e500b6b335a8d6c83d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing the names of all attribute objects in this repository. <br/></td></tr>
<tr class="separator:abc82babd19360e500b6b335a8d6c83d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4683ed93c60a81e0c3dc6faaf3c23765"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4683ed93c60a81e0c3dc6faaf3c23765"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a4683ed93c60a81e0c3dc6faaf3c23765">AttributeObjects</a></td></tr>
<tr class="memdesc:a4683ed93c60a81e0c3dc6faaf3c23765"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing pointers to all attribute objects stored in this repository. <br/></td></tr>
<tr class="separator:a4683ed93c60a81e0c3dc6faaf3c23765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa0a7f72a75baf5d4993816de8d0b5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8aa0a7f72a75baf5d4993816de8d0b5b"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">Ports</a></td></tr>
<tr class="memdesc:a8aa0a7f72a75baf5d4993816de8d0b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of pointers to ports. <br/></td></tr>
<tr class="separator:a8aa0a7f72a75baf5d4993816de8d0b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e28572572757c85aefab22f103dff3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e28572572757c85aefab22f103dff3"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad7e28572572757c85aefab22f103dff3">PortNames</a></td></tr>
<tr class="memdesc:ad7e28572572757c85aefab22f103dff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of names of ports. <br/></td></tr>
<tr class="separator:ad7e28572572757c85aefab22f103dff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11f3df6e15c16fd32cd30394ac5bce9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab11f3df6e15c16fd32cd30394ac5bce9"></a>
typedef boost::function&lt; void(<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SlotFunction</b></td></tr>
<tr class="separator:ab11f3df6e15c16fd32cd30394ac5bce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a76738c44348ce8c9c678b4fe73f27e99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76738c44348ce8c9c678b4fe73f27e99"></a>
StateMachineServicePtr&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (ParsedStateMachinePtr newsc, std::map&lt; const <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> *, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> * &gt; &amp;replacements, bool instantiate)</td></tr>
<tr class="separator:a76738c44348ce8c9c678b4fe73f27e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdc1579a66c3c39a565f99c92e5e7cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fdc1579a66c3c39a565f99c92e5e7cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1scripting_1_1StateMachineService.html#a5fdc1579a66c3c39a565f99c92e5e7cd">StateMachineService</a> (ParsedStateMachinePtr statemachine, <a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *tc)</td></tr>
<tr class="memdesc:a5fdc1579a66c3c39a565f99c92e5e7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">By constructing this object, a stateMachine can be added to a taskcontext as a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>, with its operations. <br/></td></tr>
<tr class="separator:a5fdc1579a66c3c39a565f99c92e5e7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f73cc6c6b7e085a7c526eb342df2830"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f73cc6c6b7e085a7c526eb342df2830"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5f73cc6c6b7e085a7c526eb342df2830">getName</a> () const </td></tr>
<tr class="memdesc:a5f73cc6c6b7e085a7c526eb342df2830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this service instance. <br/></td></tr>
<tr class="separator:a5f73cc6c6b7e085a7c526eb342df2830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f65c77b98b5361207242cf5b59cf8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26f65c77b98b5361207242cf5b59cf8c"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a26f65c77b98b5361207242cf5b59cf8c">doc</a> () const </td></tr>
<tr class="memdesc:a26f65c77b98b5361207242cf5b59cf8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descriptive text for this service. <br/></td></tr>
<tr class="separator:a26f65c77b98b5361207242cf5b59cf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1eb79e816b491e71c03ae96e56f0eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a1eb79e816b491e71c03ae96e56f0eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a2a1eb79e816b491e71c03ae96e56f0eb">doc</a> (const std::string &amp;description)</td></tr>
<tr class="memdesc:a2a1eb79e816b491e71c03ae96e56f0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the descriptive text for this service. <br/></td></tr>
<tr class="separator:a2a1eb79e816b491e71c03ae96e56f0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efbfa07f131b186683525c964ce68a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9efbfa07f131b186683525c964ce68a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a9efbfa07f131b186683525c964ce68a5">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a9efbfa07f131b186683525c964ce68a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the name of this service. <br/></td></tr>
<tr class="separator:a9efbfa07f131b186683525c964ce68a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4893628c8cc423c6e5b3511f9af536"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a4893628c8cc423c6e5b3511f9af536"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5a4893628c8cc423c6e5b3511f9af536">setOwner</a> (<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *new_owner)</td></tr>
<tr class="memdesc:a5a4893628c8cc423c6e5b3511f9af536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> that will execute the operations in this service. <br/></td></tr>
<tr class="separator:a5a4893628c8cc423c6e5b3511f9af536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48caa7cb7c781b54bb5d3eb71fff4225"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48caa7cb7c781b54bb5d3eb71fff4225"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a48caa7cb7c781b54bb5d3eb71fff4225">setParent</a> (shared_ptr new_parent)</td></tr>
<tr class="memdesc:a48caa7cb7c781b54bb5d3eb71fff4225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent service in case this service is a sub-service. <br/></td></tr>
<tr class="separator:a48caa7cb7c781b54bb5d3eb71fff4225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137b83848de6b783f1ef66b427b7588b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a137b83848de6b783f1ef66b427b7588b"></a>
shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a137b83848de6b783f1ef66b427b7588b">getParent</a> () const </td></tr>
<tr class="memdesc:a137b83848de6b783f1ef66b427b7588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent is the direct parent of this service. <br/></td></tr>
<tr class="separator:a137b83848de6b783f1ef66b427b7588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6a916611b84ec0efa63041d7448116"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f6a916611b84ec0efa63041d7448116"></a>
virtual ProviderNames&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a9f6a916611b84ec0efa63041d7448116">getProviderNames</a> () const </td></tr>
<tr class="memdesc:a9f6a916611b84ec0efa63041d7448116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a standard container which contains all the sub-service names of this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>. <br/></td></tr>
<tr class="separator:a9f6a916611b84ec0efa63041d7448116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09c4e953c52113e8a117d7f65cae7ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#af09c4e953c52113e8a117d7f65cae7ef">getOwner</a> () const </td></tr>
<tr class="memdesc:af09c4e953c52113e8a117d7f65cae7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The owner is the top-level <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> owning this service (indirectly).  <a href="#af09c4e953c52113e8a117d7f65cae7ef">More...</a><br/></td></tr>
<tr class="separator:af09c4e953c52113e8a117d7f65cae7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e33b3a154e6e7e00d8a3f3adce25ac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a6e33b3a154e6e7e00d8a3f3adce25ac7">getOwnerExecutionEngine</a> () const </td></tr>
<tr class="memdesc:a6e33b3a154e6e7e00d8a3f3adce25ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the execution engine of this service owner.  <a href="#a6e33b3a154e6e7e00d8a3f3adce25ac7">More...</a><br/></td></tr>
<tr class="separator:a6e33b3a154e6e7e00d8a3f3adce25ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d23e90906042881cc9315e1bd98f449"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a5d23e90906042881cc9315e1bd98f449">addService</a> (shared_ptr obj)</td></tr>
<tr class="memdesc:a5d23e90906042881cc9315e1bd98f449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new sub-service to this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>.  <a href="#a5d23e90906042881cc9315e1bd98f449">More...</a><br/></td></tr>
<tr class="separator:a5d23e90906042881cc9315e1bd98f449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0389e2b340c1c2b2405289eae7ff3a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#aaa0389e2b340c1c2b2405289eae7ff3a">removeService</a> (std::string const &amp;service_name)</td></tr>
<tr class="memdesc:aaa0389e2b340c1c2b2405289eae7ff3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously added sub-service, potentially freeing it (and <em>this</em>) from memory.  <a href="#aaa0389e2b340c1c2b2405289eae7ff3a">More...</a><br/></td></tr>
<tr class="separator:aaa0389e2b340c1c2b2405289eae7ff3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224b685592dec643289798cac7ad8e2c"><td class="memItemLeft" align="right" valign="top">Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a224b685592dec643289798cac7ad8e2c">provides</a> ()</td></tr>
<tr class="memdesc:a224b685592dec643289798cac7ad8e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>this</em> <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>, unless no shared_ptr yet exists.  <a href="#a224b685592dec643289798cac7ad8e2c">More...</a><br/></td></tr>
<tr class="separator:a224b685592dec643289798cac7ad8e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e9501a0c0ef27bde331ddaa5e63538"><td class="memItemLeft" align="right" valign="top">Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a52e9501a0c0ef27bde331ddaa5e63538">provides</a> (const std::string &amp;service_name)</td></tr>
<tr class="memdesc:a52e9501a0c0ef27bde331ddaa5e63538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-Service which resorts under this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>, creating a new one if it does not yet exists.  <a href="#a52e9501a0c0ef27bde331ddaa5e63538">More...</a><br/></td></tr>
<tr class="separator:a52e9501a0c0ef27bde331ddaa5e63538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51ab122e01b561762386fcc8fabb55d"><td class="memItemLeft" align="right" valign="top">shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#ad51ab122e01b561762386fcc8fabb55d">getService</a> (const std::string &amp;service_name)</td></tr>
<tr class="memdesc:ad51ab122e01b561762386fcc8fabb55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer to strictly a sub-service of a null pointer if !hasService(service_name).  <a href="#ad51ab122e01b561762386fcc8fabb55d">More...</a><br/></td></tr>
<tr class="separator:ad51ab122e01b561762386fcc8fabb55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedae8dc1fc49511be315d4abe1682605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#aedae8dc1fc49511be315d4abe1682605">getService</a> () const </td></tr>
<tr class="memdesc:aedae8dc1fc49511be315d4abe1682605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service this interface belongs to.  <a href="#aedae8dc1fc49511be315d4abe1682605">More...</a><br/></td></tr>
<tr class="separator:aedae8dc1fc49511be315d4abe1682605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986074c32d5232b44d12f62515c3cac2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a986074c32d5232b44d12f62515c3cac2">hasService</a> (const std::string &amp;service_name)</td></tr>
<tr class="memdesc:a986074c32d5232b44d12f62515c3cac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this service has the sub-service <em>service_name</em>.  <a href="#a986074c32d5232b44d12f62515c3cac2">More...</a><br/></td></tr>
<tr class="separator:a986074c32d5232b44d12f62515c3cac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490fc9133d21ccd6f8e2388ab07431c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a490fc9133d21ccd6f8e2388ab07431c2">clear</a> ()</td></tr>
<tr class="memdesc:a490fc9133d21ccd6f8e2388ab07431c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all added operations, properties and sub-services from this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>.  <a href="#a490fc9133d21ccd6f8e2388ab07431c2">More...</a><br/></td></tr>
<tr class="separator:a490fc9133d21ccd6f8e2388ab07431c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca6c54840653c4b0dfab69df8839598"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a4ca6c54840653c4b0dfab69df8839598">getOperationNames</a> () const </td></tr>
<tr class="memdesc:a4ca6c54840653c4b0dfab69df8839598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the names of all operations added to this interface.  <a href="#a4ca6c54840653c4b0dfab69df8839598">More...</a><br/></td></tr>
<tr class="separator:a4ca6c54840653c4b0dfab69df8839598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac758c65de8fae3be3bc4ed3eac3495"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a7ac758c65de8fae3be3bc4ed3eac3495">hasOperation</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a7ac758c65de8fae3be3bc4ed3eac3495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for the existence of a <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a> in this interface.  <a href="#a7ac758c65de8fae3be3bc4ed3eac3495">More...</a><br/></td></tr>
<tr class="separator:a7ac758c65de8fae3be3bc4ed3eac3495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdccc873fb77f51f5d53cca01bcdf58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#abcdccc873fb77f51f5d53cca01bcdf58">addLocalOperation</a> (<a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> &amp;op)</td></tr>
<tr class="memdesc:abcdccc873fb77f51f5d53cca01bcdf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a> object to the operation interface.  <a href="#abcdccc873fb77f51f5d53cca01bcdf58">More...</a><br/></td></tr>
<tr class="separator:abcdccc873fb77f51f5d53cca01bcdf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f714307df9151bee776127196832859"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a3f714307df9151bee776127196832859">getLocalOperation</a> (std::string name)</td></tr>
<tr class="memdesc:a3f714307df9151bee776127196832859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a locally added operation from this interface.  <a href="#a3f714307df9151bee776127196832859">More...</a><br/></td></tr>
<tr class="separator:a3f714307df9151bee776127196832859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c2db6bcad1ea88a22191e8780d4e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c">getOperation</a> (std::string name)</td></tr>
<tr class="memdesc:a43c2db6bcad1ea88a22191e8780d4e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a previously added operation for use in a C++ <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> object.  <a href="#a43c2db6bcad1ea88a22191e8780d4e3c">More...</a><br/></td></tr>
<tr class="separator:a43c2db6bcad1ea88a22191e8780d4e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd085079896f5242c5656f8ee5034a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a0bd085079896f5242c5656f8ee5034a9">getOperation</a> (std::string name, const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;args, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller) const </td></tr>
<tr class="memdesc:a0bd085079896f5242c5656f8ee5034a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use only.  <a href="#a0bd085079896f5242c5656f8ee5034a9">More...</a><br/></td></tr>
<tr class="separator:a0bd085079896f5242c5656f8ee5034a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffa32a19a1b58771146c56773ae5af2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adffa32a19a1b58771146c56773ae5af2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#adffa32a19a1b58771146c56773ae5af2">removeOperation</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:adffa32a19a1b58771146c56773ae5af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added operation. <br/></td></tr>
<tr class="separator:adffa32a19a1b58771146c56773ae5af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447c3a77e8dd12b18ba02b059604ee87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a447c3a77e8dd12b18ba02b059604ee87">setOperationThread</a> (std::string const &amp;name, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et)</td></tr>
<tr class="memdesc:a447c3a77e8dd12b18ba02b059604ee87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the thread of execution of a previously added operation.  <a href="#a447c3a77e8dd12b18ba02b059604ee87">More...</a><br/></td></tr>
<tr class="separator:a447c3a77e8dd12b18ba02b059604ee87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4f94e4184b2f470053ad54c42e6dda"><td class="memTemplParams" colspan="2">template&lt;class Signature &gt; </td></tr>
<tr class="memitem:abd4f94e4184b2f470053ad54c42e6dda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#abd4f94e4184b2f470053ad54c42e6dda">addOperation</a> (<a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;op)</td></tr>
<tr class="memdesc:abd4f94e4184b2f470053ad54c42e6dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation object to the interface.  <a href="#abd4f94e4184b2f470053ad54c42e6dda">More...</a><br/></td></tr>
<tr class="separator:abd4f94e4184b2f470053ad54c42e6dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f467780775bea590fcb6e6eef72b580"><td class="memTemplParams" colspan="2">template&lt;class Func , class Class &gt; </td></tr>
<tr class="memitem:a9f467780775bea590fcb6e6eef72b580"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt; Func &gt;<br class="typebreak"/>
::Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a9f467780775bea590fcb6e6eef72b580">addOperation</a> (const std::string name, Func func, Class *obj, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr class="memdesc:a9f467780775bea590fcb6e6eef72b580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to the interface by means of a C++ Class member function.  <a href="#a9f467780775bea590fcb6e6eef72b580">More...</a><br/></td></tr>
<tr class="separator:a9f467780775bea590fcb6e6eef72b580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd3085e2a555ca4b7e7d01ac51ce7b7"><td class="memTemplParams" colspan="2">template&lt;class Func &gt; </td></tr>
<tr class="memitem:a2fd3085e2a555ca4b7e7d01ac51ce7b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Func &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a2fd3085e2a555ca4b7e7d01ac51ce7b7">addOperation</a> (const std::string name, Func *func, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr class="memdesc:a2fd3085e2a555ca4b7e7d01ac51ce7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to the interface by means of a free C/C++ function.  <a href="#a2fd3085e2a555ca4b7e7d01ac51ce7b7">More...</a><br/></td></tr>
<tr class="separator:a2fd3085e2a555ca4b7e7d01ac51ce7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48f4deb45e99802ffd615015769fc0a"><td class="memTemplParams" colspan="2">template&lt;class Signature &gt; </td></tr>
<tr class="memitem:ad48f4deb45e99802ffd615015769fc0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#ad48f4deb45e99802ffd615015769fc0a">addSynchronousOperation</a> (<a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;op)</td></tr>
<tr class="memdesc:ad48f4deb45e99802ffd615015769fc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation object to the interface.  <a href="#ad48f4deb45e99802ffd615015769fc0a">More...</a><br/></td></tr>
<tr class="separator:ad48f4deb45e99802ffd615015769fc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01fee5e61de4416b8393b17fdde7d2f"><td class="memTemplParams" colspan="2">template&lt;class Func , class Class &gt; </td></tr>
<tr class="memitem:ae01fee5e61de4416b8393b17fdde7d2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt; Func &gt;<br class="typebreak"/>
::Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#ae01fee5e61de4416b8393b17fdde7d2f">addSynchronousOperation</a> (const std::string name, Func func, Class *obj, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr class="memdesc:ae01fee5e61de4416b8393b17fdde7d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to the synchronous interface by means of a function.  <a href="#ae01fee5e61de4416b8393b17fdde7d2f">More...</a><br/></td></tr>
<tr class="separator:ae01fee5e61de4416b8393b17fdde7d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c55fbf8e8b5fbc74ff3fe5aaddf4bb"><td class="memTemplParams" colspan="2">template&lt;class Func , class ObjT &gt; </td></tr>
<tr class="memitem:a16c55fbf8e8b5fbc74ff3fe5aaddf4bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structRTT_1_1internal_1_1GetSignatureDS.html">internal::GetSignatureDS</a>&lt; Func &gt;<br class="typebreak"/>
::Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a16c55fbf8e8b5fbc74ff3fe5aaddf4bb">addOperationDS</a> (const std::string &amp;name, Func func, <a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *sp, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr class="memdesc:a16c55fbf8e8b5fbc74ff3fe5aaddf4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use only.  <a href="#a16c55fbf8e8b5fbc74ff3fe5aaddf4bb">More...</a><br/></td></tr>
<tr class="separator:a16c55fbf8e8b5fbc74ff3fe5aaddf4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5dd40574f3049800e2a8695f548f4b5"><td class="memTemplParams" colspan="2">template&lt;class Signature , class ObjT &gt; </td></tr>
<tr class="memitem:ad5dd40574f3049800e2a8695f548f4b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#ad5dd40574f3049800e2a8695f548f4b5">addOperationDS</a> (<a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *sp, <a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;op)</td></tr>
<tr class="memdesc:ad5dd40574f3049800e2a8695f548f4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use only.  <a href="#ad5dd40574f3049800e2a8695f548f4b5">More...</a><br/></td></tr>
<tr class="separator:ad5dd40574f3049800e2a8695f548f4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304d85203882c54aac4bbcab91d0da13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1internal_1_1OperationCallerC.html">internal::OperationCallerC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a304d85203882c54aac4bbcab91d0da13">create</a> (std::string name, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller)</td></tr>
<tr class="memdesc:a304d85203882c54aac4bbcab91d0da13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a OperationCallerC object, a template-less operation invocation object.  <a href="#a304d85203882c54aac4bbcab91d0da13">More...</a><br/></td></tr>
<tr class="separator:a304d85203882c54aac4bbcab91d0da13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594ee345ec9aefcde6f6a184107a4ec2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a594ee345ec9aefcde6f6a184107a4ec2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a594ee345ec9aefcde6f6a184107a4ec2">resetOperation</a> (std::string name, <a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> *impl)</td></tr>
<tr class="memdesc:a594ee345ec9aefcde6f6a184107a4ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the implementation of a operation. <br/></td></tr>
<tr class="separator:a594ee345ec9aefcde6f6a184107a4ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ddca9d0376b78c7617ac790f985e58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91ddca9d0376b78c7617ac790f985e58"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a91ddca9d0376b78c7617ac790f985e58">getNames</a> () const </td></tr>
<tr class="memdesc:a91ddca9d0376b78c7617ac790f985e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all the names of the added operations. <br/></td></tr>
<tr class="separator:a91ddca9d0376b78c7617ac790f985e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0c72ef924fbd180eebbcc1e93e590b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f0c72ef924fbd180eebbcc1e93e590b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a1f0c72ef924fbd180eebbcc1e93e590b">hasMember</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a1f0c72ef924fbd180eebbcc1e93e590b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if an operation is present. <br/></td></tr>
<tr class="separator:a1f0c72ef924fbd180eebbcc1e93e590b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d8ac5248f6005053d90cdfe76cd05a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#ac6d8ac5248f6005053d90cdfe76cd05a">getArity</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:ac6d8ac5248f6005053d90cdfe76cd05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of arguments of an operation.  <a href="#ac6d8ac5248f6005053d90cdfe76cd05a">More...</a><br/></td></tr>
<tr class="separator:ac6d8ac5248f6005053d90cdfe76cd05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0151ba33c1e610eb168c8b72b2f69545"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a0151ba33c1e610eb168c8b72b2f69545">getCollectArity</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a0151ba33c1e610eb168c8b72b2f69545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the collectable number of arguments of an operation.  <a href="#a0151ba33c1e610eb168c8b72b2f69545">More...</a><br/></td></tr>
<tr class="separator:a0151ba33c1e610eb168c8b72b2f69545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1106ef1dc8f222a0595e50ad93637b45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a1106ef1dc8f222a0595e50ad93637b45">isSynchronous</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a1106ef1dc8f222a0595e50ad93637b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a given operation is limited to sychronous invocation (own component thread) only.  <a href="#a1106ef1dc8f222a0595e50ad93637b45">More...</a><br/></td></tr>
<tr class="separator:a1106ef1dc8f222a0595e50ad93637b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8762e2fbdbaa9e88f90474c2bb73cfc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a8762e2fbdbaa9e88f90474c2bb73cfc4">produce</a> (const std::string &amp;name, const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;args, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller) const </td></tr>
<tr class="memdesc:a8762e2fbdbaa9e88f90474c2bb73cfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a DataSource that call()s an operation.  <a href="#a8762e2fbdbaa9e88f90474c2bb73cfc4">More...</a><br/></td></tr>
<tr class="separator:a8762e2fbdbaa9e88f90474c2bb73cfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e9bd1086d592eba8612e7bd0f67b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#ad3e9bd1086d592eba8612e7bd0f67b9d">produceSend</a> (const std::string &amp;name, const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;args, <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *caller) const </td></tr>
<tr class="memdesc:ad3e9bd1086d592eba8612e7bd0f67b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a DataSource that send()s an operation.  <a href="#ad3e9bd1086d592eba8612e7bd0f67b9d">More...</a><br/></td></tr>
<tr class="separator:ad3e9bd1086d592eba8612e7bd0f67b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9330b6a57234e636220e32636a16a45a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a9330b6a57234e636220e32636a16a45a">produceHandle</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a9330b6a57234e636220e32636a16a45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce an AssignableDataSource that contains a <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation. ">SendHandle</a>, fit for the operation.  <a href="#a9330b6a57234e636220e32636a16a45a">More...</a><br/></td></tr>
<tr class="separator:a9330b6a57234e636220e32636a16a45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a921268272a88f33029e220c2b512c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a91a921268272a88f33029e220c2b512c">produceCollect</a> (const std::string &amp;name, const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;args, <a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; bool &gt;::shared_ptr blocking) const </td></tr>
<tr class="memdesc:a91a921268272a88f33029e220c2b512c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a DataSource that collects a sent operation, The DataSource will return the SendStatus and store the results in the presented arguments.  <a href="#a91a921268272a88f33029e220c2b512c">More...</a><br/></td></tr>
<tr class="separator:a91a921268272a88f33029e220c2b512c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843066924eb7c079832718c5cf15e7a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1OperationInterface.html#a33038c30f37f51ba4e0f71ffa3dd78db">Descriptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a843066924eb7c079832718c5cf15e7a1">getArgumentList</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a843066924eb7c079832718c5cf15e7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the names and descriptions of all arguments of an operation.  <a href="#a843066924eb7c079832718c5cf15e7a1">More...</a><br/></td></tr>
<tr class="separator:a843066924eb7c079832718c5cf15e7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9887ac7ed938277edf7063063e849223"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a9887ac7ed938277edf7063063e849223">getResultType</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a9887ac7ed938277edf7063063e849223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type name of the result type of an operation.  <a href="#a9887ac7ed938277edf7063063e849223">More...</a><br/></td></tr>
<tr class="separator:a9887ac7ed938277edf7063063e849223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0154dd6d15f610f5347ed2a4e9e96bcf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a0154dd6d15f610f5347ed2a4e9e96bcf">getDescription</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a0154dd6d15f610f5347ed2a4e9e96bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description of an operation.  <a href="#a0154dd6d15f610f5347ed2a4e9e96bcf">More...</a><br/></td></tr>
<tr class="separator:a0154dd6d15f610f5347ed2a4e9e96bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7530f8d747ccb09e5d4c68d1177bd060"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a7530f8d747ccb09e5d4c68d1177bd060">add</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *part)</td></tr>
<tr class="memdesc:a7530f8d747ccb09e5d4c68d1177bd060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new operation to the interface or replace an existing one.  <a href="#a7530f8d747ccb09e5d4c68d1177bd060">More...</a><br/></td></tr>
<tr class="separator:a7530f8d747ccb09e5d4c68d1177bd060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72938e680f9d2394b08c6ef45aee2e80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#a72938e680f9d2394b08c6ef45aee2e80">remove</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a72938e680f9d2394b08c6ef45aee2e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an added operation from the interface.  <a href="#a72938e680f9d2394b08c6ef45aee2e80">More...</a><br/></td></tr>
<tr class="separator:a72938e680f9d2394b08c6ef45aee2e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1793b4990e68890a210820bd8922311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1OperationInterface.html#af1793b4990e68890a210820bd8922311">getPart</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:af1793b4990e68890a210820bd8922311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a previously added part of this factory.  <a href="#af1793b4990e68890a210820bd8922311">More...</a><br/></td></tr>
<tr class="separator:af1793b4990e68890a210820bd8922311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916de084248760b621ff9efbb65a39ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a916de084248760b621ff9efbb65a39ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a916de084248760b621ff9efbb65a39ea">hasAttribute</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a916de084248760b621ff9efbb65a39ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an attribute is present in this interface. <br/></td></tr>
<tr class="separator:a916de084248760b621ff9efbb65a39ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43de01de0fa000849289e9e60f50b36"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad43de01de0fa000849289e9e60f50b36"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ad43de01de0fa000849289e9e60f50b36">addAttribute</a> (const std::string &amp;name, T &amp;attr)</td></tr>
<tr class="memdesc:ad43de01de0fa000849289e9e60f50b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as read/write attribute to the configuration interface.  <a href="#ad43de01de0fa000849289e9e60f50b36">More...</a><br/></td></tr>
<tr class="separator:ad43de01de0fa000849289e9e60f50b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a8c29748bafb1f3119d062c19dc0e1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a53a8c29748bafb1f3119d062c19dc0e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a53a8c29748bafb1f3119d062c19dc0e1">addAttribute</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt; T &gt; &amp;attr)</td></tr>
<tr class="memdesc:a53a8c29748bafb1f3119d062c19dc0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an existing attribute object to the configuration interface.  <a href="#a53a8c29748bafb1f3119d062c19dc0e1">More...</a><br/></td></tr>
<tr class="separator:a53a8c29748bafb1f3119d062c19dc0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4f82517c3b1ec1297122ef1d9de0fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a8e4f82517c3b1ec1297122ef1d9de0fe">addAttribute</a> (<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;a)</td></tr>
<tr class="memdesc:a8e4f82517c3b1ec1297122ef1d9de0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data. ">base::AttributeBase</a> which remains owned by the user.  <a href="#a8e4f82517c3b1ec1297122ef1d9de0fe">More...</a><br/></td></tr>
<tr class="separator:a8e4f82517c3b1ec1297122ef1d9de0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1cb31505af2ec04d16cc0015f4ef32"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5e1cb31505af2ec04d16cc0015f4ef32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a5e1cb31505af2ec04d16cc0015f4ef32">addConstant</a> (const std::string &amp;name, const T &amp;cnst)</td></tr>
<tr class="memdesc:a5e1cb31505af2ec04d16cc0015f4ef32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as read-only attribute to the configuration interface.  <a href="#a5e1cb31505af2ec04d16cc0015f4ef32">More...</a><br/></td></tr>
<tr class="separator:a5e1cb31505af2ec04d16cc0015f4ef32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670818300e4efb32da6532fa815d1baa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a670818300e4efb32da6532fa815d1baa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a670818300e4efb32da6532fa815d1baa">addConstant</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt; T &gt; &amp;cnst)</td></tr>
<tr class="memdesc:a670818300e4efb32da6532fa815d1baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an existing constant object to the configuration interface.  <a href="#a670818300e4efb32da6532fa815d1baa">More...</a><br/></td></tr>
<tr class="separator:a670818300e4efb32da6532fa815d1baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb93dbd0439b6b67abe7e5aecfdc2fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aacb93dbd0439b6b67abe7e5aecfdc2fe">addConstant</a> (<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;c)</td></tr>
<tr class="memdesc:aacb93dbd0439b6b67abe7e5aecfdc2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation. ">Constant</a> with a given value.  <a href="#aacb93dbd0439b6b67abe7e5aecfdc2fe">More...</a><br/></td></tr>
<tr class="separator:aacb93dbd0439b6b67abe7e5aecfdc2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef82495c4e0b04ad555914c7216f76c1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aef82495c4e0b04ad555914c7216f76c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aef82495c4e0b04ad555914c7216f76c1">addProperty</a> (const std::string &amp;name, T &amp;prop)</td></tr>
<tr class="memdesc:aef82495c4e0b04ad555914c7216f76c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as a property to the configuration interface.  <a href="#aef82495c4e0b04ad555914c7216f76c1">More...</a><br/></td></tr>
<tr class="separator:aef82495c4e0b04ad555914c7216f76c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f56e23ad7dbb378acc61367c281adf0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f56e23ad7dbb378acc61367c281adf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a1f56e23ad7dbb378acc61367c281adf0">addProperty</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;prop)</td></tr>
<tr class="memdesc:a1f56e23ad7dbb378acc61367c281adf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an existing property object to the configuration interface.  <a href="#a1f56e23ad7dbb378acc61367c281adf0">More...</a><br/></td></tr>
<tr class="separator:a1f56e23ad7dbb378acc61367c281adf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef004414e0bd9e610188e750a88648c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aef004414e0bd9e610188e750a88648c3">addProperty</a> (<a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;pb)</td></tr>
<tr class="memdesc:aef004414e0bd9e610188e750a88648c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1base_1_1PropertyBase.html" title="Base class for all properties. ">base::PropertyBase</a> as a property.  <a href="#aef004414e0bd9e610188e750a88648c3">More...</a><br/></td></tr>
<tr class="separator:aef004414e0bd9e610188e750a88648c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbdbdbbdbf411175bf12a60a559b6ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dbdbdbbdbf411175bf12a60a559b6ca"></a>
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAttribute</b> (const std::string &amp;name) const </td></tr>
<tr class="separator:a3dbdbdbbdbf411175bf12a60a559b6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15a32cd1584071f1dc75a5bbea24f88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa15a32cd1584071f1dc75a5bbea24f88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aa15a32cd1584071f1dc75a5bbea24f88">removeAttribute</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa15a32cd1584071f1dc75a5bbea24f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an attribute from the repository. <br/></td></tr>
<tr class="separator:aa15a32cd1584071f1dc75a5bbea24f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210c25e71ff311f23e8cb21ee838ee4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a210c25e71ff311f23e8cb21ee838ee4f"></a>
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getConstant</b> (const std::string &amp;name) const </td></tr>
<tr class="separator:a210c25e71ff311f23e8cb21ee838ee4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c56f8a6e874cbbe551270fd8bc4047"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51c56f8a6e874cbbe551270fd8bc4047"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a51c56f8a6e874cbbe551270fd8bc4047">hasProperty</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a51c56f8a6e874cbbe551270fd8bc4047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a property is present. <br/></td></tr>
<tr class="separator:a51c56f8a6e874cbbe551270fd8bc4047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cea1140a7dc44ef70adbe472d2e54c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a7cea1140a7dc44ef70adbe472d2e54c3">removeProperty</a> (<a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;p)</td></tr>
<tr class="memdesc:a7cea1140a7dc44ef70adbe472d2e54c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously added <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> and associated attribute.  <a href="#a7cea1140a7dc44ef70adbe472d2e54c3">More...</a><br/></td></tr>
<tr class="separator:a7cea1140a7dc44ef70adbe472d2e54c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd042c5788def6124d04d9ea0b37c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#accd042c5788def6124d04d9ea0b37c20">getProperty</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:accd042c5788def6124d04d9ea0b37c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> with name <em>name</em>.  <a href="#accd042c5788def6124d04d9ea0b37c20">More...</a><br/></td></tr>
<tr class="separator:accd042c5788def6124d04d9ea0b37c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42d3a355376882088f6c7f407d961a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ae42d3a355376882088f6c7f407d961a5">setValue</a> (<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *ab)</td></tr>
<tr class="memdesc:ae42d3a355376882088f6c7f407d961a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the ownership of an attribute to the repository.  <a href="#ae42d3a355376882088f6c7f407d961a5">More...</a><br/></td></tr>
<tr class="separator:ae42d3a355376882088f6c7f407d961a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a349b9b2086996f2f445c98a03e30cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a349b9b2086996f2f445c98a03e30cd"></a>
<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getValue</b> (const std::string &amp;name) const </td></tr>
<tr class="separator:a7a349b9b2086996f2f445c98a03e30cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2d3b696e81c6f72386cbc37f41d087"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac2d3b696e81c6f72386cbc37f41d087"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#aac2d3b696e81c6f72386cbc37f41d087">removeValue</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aac2d3b696e81c6f72386cbc37f41d087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a value added with setValue from the repository. <br/></td></tr>
<tr class="separator:aac2d3b696e81c6f72386cbc37f41d087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56fd107358cd0a8ebdfe2aead4e8a24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1ConfigurationInterface.html">ConfigurationInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ab56fd107358cd0a8ebdfe2aead4e8a24">copy</a> (std::map&lt; const <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> *, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> * &gt; &amp;repl, bool instantiate) const </td></tr>
<tr class="memdesc:ab56fd107358cd0a8ebdfe2aead4e8a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new copy of this repository with the copy operation semantics.  <a href="#ab56fd107358cd0a8ebdfe2aead4e8a24">More...</a><br/></td></tr>
<tr class="separator:ab56fd107358cd0a8ebdfe2aead4e8a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537659ebd311cd50a0d441f4e7f4a595"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a537659ebd311cd50a0d441f4e7f4a595"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a537659ebd311cd50a0d441f4e7f4a595">loadValues</a> (<a class="el" href="classRTT_1_1ConfigurationInterface.html#a4683ed93c60a81e0c3dc6faaf3c23765">AttributeObjects</a> const &amp;new_values)</td></tr>
<tr class="memdesc:a537659ebd311cd50a0d441f4e7f4a595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds these attributes to this repository. <br/></td></tr>
<tr class="separator:a537659ebd311cd50a0d441f4e7f4a595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8004606abadbf6bfd292b22c7ca9227"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8004606abadbf6bfd292b22c7ca9227"></a>
<a class="el" href="classRTT_1_1ConfigurationInterface.html#a4683ed93c60a81e0c3dc6faaf3c23765">AttributeObjects</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ab8004606abadbf6bfd292b22c7ca9227">getValues</a> () const </td></tr>
<tr class="memdesc:ab8004606abadbf6bfd292b22c7ca9227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all attributes in this repository. <br/></td></tr>
<tr class="separator:ab8004606abadbf6bfd292b22c7ca9227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b113f5fc0f51f1e822b5b79e8528d1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b113f5fc0f51f1e822b5b79e8528d1f"></a>
<a class="el" href="classRTT_1_1ConfigurationInterface.html#abc82babd19360e500b6b335a8d6c83d2">AttributeNames</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#a8b113f5fc0f51f1e822b5b79e8528d1f">getAttributeNames</a> () const </td></tr>
<tr class="memdesc:a8b113f5fc0f51f1e822b5b79e8528d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the names of all attributes in this repository. <br/></td></tr>
<tr class="separator:a8b113f5fc0f51f1e822b5b79e8528d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2398778a4b987d13ad205de64b65475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2398778a4b987d13ad205de64b65475"></a>
<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConfigurationInterface.html#ac2398778a4b987d13ad205de64b65475">properties</a> ()</td></tr>
<tr class="memdesc:ac2398778a4b987d13ad205de64b65475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a bag of all properties. <br/></td></tr>
<tr class="separator:ac2398778a4b987d13ad205de64b65475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cc8251add66d43626fb5a36630a86d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ae4cc8251add66d43626fb5a36630a86d">addPort</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr class="memdesc:ae4cc8251add66d43626fb5a36630a86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port.  <a href="#ae4cc8251add66d43626fb5a36630a86d">More...</a><br/></td></tr>
<tr class="separator:ae4cc8251add66d43626fb5a36630a86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7439b0849223846eaef9e857e2863b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a7439b0849223846eaef9e857e2863b8f">addPort</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr class="memdesc:a7439b0849223846eaef9e857e2863b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port.  <a href="#a7439b0849223846eaef9e857e2863b8f">More...</a><br/></td></tr>
<tr class="separator:a7439b0849223846eaef9e857e2863b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089897b16e398886de8a3b0fb86b1045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a089897b16e398886de8a3b0fb86b1045">addEventPort</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, SlotFunction callback=SlotFunction())</td></tr>
<tr class="memdesc:a089897b16e398886de8a3b0fb86b1045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port.  <a href="#a089897b16e398886de8a3b0fb86b1045">More...</a><br/></td></tr>
<tr class="separator:a089897b16e398886de8a3b0fb86b1045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee64763dfe8053940fa81fe2582d5be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a6ee64763dfe8053940fa81fe2582d5be">addEventPort</a> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, SlotFunction callback=SlotFunction())</td></tr>
<tr class="memdesc:a6ee64763dfe8053940fa81fe2582d5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port.  <a href="#a6ee64763dfe8053940fa81fe2582d5be">More...</a><br/></td></tr>
<tr class="separator:a6ee64763dfe8053940fa81fe2582d5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176244c5979a8010ae7dcc0a3db3bb63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a176244c5979a8010ae7dcc0a3db3bb63">removePort</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a176244c5979a8010ae7dcc0a3db3bb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a Port from this interface.  <a href="#a176244c5979a8010ae7dcc0a3db3bb63">More...</a><br/></td></tr>
<tr class="separator:a176244c5979a8010ae7dcc0a3db3bb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697023207fdd61c0ae65d3f7b55bf57e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">Ports</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a697023207fdd61c0ae65d3f7b55bf57e">getPorts</a> () const </td></tr>
<tr class="memdesc:a697023207fdd61c0ae65d3f7b55bf57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all ports of this interface.  <a href="#a697023207fdd61c0ae65d3f7b55bf57e">More...</a><br/></td></tr>
<tr class="separator:a697023207fdd61c0ae65d3f7b55bf57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1cd98ccf5d14b6a510f65b37bae841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad7e28572572757c85aefab22f103dff3">PortNames</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#adb1cd98ccf5d14b6a510f65b37bae841">getPortNames</a> () const </td></tr>
<tr class="memdesc:adb1cd98ccf5d14b6a510f65b37bae841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all port names of this interface.  <a href="#adb1cd98ccf5d14b6a510f65b37bae841">More...</a><br/></td></tr>
<tr class="separator:adb1cd98ccf5d14b6a510f65b37bae841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a4e6066c255dd36059f5e9d791eecb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a87a4e6066c255dd36059f5e9d791eecb">getPort</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a87a4e6066c255dd36059f5e9d791eecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an added port.  <a href="#a87a4e6066c255dd36059f5e9d791eecb">More...</a><br/></td></tr>
<tr class="separator:a87a4e6066c255dd36059f5e9d791eecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af969a2411243abdea4a897753dc68850"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#af969a2411243abdea4a897753dc68850">getPortDescription</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:af969a2411243abdea4a897753dc68850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description of an added Port.  <a href="#af969a2411243abdea4a897753dc68850">More...</a><br/></td></tr>
<tr class="separator:af969a2411243abdea4a897753dc68850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21b73e9f5e1e6186ad10b3ec0a1ffe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad21b73e9f5e1e6186ad10b3ec0a1ffe7">setPortDescription</a> (const std::string &amp;name, const std::string description)</td></tr>
<tr class="memdesc:ad21b73e9f5e1e6186ad10b3ec0a1ffe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the description for the service of an added port.  <a href="#ad21b73e9f5e1e6186ad10b3ec0a1ffe7">More...</a><br/></td></tr>
<tr class="separator:ad21b73e9f5e1e6186ad10b3ec0a1ffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958627b0442cb97f4e91f9fae0f6eee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a958627b0442cb97f4e91f9fae0f6eee0">addLocalPort</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr class="memdesc:a958627b0442cb97f4e91f9fae0f6eee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Port to this task without registering a service for it.  <a href="#a958627b0442cb97f4e91f9fae0f6eee0">More...</a><br/></td></tr>
<tr class="separator:a958627b0442cb97f4e91f9fae0f6eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90b18e5b4d26af2062cff0feaf9cb57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ae90b18e5b4d26af2062cff0feaf9cb57">addLocalEventPort</a> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, SlotFunction callback=SlotFunction())</td></tr>
<tr class="memdesc:ae90b18e5b4d26af2062cff0feaf9cb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Event triggering Port to this task without registering a service for it.  <a href="#ae90b18e5b4d26af2062cff0feaf9cb57">More...</a><br/></td></tr>
<tr class="separator:ae90b18e5b4d26af2062cff0feaf9cb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdccc95629af8c46757fc5973ab10e10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#abdccc95629af8c46757fc5973ab10e10">removeLocalPort</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:abdccc95629af8c46757fc5973ab10e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a locally added Port from this interface.  <a href="#abdccc95629af8c46757fc5973ab10e10">More...</a><br/></td></tr>
<tr class="separator:abdccc95629af8c46757fc5973ab10e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8366db58aee0b4db7cce0cf1601e7d7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8366db58aee0b4db7cce0cf1601e7d7d"></a>
template&lt;class Type &gt; </td></tr>
<tr class="memitem:a8366db58aee0b4db7cce0cf1601e7d7d"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a8366db58aee0b4db7cce0cf1601e7d7d">getPortType</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a8366db58aee0b4db7cce0cf1601e7d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a port of a specific type. <br/></td></tr>
<tr class="separator:a8366db58aee0b4db7cce0cf1601e7d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2eb3405418171a632e2d3db021c981"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb2eb3405418171a632e2d3db021c981"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#adb2eb3405418171a632e2d3db021c981">dataOnPort</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *port)</td></tr>
<tr class="memdesc:adb2eb3405418171a632e2d3db021c981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the input ports to notify this class of new data. <br/></td></tr>
<tr class="separator:adb2eb3405418171a632e2d3db021c981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a56d813e588db7acf6266492c53bb5062"><td class="memItemLeft" align="right" valign="top">static Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a56d813e588db7acf6266492c53bb5062">Create</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *owner=0)</td></tr>
<tr class="memdesc:a56d813e588db7acf6266492c53bb5062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with a name and an owner.  <a href="#a56d813e588db7acf6266492c53bb5062">More...</a><br/></td></tr>
<tr class="separator:a56d813e588db7acf6266492c53bb5062"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a5540a48f3ee2461f90f58f8c5b205908"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5540a48f3ee2461f90f58f8c5b205908"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
shared_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Services</b></td></tr>
<tr class="separator:a5540a48f3ee2461f90f58f8c5b205908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16563f08c5f4b76019bbcb98002344f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae16563f08c5f4b76019bbcb98002344f"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleOperations</b></td></tr>
<tr class="separator:ae16563f08c5f4b76019bbcb98002344f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae676323ac7baaa2b2d69a81b02a361c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae676323ac7baaa2b2d69a81b02a361c1"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OperationList</b></td></tr>
<tr class="separator:ae676323ac7baaa2b2d69a81b02a361c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10968726affb9dda3766ca391290a0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad10968726affb9dda3766ca391290a0a"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_t</b></td></tr>
<tr class="separator:ad10968726affb9dda3766ca391290a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1ee7a9617d13a55be42a8af7fa2dab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b1ee7a9617d13a55be42a8af7fa2dab"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_t</b></td></tr>
<tr class="separator:a9b1ee7a9617d13a55be42a8af7fa2dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad20f3f7dbaaf9c33966152c217e67b84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad20f3f7dbaaf9c33966152c217e67b84"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>testOperation</b> (<a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> &amp;op)</td></tr>
<tr class="separator:ad20f3f7dbaaf9c33966152c217e67b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9025045596e684ad2a3e0c0829fd8d47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9025045596e684ad2a3e0c0829fd8d47"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>chkPtr</b> (const std::string &amp;where, const std::string &amp;name, const void *ptr)</td></tr>
<tr class="separator:a9025045596e684ad2a3e0c0829fd8d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c32ae219720ffec7ffa5133e5e7f92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03c32ae219720ffec7ffa5133e5e7f92"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>chkPtr</b> (const std::string &amp;where, const std::string &amp;name, const void *ptr)</td></tr>
<tr class="separator:a03c32ae219720ffec7ffa5133e5e7f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a5bb35c562641a32e2fe907c8a6efb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad8a5bb35c562641a32e2fe907c8a6efb">createPortObject</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad8a5bb35c562641a32e2fe907c8a6efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> through which one can access a Port.  <a href="#ad8a5bb35c562641a32e2fe907c8a6efb">More...</a><br/></td></tr>
<tr class="separator:ad8a5bb35c562641a32e2fe907c8a6efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a072525873f8237dd7c733763fbc7bab3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a072525873f8237dd7c733763fbc7bab3"></a>
Services&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1Service.html#a072525873f8237dd7c733763fbc7bab3">services</a></td></tr>
<tr class="memdesc:a072525873f8237dd7c733763fbc7bab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the services we implement. <br/></td></tr>
<tr class="separator:a072525873f8237dd7c733763fbc7bab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13d10c824414ec35c09b0fb798ff5f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab13d10c824414ec35c09b0fb798ff5f2"></a>
SimpleOperations&#160;</td><td class="memItemRight" valign="bottom"><b>simpleoperations</b></td></tr>
<tr class="separator:ab13d10c824414ec35c09b0fb798ff5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1ca86d7dbbf09e91a19bb0cb7861b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace1ca86d7dbbf09e91a19bb0cb7861b7"></a>
OperationList&#160;</td><td class="memItemRight" valign="bottom"><b>ownedoperations</b></td></tr>
<tr class="separator:ace1ca86d7dbbf09e91a19bb0cb7861b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70759dc8adb15d10109606417d6a782e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70759dc8adb15d10109606417d6a782e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>mname</b></td></tr>
<tr class="separator:a70759dc8adb15d10109606417d6a782e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9bf062d263aa310f61581cbefb69d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c9bf062d263aa310f61581cbefb69d3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>mdescription</b></td></tr>
<tr class="separator:a8c9bf062d263aa310f61581cbefb69d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683cc479ff50845807c08018989078ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a683cc479ff50845807c08018989078ac"></a>
<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mowner</b></td></tr>
<tr class="separator:a683cc479ff50845807c08018989078ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821eb104f1784f9be5713a44690ba184"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a821eb104f1784f9be5713a44690ba184"></a>
shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>parent</b></td></tr>
<tr class="separator:a821eb104f1784f9be5713a44690ba184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd866a2dc50ff53a0dcfb44f1291cfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addd866a2dc50ff53a0dcfb44f1291cfa"></a>
map_t&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:addd866a2dc50ff53a0dcfb44f1291cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340794753c12f6d3ae63fa4a1256c39a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a340794753c12f6d3ae63fa4a1256c39a"></a>
map_t&#160;</td><td class="memItemRight" valign="bottom"><b>values</b></td></tr>
<tr class="separator:a340794753c12f6d3ae63fa4a1256c39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e14488be2ffc427664d5d1ace164ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32e14488be2ffc427664d5d1ace164ad"></a>
<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bag</b></td></tr>
<tr class="separator:a32e14488be2ffc427664d5d1ace164ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f3e00a2bb63d6a221ac0b78bb52f4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40f3e00a2bb63d6a221ac0b78bb52f4e"></a>
<a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">Ports</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a40f3e00a2bb63d6a221ac0b78bb52f4e">mports</a></td></tr>
<tr class="memdesc:a40f3e00a2bb63d6a221ac0b78bb52f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">All our ports. <br/></td></tr>
<tr class="separator:a40f3e00a2bb63d6a221ac0b78bb52f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786bd9c13ab8ac9af980daaa4d0f8784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1DataFlowInterface.html#a786bd9c13ab8ac9af980daaa4d0f8784">mservice</a></td></tr>
<tr class="memdesc:a786bd9c13ab8ac9af980daaa4d0f8784"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>.  <a href="#a786bd9c13ab8ac9af980daaa4d0f8784">More...</a><br/></td></tr>
<tr class="separator:a786bd9c13ab8ac9af980daaa4d0f8784"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a stateMachine as a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> in the <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> system. </p>

<p>Definition at line <a class="el" href="StateMachineService_8hpp_source.html#l00054">54</a> of file <a class="el" href="StateMachineService_8hpp_source.html">StateMachineService.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7530f8d747ccb09e5d4c68d1177bd060"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OperationInterface::add </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new operation to the interface or replace an existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">part</td><td>A part which creates the operation. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00170">170</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad43de01de0fa000849289e9e60f50b36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a variable of any type as read/write attribute to the configuration interface. </p>
<p>An <a class="el" href="classRTT_1_1Alias.html" title="This class is the most basic Attribute implementation (only suitable for reading a internal::DataSour...">Alias</a> is created which causes contents of the <em>attr</em> variable always to be in sync with the contents of the attribute object in the interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute </td></tr>
    <tr><td class="paramname">attr</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00101">101</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53a8c29748bafb1f3119d062c19dc0e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Attribute.html">Attribute</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an existing attribute object to the configuration interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute. <em>attr</em> will be initialized with this name. </td></tr>
    <tr><td class="paramname">attr</td><td>The attribute to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get. ">Attribute</a> object by reference, which you can further query or use. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>attr.ready() == true </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00115">115</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="AttributeBase_8hpp_source.html#l00089">RTT::base::AttributeBase::ready()</a>, and <a class="el" href="Attribute_8cpp_source.html#l00064">RTT::base::AttributeBase::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e4f82517c3b1ec1297122ef1d9de0fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data. ">base::AttributeBase</a> which remains owned by the user. </p>
<p>This is a low-level function that can be used if you already created an <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get. ">Attribute</a> object that does not belong yet to a service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>remains owned by the user, and becomes served by the repository. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00204">204</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a88425e387dbeeaec504e5c4ae98de7c7">RTT::base::AttributeBase::clone()</a>, and <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a3d2ad8fcaa5104bc86a135e203f27d33">RTT::base::AttributeBase::getDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1cb31505af2ec04d16cc0015f4ef32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addConstant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>cnst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a variable of any type as read-only attribute to the configuration interface. </p>
<p>An <a class="el" href="classRTT_1_1Alias.html" title="This class is the most basic Attribute implementation (only suitable for reading a internal::DataSour...">Alias</a> is created which causes contents of the attribute always to be in sync with the contents of <em>cnst</em>, but it can only be read through the interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute </td></tr>
    <tr><td class="paramname">cnst</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00135">135</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a670818300e4efb32da6532fa815d1baa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addConstant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Constant.html">Constant</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cnst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an existing constant object to the configuration interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this constant. <em>cnst</em> will be initialized with this name. </td></tr>
    <tr><td class="paramname">cnst</td><td>The constant to add. If cnst has not been initialized, it will be initialized to T(). You can change it later-on using the <a class="el" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation. ">Constant</a>'s API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation. ">Constant</a> object by reference, which you can further query or use. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>cnst.ready() == true </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00150">150</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="AttributeBase_8hpp_source.html#l00089">RTT::base::AttributeBase::ready()</a>, and <a class="el" href="Attribute_8cpp_source.html#l00064">RTT::base::AttributeBase::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="aacb93dbd0439b6b67abe7e5aecfdc2fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a <a class="el" href="classRTT_1_1Constant.html" title="As opposed to a Attribute, a Constant can not be assigned to a new value after creation. ">Constant</a> with a given value. </p>
<dl class="section see"><dt>See Also</dt><dd>getConstant </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00232">232</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a88425e387dbeeaec504e5c4ae98de7c7">RTT::base::AttributeBase::clone()</a>, and <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a3d2ad8fcaa5104bc86a135e203f27d33">RTT::base::AttributeBase::getDataSource()</a>.</p>

</div>
</div>
<a class="anchor" id="a089897b16e398886de8a3b0fb86b1045"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a>&amp; RTT::DataFlowInterface::addEventPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotFunction&#160;</td>
          <td class="paramname"><em>callback</em> = <code>SlotFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name and add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give to the port. </td></tr>
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called when new data arrives on this port. The callback function will be called <b>instead</b> of updateHook(). Use this-&gt;trigger() in your callback function in order to schedule an updateHook() nevertheless in the same cycle. If callback is not provided, updateHook() will be executed by default. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00117">117</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

<p>References <a class="el" href="PortInterface_8cpp_source.html#l00051">RTT::base::PortInterface::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ee64763dfe8053940fa81fe2582d5be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">InputPortInterface</a> &amp; RTT::DataFlowInterface::addEventPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotFunction&#160;</td>
          <td class="paramname"><em>callback</em> = <code>SlotFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port. </p>
<p>When data arrives on this port your <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> will be woken up and updateHook() will be executed by default. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called when new data arrives on this port. The callback function will be called <b>instead</b> of updateHook(). Use this-&gt;trigger() in your callback function in order to schedule an updateHook() nevertheless in the same cycle. If callback is not provided, updateHook() will be executed by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00097">97</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8cpp_source.html#l00135">RTT::DataFlowInterface::addLocalEventPort()</a>, <a class="el" href="Service_8cpp_source.html#l00083">RTT::Service::addService()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00238">RTT::DataFlowInterface::createPortObject()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00079">RTT::base::PortInterface::getName()</a>, <a class="el" href="Service_8cpp_source.html#l00181">RTT::Service::hasService()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00284">RTT::DataFlowInterface::mservice</a>, <a class="el" href="Service_8cpp_source.html#l00114">RTT::Service::provides()</a>, and <a class="el" href="Service_8cpp_source.html#l00105">RTT::Service::removeService()</a>.</p>

</div>
</div>
<a class="anchor" id="ae90b18e5b4d26af2062cff0feaf9cb57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">InputPortInterface</a> &amp; RTT::DataFlowInterface::addLocalEventPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlotFunction&#160;</td>
          <td class="paramname"><em>callback</em> = <code>SlotFunction()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an Event triggering Port to this task without registering a service for it. </p>
<p>When data arrives on this port your <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> will be woken up and updateHook will be executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called when new data arrives on this port. The callback function will be called in sequence with updateHook(), so asynchronously with regard to the arrival of data on the port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00135">135</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8cpp_source.html#l00082">RTT::DataFlowInterface::addLocalPort()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00079">RTT::base::PortInterface::getName()</a>, <a class="el" href="Service_8hpp_source.html#l00142">RTT::Service::getName()</a>, <a class="el" href="Service_8hpp_source.html#l00188">RTT::Service::getOwner()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00284">RTT::DataFlowInterface::mservice</a>, <a class="el" href="InputPortInterface_8cpp_source.html#l00112">RTT::base::InputPortInterface::signalInterface()</a>, and <a class="el" href="TaskCore_8cpp_source.html#l00088">RTT::base::TaskCore::trigger()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00097">RTT::DataFlowInterface::addEventPort()</a>.</p>

</div>
</div>
<a class="anchor" id="abcdccc873fb77f51f5d53cca01bcdf58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::addLocalOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1OperationBase.html">base::OperationBase</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a> object to the operation interface. </p>
<p>This version of addOperation does not add the <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a> object to the remote interface and only to the local, in-process C++ interface.</p>
<dl class="section note"><dt>Note</dt><dd>Do not use this function unless you know what you're doing. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1Service.html#abd4f94e4184b2f470053ad54c42e6dda" title="Add an operation object to the interface. ">addOperation()</a> for adding normal, remotely available operations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a> object to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it could be added, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00187">187</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, <a class="el" href="classRTT_1_1base_1_1OperationBase.html#a710a6931a7b0e7dfc96620028ef85a5d">RTT::base::OperationBase::getImplementation()</a>, <a class="el" href="OperationBase_8hpp_source.html#l00084">RTT::base::OperationBase::getName()</a>, <a class="el" href="Service_8cpp_source.html#l00248">RTT::Service::removeOperation()</a>, and <a class="el" href="OperationBase_8hpp_source.html#l00116">RTT::base::OperationBase::setOwner()</a>.</p>

</div>
</div>
<a class="anchor" id="a958627b0442cb97f4e91f9fae0f6eee0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> &amp; RTT::DataFlowInterface::addLocalPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a Port to this task without registering a service for it. </p>
<p>If a port with the same name already exists, addPort will replace it with <em>port</em> and log a warning. </p>
<dl class="section return"><dt>Returns</dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00082">82</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="PortInterface_8hpp_source.html#l00079">RTT::base::PortInterface::getName()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00280">RTT::DataFlowInterface::mports</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00186">RTT::DataFlowInterface::removeLocalPort()</a>, and <a class="el" href="PortInterface_8cpp_source.html#l00100">RTT::base::PortInterface::setInterface()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00135">RTT::DataFlowInterface::addLocalEventPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>.</p>

</div>
</div>
<a class="anchor" id="abd4f94e4184b2f470053ad54c42e6dda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt;Signature&gt;&amp; RTT::Service::addOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an operation object to the interface. </p>
<p>This version of addOperation exports an existing <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a> object to the public interface of this component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given parameter <em>op</em> </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00344">344</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>References <a class="el" href="OperationBase_8hpp_source.html#l00084">RTT::base::OperationBase::getName()</a>.</p>

<p>Referenced by <a class="el" href="MarshallingService_8cpp_source.html#l00062">RTT::marsh::MarshallingService::MarshallingService()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f467780775bea590fcb6e6eef72b580"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt;Func&gt;::Signature &gt;&amp; RTT::Service::addOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an operation to the interface by means of a C++ Class member function. </p>
<p>The function <em>func</em> must be a C++ member function and <em>obj</em> is the object having that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new operation </td></tr>
    <tr><td class="paramname">func</td><td>A pointer to a function, for example, &amp;Bar::foo (C++ class function). </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object that will execute the function. </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread choice: will the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> of this service execute the function <em>func</em> in its own thread, or will the client's thread (the caller) execute <em>func</em> ?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created operation object, which you may further document or query. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00405">405</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fd3085e2a555ca4b7e7d01ac51ce7b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Func &gt;&amp; RTT::Service::addOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an operation to the interface by means of a free C/C++ function. </p>
<p>The function <em>func</em> must be a free C/C++ function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new operation </td></tr>
    <tr><td class="paramname">func</td><td>A pointer to a C function, for example, &amp;foo (or a <b>static</b> C++ class function). </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread choice: will the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> of this service execute the function <em>func</em> in its own thread, or will the client's thread (the caller) execute <em>func</em> ?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created operation object, which you may further document or query. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00426">426</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16c55fbf8e8b5fbc74ff3fe5aaddf4bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class ObjT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <a class="el" href="structRTT_1_1internal_1_1GetSignatureDS.html">internal::GetSignatureDS</a>&lt;Func&gt;::Signature&gt;&amp; RTT::Service::addOperationDS </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For internal use only. </p>
<p>The pointer of the object of which a member function must be invoked is stored in a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">internal::DataSource</a> such that the pointer can change during program execution. Required in scripting for state machines. </p>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00509">509</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>Referenced by <a class="el" href="ProgramService_8cpp_source.html#l00052">RTT::scripting::ProgramService::ProgramService()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5dd40574f3049800e2a8695f548f4b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature , class ObjT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt;Signature&gt;&amp; RTT::Service::addOperationDS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; boost::shared_ptr&lt; ObjT &gt; &gt; *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For internal use only. </p>
<p>The pointer of the object of which a member function must be invoked is stored in a <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">internal::DataSource</a> such that the pointer can change during program execution. Required in scripting for state machines. </p>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00524">524</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>References <a class="el" href="OperationBase_8hpp_source.html#l00084">RTT::base::OperationBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4cc8251add66d43626fb5a36630a86d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a>&amp; RTT::DataFlowInterface::addPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name and add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give to the port. </td></tr>
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00089">89</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

<p>References <a class="el" href="PortInterface_8cpp_source.html#l00051">RTT::base::PortInterface::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a7439b0849223846eaef9e857e2863b8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> &amp; RTT::DataFlowInterface::addPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port. </p>
<p>If a port or service with the name already exists, addPort will replace them with <em>port</em> and log a warning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>port</em> </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">59</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8cpp_source.html#l00082">RTT::DataFlowInterface::addLocalPort()</a>, <a class="el" href="Service_8cpp_source.html#l00083">RTT::Service::addService()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00238">RTT::DataFlowInterface::createPortObject()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00079">RTT::base::PortInterface::getName()</a>, <a class="el" href="Service_8cpp_source.html#l00181">RTT::Service::hasService()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00284">RTT::DataFlowInterface::mservice</a>, <a class="el" href="Service_8cpp_source.html#l00114">RTT::Service::provides()</a>, and <a class="el" href="Service_8cpp_source.html#l00105">RTT::Service::removeService()</a>.</p>

</div>
</div>
<a class="anchor" id="aef82495c4e0b04ad555914c7216f76c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a variable of any type as a property to the configuration interface. </p>
<p>A <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> is created which causes contents of the property always to be in sync with the contents of <em>prop</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this property </td></tr>
    <tr><td class="paramname">prop</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> object by reference, which you can further query or document. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00171">171</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00071">RTT::scripting::ScriptingService::ScriptingService()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f56e23ad7dbb378acc61367c281adf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt;T&gt;&amp; RTT::ConfigurationInterface::addProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an existing property object to the configuration interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this property. <em>prop</em> will be initialized with this name. </td></tr>
    <tr><td class="paramname">prop</td><td>The property to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> object by reference, which you can further query or document. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>prop.ready() == true </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00184">184</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

<p>References <a class="el" href="PropertyBase_8hpp_source.html#l00114">RTT::base::PropertyBase::ready()</a>, and <a class="el" href="PropertyBase_8cpp_source.html#l00059">RTT::base::PropertyBase::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="aef004414e0bd9e610188e750a88648c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::addProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1base_1_1PropertyBase.html" title="Base class for all properties. ">base::PropertyBase</a> as a property. </p>
<dl class="section return"><dt>Returns</dt><dd>false if a property with the same name already exists. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1ConfigurationInterface.html#a7cea1140a7dc44ef70adbe472d2e54c3" title="Remove a previously added Property and associated attribute. ">removeProperty</a> </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00090">90</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="PropertyBase_8hpp_source.html#l00088">RTT::base::PropertyBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d23e90906042881cc9315e1bd98f449"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::addService </td>
          <td>(</td>
          <td class="paramtype">Service::shared_ptr&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new sub-service to this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>This object becomes owned by this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>obj will take a Service::shared_ptr to this and vice versa. In case <em>this</em> <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> is not yet reference counted, obj will hold the only reference count to this.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if it could be added, false if such service already exists. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00083">83</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00566">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00097">RTT::DataFlowInterface::addEventPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>.</p>

</div>
</div>
<a class="anchor" id="ad48f4deb45e99802ffd615015769fc0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt;Signature&gt;&amp; RTT::Service::addSynchronousOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an operation object to the interface. </p>
<p>This version exports an existing <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a> object to the synchronous interface of the component</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given parameter <em>op</em> </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00382">382</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>References <a class="el" href="OperationBase_8hpp_source.html#l00084">RTT::base::OperationBase::getName()</a>.</p>

<p>Referenced by <a class="el" href="PortInterface_8cpp_source.html#l00079">RTT::base::PortInterface::createPortObject()</a>.</p>

</div>
</div>
<a class="anchor" id="ae01fee5e61de4416b8393b17fdde7d2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt;Func&gt;::Signature &gt;&amp; RTT::Service::addSynchronousOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an operation to the synchronous interface by means of a function. </p>
<p>The function <em>func</em> must be a C++ Class member function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new operation </td></tr>
    <tr><td class="paramname">func</td><td>A pointer to a function, for example &amp;Bar::foo (C++ class function). </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object that will execute the function in case of a C++ class function, </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread choice: will the owning <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> of this service execute the function <em>func</em> in its own thread, or will the client's thread (the caller) execute <em>func</em> ?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created operation object, which you may further document or query. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00495">495</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a490fc9133d21ccd6f8e2388ab07431c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::Service::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all added operations, properties and sub-services from this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Since sub-services hold a reference to <em>this</em> <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>, <a class="el" href="classRTT_1_1Service.html#a490fc9133d21ccd6f8e2388ab07431c2" title="Clear all added operations, properties and sub-services from this Service. ">clear()</a> may also delete this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>. In order to protect against such deletion, take a Service::shared_ptr to <em>this</em> before calling <a class="el" href="classRTT_1_1Service.html#a490fc9133d21ccd6f8e2388ab07431c2" title="Clear all added operations, properties and sub-services from this Service. ">clear()</a>. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00219">219</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="OperationInterface_8cpp_source.html#l00058">RTT::OperationInterface::clear()</a>, <a class="el" href="ConfigurationInterface_8cpp_source.html#l00070">RTT::ConfigurationInterface::clear()</a>, <a class="el" href="Service_8cpp_source.html#l00105">RTT::Service::removeService()</a>, and <a class="el" href="Service_8hpp_source.html#l00566">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="ScriptingService_8cpp_source.html#l00092">RTT::scripting::ScriptingService::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="ab56fd107358cd0a8ebdfe2aead4e8a24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ConfigurationInterface.html">ConfigurationInterface</a> * RTT::ConfigurationInterface::copy </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; const <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> *, <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html">base::DataSourceBase</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>instantiate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new copy of this repository with the copy operation semantics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instantiate</td><td>set to true if you want a copy which will upon any future copy return the same DataSources, thus 'fixating' or 'instantiating' the DataSources. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1base_1_1ActionInterface.html" title="Based on the software pattern &#39;command&#39;, this interface allows execution of action objects...">base::ActionInterface</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this does not copy the <a class="el" href="classRTT_1_1ConfigurationInterface.html#ac2398778a4b987d13ad205de64b65475" title="Return a bag of all properties. ">properties()</a> within this repository. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00060">60</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="ConfigurationInterface_8cpp_source.html#l00078">RTT::ConfigurationInterface::setValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a56d813e588db7acf6266492c53bb5062"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::Create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td>
          <td class="paramname"><em>owner</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with a name and an owner. </p>
<p>Each service must be owned by a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> and the owner can be set afterwards with setOwner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this service. </td></tr>
    <tr><td class="paramname">owner</td><td>The <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> that will execute the operations of this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>When using boost &lt; 1.40, the owner is not stored in the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>, until the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> object is effectively added to the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1Service.html#af09c4e953c52113e8a117d7f65cae7ef" title="The owner is the top-level TaskContext owning this service (indirectly). ">getOwner()</a> </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00052">52</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8hpp_source.html#l00257">RTT::TaskContext::provides()</a>.</p>

</div>
</div>
<a class="anchor" id="a304d85203882c54aac4bbcab91d0da13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1internal_1_1OperationCallerC.html">internal::OperationCallerC</a> RTT::Service::create </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a OperationCallerC object, a template-less operation invocation object. </p>
<p>This function is inferior to <a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c" title="Get a previously added operation for use in a C++ OperationCaller object. ">getOperation(std::string name)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object which can invoke a operation. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00285">285</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="OperationInterface_8cpp_source.html#l00188">RTT::OperationInterface::getPart()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8a5bb35c562641a32e2fe907c8a6efb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Service.html">Service</a> * RTT::DataFlowInterface::createPortObject </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> through which one can access a Port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00238">238</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="PortInterface_8cpp_source.html#l00079">RTT::base::PortInterface::createPortObject()</a>, <a class="el" href="Service_8hpp_source.html#l00147">RTT::Service::doc()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00211">RTT::DataFlowInterface::getPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00220">RTT::DataFlowInterface::getPortDescription()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00097">RTT::DataFlowInterface::addEventPort()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>.</p>

</div>
</div>
<a class="anchor" id="a843066924eb7c079832718c5cf15e7a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1OperationInterface.html#a33038c30f37f51ba4e0f71ffa3dd78db">OperationInterface::Descriptions</a> OperationInterface::getArgumentList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the names and descriptions of all arguments of an operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of descriptions. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name. ">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00146">146</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6d8ac5248f6005053d90cdfe76cd05a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OperationInterface::getArity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the number of arguments of an operation. </p>
<p>These are the number of function arguments, not counting the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arity, or -1 if <em>name</em> is not found. </dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00077">77</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0151ba33c1e610eb168c8b72b2f69545"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OperationInterface::getCollectArity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the collectable number of arguments of an operation. </p>
<p>These are the return value (if non void) and each non-const reference argument of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arity, or -1 if <em>name</em> is not found. </dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00085">85</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0154dd6d15f610f5347ed2a4e9e96bcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string OperationInterface::getDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the description of an operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A user readable description. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name. ">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00162">162</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f714307df9151bee776127196832859"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> &gt; RTT::Service::getLocalOperation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a locally added operation from this interface. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this function unless you know what you're doing. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c" title="Get a previously added operation for use in a C++ OperationCaller object. ">getOperation()</a> for getting normal, remotely available operations. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00212">212</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8cpp_source.html#l00242">RTT::Service::hasOperation()</a>.</p>

</div>
</div>
<a class="anchor" id="a43c2db6bcad1ea88a22191e8780d4e3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> * RTT::Service::getOperation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a previously added operation for use in a C++ <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> object. </p>
<p>Store the result of this function in a OperationCaller&lt;Signature&gt; object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an operation interface part or a null pointer if <em>name</em> was not found. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00151">151</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00142">RTT::Service::getName()</a>, <a class="el" href="OperationInterface_8cpp_source.html#l00188">RTT::OperationInterface::getPart()</a>, and <a class="el" href="OperationInterface_8cpp_source.html#l00072">RTT::OperationInterface::hasMember()</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00169">RTT::Service::setOperationThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a0bd085079896f5242c5656f8ee5034a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> RTT::Service::getOperation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For internal use only. </p>
<p>Get a previously added operation as a DataSource. This function is inferior to <a class="el" href="classRTT_1_1Service.html#a43c2db6bcad1ea88a22191e8780d4e3c" title="Get a previously added operation for use in a C++ OperationCaller object. ">getOperation(std::string name)</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments of the operation as Data Sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">internal::DataSource</a> which, when evaluated, invokes the operation. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00543">543</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ca6c54840653c4b0dfab69df8839598"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; RTT::Service::getOperationNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the names of all operations added to this interface. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1OperationInterface.html#a91ddca9d0376b78c7617ac790f985e58" title="Get a list of all the names of the added operations. ">getNames()</a> to get a list of all operations available to <a class="el" href="namespaceRTT_1_1scripting.html" title="Parser code for the Orocos real-time scripting language. ">scripting</a>. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00236">236</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af09c4e953c52113e8a117d7f65cae7ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a>* RTT::Service::getOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The owner is the top-level <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> owning this service (indirectly). </p>
<p>A <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> can only belong to one <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function will only return the owner after the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> has been added to the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </dd></dl>

<p>Definition at line <a class="el" href="Service_8hpp_source.html#l00188">188</a> of file <a class="el" href="Service_8hpp_source.html">Service.hpp</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00135">RTT::DataFlowInterface::addLocalEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00128">RTT::DataFlowInterface::dataOnPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00055">RTT::DataFlowInterface::getOwner()</a>, <a class="el" href="Service_8cpp_source.html#l00077">RTT::Service::getOwnerExecutionEngine()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00360">RTT::scripting::ScriptingService::loadProgram()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00185">RTT::scripting::ScriptingService::loadStateMachine()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00165">RTT::DataFlowInterface::removePort()</a>, and <a class="el" href="Service_8cpp_source.html#l00169">RTT::Service::setOperationThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e33b3a154e6e7e00d8a3f3adce25ac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> * RTT::Service::getOwnerExecutionEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the execution engine of this service owner. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1Service.html#af09c4e953c52113e8a117d7f65cae7ef" title="The owner is the top-level TaskContext owning this service (indirectly). ">getOwner</a> </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00077">77</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, and <a class="el" href="Service_8hpp_source.html#l00188">RTT::Service::getOwner()</a>.</p>

</div>
</div>
<a class="anchor" id="af1793b4990e68890a210820bd8922311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> * OperationInterface::getPart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a previously added part of this factory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00188">188</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00285">RTT::Service::create()</a>, and <a class="el" href="Service_8cpp_source.html#l00151">RTT::Service::getOperation()</a>.</p>

</div>
</div>
<a class="anchor" id="a87a4e6066c255dd36059f5e9d791eecb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">PortInterface</a> * RTT::DataFlowInterface::getPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an added port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a port or null if it does not exist. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00211">211</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00280">RTT::DataFlowInterface::mports</a>.</p>

<p>Referenced by <a class="el" href="TaskContext_8cpp_source.html#l00147">RTT::TaskContext::connectPorts()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00238">RTT::DataFlowInterface::createPortObject()</a>.</p>

</div>
</div>
<a class="anchor" id="af969a2411243abdea4a897753dc68850"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RTT::DataFlowInterface::getPortDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the description of an added Port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The description or "" if it does not exist. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00220">220</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00280">RTT::DataFlowInterface::mports</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00238">RTT::DataFlowInterface::createPortObject()</a>.</p>

</div>
</div>
<a class="anchor" id="adb1cd98ccf5d14b6a510f65b37bae841"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1DataFlowInterface.html#ad7e28572572757c85aefab22f103dff3">DataFlowInterface::PortNames</a> RTT::DataFlowInterface::getPortNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all port names of this interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A sequence of strings containing the port names. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>by getNames() </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00202">202</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00280">RTT::DataFlowInterface::mports</a>.</p>

</div>
</div>
<a class="anchor" id="a697023207fdd61c0ae65d3f7b55bf57e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1DataFlowInterface.html#a8aa0a7f72a75baf5d4993816de8d0b5b">DataFlowInterface::Ports</a> RTT::DataFlowInterface::getPorts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all ports of this interface. </p>
<dl class="section return"><dt>Returns</dt><dd>A sequence of pointers to ports. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">198</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00280">RTT::DataFlowInterface::mports</a>.</p>

<p>Referenced by <a class="el" href="TaskContext_8cpp_source.html#l00147">RTT::TaskContext::connectPorts()</a>, and <a class="el" href="TaskContext_8cpp_source.html#l00285">RTT::TaskContext::disconnect()</a>.</p>

</div>
</div>
<a class="anchor" id="accd042c5788def6124d04d9ea0b37c20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a>* RTT::ConfigurationInterface::getProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> with name <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the property to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The PropertyBase with this name, zero if it does not exist. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8hpp_source.html#l00275">275</a> of file <a class="el" href="ConfigurationInterface_8hpp_source.html">ConfigurationInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9887ac7ed938277edf7063063e849223"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string OperationInterface::getResultType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type name of the result type of an operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A name of a data type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name. ">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00154">154</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aedae8dc1fc49511be315d4abe1682605"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Service.html">Service</a>* RTT::DataFlowInterface::getService </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the service this interface belongs to. </p>
<p>The returned service is a service living in the component returned by <a class="el" href="classRTT_1_1DataFlowInterface.html#a2a8228f2601888b717209ed65379f84f" title="Returns the component this interface belongs to. ">getOwner()</a> or in one of its sub-services. </p>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00203">203</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad51ab122e01b561762386fcc8fabb55d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::getService </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a shared pointer to strictly a sub-service of a null pointer if !hasService(service_name). </p>
<p>This method will not return the <em>this</em> pointer when service_name equals "this" or create new service objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>The name of the sub-service to be returned. or created, or the result of <a class="el" href="classRTT_1_1Service.html#a224b685592dec643289798cac7ad8e2c" title="Returns this Service, unless no shared_ptr yet exists. ">provides()</a> in case of "this". </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00144">144</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00566">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00229">RTT::DataFlowInterface::setPortDescription()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ac758c65de8fae3be3bc4ed3eac3495"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::hasOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query for the existence of a <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a> in this interface. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1OperationInterface.html#a1f0c72ef924fbd180eebbcc1e93e590b" title="Query if an operation is present. ">hasMember()</a> to verify if a operation is available to <a class="el" href="namespaceRTT_1_1scripting.html" title="Parser code for the Orocos real-time scripting language. ">scripting</a> as well. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00242">242</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00212">RTT::Service::getLocalOperation()</a>, <a class="el" href="Service_8cpp_source.html#l00248">RTT::Service::removeOperation()</a>, <a class="el" href="Service_8cpp_source.html#l00161">RTT::Service::resetOperation()</a>, and <a class="el" href="Service_8cpp_source.html#l00169">RTT::Service::setOperationThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a986074c32d5232b44d12f62515c3cac2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::hasService </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this service has the sub-service <em>service_name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>The name of the sub-service to be queried. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00181">181</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00566">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00097">RTT::DataFlowInterface::addEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00176">RTT::marsh::MarshallingService::loadServiceProperties()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00198">RTT::marsh::MarshallingService::readServiceProperties()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00239">RTT::marsh::MarshallingService::readServiceProperty()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00165">RTT::DataFlowInterface::removePort()</a>, <a class="el" href="GlobalService_8cpp_source.html#l00041">RTT::internal::GlobalService::require()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00187">RTT::marsh::MarshallingService::storeServiceProperties()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00228">RTT::marsh::MarshallingService::updateServiceFile()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00208">RTT::marsh::MarshallingService::updateServiceProperties()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00218">RTT::marsh::MarshallingService::writeServiceProperties()</a>, and <a class="el" href="MarshallingService_8cpp_source.html#l00249">RTT::marsh::MarshallingService::writeServiceProperty()</a>.</p>

</div>
</div>
<a class="anchor" id="a1106ef1dc8f222a0595e50ad93637b45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OperationInterface::isSynchronous </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if a given operation is limited to sychronous invocation (own component thread) only. </p>
<dl class="section return"><dt>Returns</dt><dd>false if name not found or a normal operation, true if name exists but is synchronous. </dd></dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00093">93</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8762e2fbdbaa9e88f90474c2bb73cfc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce a DataSource that call()s an operation. </p>
<p>The DataSource will return the result of call().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name. ">name_not_found_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00105">105</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91a921268272a88f33029e220c2b512c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produceCollect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">internal::DataSource</a>&lt; bool &gt;::shared_ptr&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce a DataSource that collects a sent operation, The DataSource will return the SendStatus and store the results in the presented arguments. </p>
<p>Note that this function takes most of the time less arguments than its companions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources. </td></tr>
    <tr><td class="paramname">blocking</td><td>Set to true to block on the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name. ">name_not_found_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1no__asynchronous__operation__exception.html" title="Exception thrown when a factory is requested to produce an asynchronous object while it is not availa...">no_asynchronous_operation_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00129">129</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9330b6a57234e636220e32636a16a45a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produceHandle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce an AssignableDataSource that contains a <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation. ">SendHandle</a>, fit for the operation. </p>
<p>The DataSource will return the <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation. ">SendHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name. ">name_not_found_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1no__asynchronous__operation__exception.html" title="Exception thrown when a factory is requested to produce an asynchronous object while it is not availa...">no_asynchronous_operation_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00121">121</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3e9bd1086d592eba8612e7bd0f67b9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> OperationInterface::produceSend </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRTT_1_1OperationInterface.html#a09243638f9e56f5322ccf49cc67ca4bb">Arguments</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce a DataSource that send()s an operation. </p>
<p>The DataSource will return the <a class="el" href="classRTT_1_1SendHandle.html" title="The SendHandle is used to collect the result values of an asynchronous invocation. ">SendHandle</a> of that operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">args</td><td>The arguments filled in as data sources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__number__of__args__exception.html" title="Exception thrown when a factory is requested to create an object but the wrong number of arguments wa...">wrong_number_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1wrong__types__of__args__exception.html" title="Exception thrown when a factory is requested to create an object, but a wrong argument type was given...">wrong_types_of_args_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1name__not__found__exception.html" title="Exception thrown when a factory is requested to create an object with an unknown name. ">name_not_found_exception</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="structRTT_1_1no__asynchronous__operation__exception.html" title="Exception thrown when a factory is requested to produce an asynchronous object while it is not availa...">no_asynchronous_operation_exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00113">113</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a224b685592dec643289798cac7ad8e2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::provides </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <em>this</em> <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>, unless no shared_ptr yet exists. </p>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer from this. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_exception</td><td>when no Service::shared_ptr to this exists yet. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00114">114</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00097">RTT::DataFlowInterface::addEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00176">RTT::marsh::MarshallingService::loadServiceProperties()</a>, <a class="el" href="Service_8cpp_source.html#l00124">RTT::Service::provides()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00198">RTT::marsh::MarshallingService::readServiceProperties()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00239">RTT::marsh::MarshallingService::readServiceProperty()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00165">RTT::DataFlowInterface::removePort()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00187">RTT::marsh::MarshallingService::storeServiceProperties()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00228">RTT::marsh::MarshallingService::updateServiceFile()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00208">RTT::marsh::MarshallingService::updateServiceProperties()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00218">RTT::marsh::MarshallingService::writeServiceProperties()</a>, and <a class="el" href="MarshallingService_8cpp_source.html#l00249">RTT::marsh::MarshallingService::writeServiceProperty()</a>.</p>

</div>
</div>
<a class="anchor" id="a52e9501a0c0ef27bde331ddaa5e63538"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::Service::provides </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sub-Service which resorts under this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>, creating a new one if it does not yet exists. </p>
<p>Use <a class="el" href="classRTT_1_1Service.html#ad51ab122e01b561762386fcc8fabb55d" title="Returns a shared pointer to strictly a sub-service of a null pointer if !hasService(service_name). ">getService()</a> if no <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> object creation should be done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>The name of the sub-service to be returned or created, or the result of <a class="el" href="classRTT_1_1Service.html#a224b685592dec643289798cac7ad8e2c" title="Returns this Service, unless no shared_ptr yet exists. ">provides()</a> in case of "this". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1Service.html#a224b685592dec643289798cac7ad8e2c" title="Returns this Service, unless no shared_ptr yet exists. ">provides()</a> for querying for "this". </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00124">124</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8cpp_source.html#l00114">RTT::Service::provides()</a>, and <a class="el" href="Service_8hpp_source.html#l00566">RTT::Service::services</a>.</p>

</div>
</div>
<a class="anchor" id="a72938e680f9d2394b08c6ef45aee2e80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OperationInterface::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an added operation from the interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="OperationInterface_8cpp_source.html#l00178">178</a> of file <a class="el" href="OperationInterface_8cpp_source.html">OperationInterface.cpp</a>.</p>

<p>Referenced by <a class="el" href="Service_8cpp_source.html#l00248">RTT::Service::removeOperation()</a>.</p>

</div>
</div>
<a class="anchor" id="abdccc95629af8c46757fc5973ab10e10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::DataFlowInterface::removeLocalPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a locally added Port from this interface. </p>
<p>This will remove all connections and callbacks assosiated with this port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function will not check if a service with the same name as <em>name</em> exists, and will not remove it. So use <a class="el" href="classRTT_1_1DataFlowInterface.html#a176244c5979a8010ae7dcc0a3db3bb63" title="Remove a Port from this interface. ">removePort()</a> in case you want to get rid of the service as well. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00186">186</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="DataFlowInterface_8hpp_source.html#l00280">RTT::DataFlowInterface::mports</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00082">RTT::DataFlowInterface::addLocalPort()</a>.</p>

</div>
</div>
<a class="anchor" id="a176244c5979a8010ae7dcc0a3db3bb63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::DataFlowInterface::removePort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a Port from this interface. </p>
<p>This will remove all services, connections and callbacks assosiated with this port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Since services are refcounted, removePort may effectively delete the <em>this</em> object in case no Service::shared_ptr exists to this <a class="el" href="classRTT_1_1DataFlowInterface.html" title="The Interface of a TaskContext which exposes its data-flow ports. ">DataFlowInterface</a>. In order to prevent such cleanup, create a Service::shared_ptr to this object before calling <a class="el" href="classRTT_1_1DataFlowInterface.html#a176244c5979a8010ae7dcc0a3db3bb63" title="Remove a Port from this interface. ">removePort()</a>. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00165">165</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00188">RTT::Service::getOwner()</a>, <a class="el" href="Service_8cpp_source.html#l00181">RTT::Service::hasService()</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00280">RTT::DataFlowInterface::mports</a>, <a class="el" href="DataFlowInterface_8hpp_source.html#l00284">RTT::DataFlowInterface::mservice</a>, <a class="el" href="Service_8cpp_source.html#l00114">RTT::Service::provides()</a>, and <a class="el" href="Service_8cpp_source.html#l00105">RTT::Service::removeService()</a>.</p>

</div>
</div>
<a class="anchor" id="a7cea1140a7dc44ef70adbe472d2e54c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::removeProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a previously added <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> and associated attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>false if no such property exists. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00129">129</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="PropertyBase_8hpp_source.html#l00088">RTT::base::PropertyBase::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa0389e2b340c1c2b2405289eae7ff3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::Service::removeService </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a previously added sub-service, potentially freeing it (and <em>this</em>) from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>the name of the service to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Since service_name holds a reference to <em>this</em> <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>, removeService may also delete this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>. In order to protect against such deletion, take a Service::shared_ptr to <em>this</em> before calling removeService. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00105">105</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="Service_8hpp_source.html#l00566">RTT::Service::services</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00097">RTT::DataFlowInterface::addEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00253">RTT::DataFlowInterface::clear()</a>, <a class="el" href="Service_8cpp_source.html#l00219">RTT::Service::clear()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00165">RTT::DataFlowInterface::removePort()</a>.</p>

</div>
</div>
<a class="anchor" id="a447c3a77e8dd12b18ba02b059604ee87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::Service::setOperationThread </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the thread of execution of a previously added operation. </p>
<p>Only the component itself should modify this property. Don't call this function from outside the component, it has unspecified behaviour when not called from within one of the member functions or a service of the current component.</p>
<p>This function is typically used to change the ExecutionThread of the standard component hooks such as startHook(), configureHook() etc. which all have the ClientThread policy by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation to modify. For example, "start". </td></tr>
    <tr><td class="paramname">et</td><td>The ExecutionThread type in which the function of the operation will be executed, being OwnThread or ClientThread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>name</em> was a local, present operation, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Service_8cpp_source.html#l00169">169</a> of file <a class="el" href="Service_8cpp_source.html">Service.cpp</a>.</p>

<p>References <a class="el" href="OperationInterface_8cpp_source.html#l00053">RTT::OperationInterfacePart::getLocalOperation()</a>, <a class="el" href="Service_8cpp_source.html#l00151">RTT::Service::getOperation()</a>, <a class="el" href="Service_8hpp_source.html#l00188">RTT::Service::getOwner()</a>, <a class="el" href="Service_8cpp_source.html#l00242">RTT::Service::hasOperation()</a>, and <a class="el" href="OperationCallerInterface_8cpp_source.html#l00028">RTT::base::OperationCallerInterface::setThread()</a>.</p>

</div>
</div>
<a class="anchor" id="ad21b73e9f5e1e6186ad10b3ec0a1ffe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::DataFlowInterface::setPortDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the description for the service of an added port. </p>
<p>It's prefered to use getPort(name)-&gt;doc(description) instead of this method, since this function only updates the documentation of the service representing this port, and not the documentation stored in the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name </td></tr>
    <tr><td class="paramname">description</td><td>The new description for this port's service </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port was found and the description was set, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="DataFlowInterface_8cpp_source.html#l00229">229</a> of file <a class="el" href="DataFlowInterface_8cpp_source.html">DataFlowInterface.cpp</a>.</p>

<p>References <a class="el" href="Service_8cpp_source.html#l00144">RTT::Service::getService()</a>, and <a class="el" href="DataFlowInterface_8hpp_source.html#l00284">RTT::DataFlowInterface::mservice</a>.</p>

<p>Referenced by <a class="el" href="PortInterface_8cpp_source.html#l00060">RTT::base::PortInterface::doc()</a>.</p>

</div>
</div>
<a class="anchor" id="ae42d3a355376882088f6c7f407d961a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConfigurationInterface::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td>
          <td class="paramname"><em>ab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer the ownership of an attribute to the repository. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ab</td><td>The attribute which becomes owned by this repository. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if an <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get. ">Attribute</a> with the same <em>name</em> already present. </dd></dl>

<p>Definition at line <a class="el" href="ConfigurationInterface_8cpp_source.html#l00078">78</a> of file <a class="el" href="ConfigurationInterface_8cpp_source.html">ConfigurationInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1AttributeBase.html#a3d2ad8fcaa5104bc86a135e203f27d33">RTT::base::AttributeBase::getDataSource()</a>, and <a class="el" href="Attribute_8cpp_source.html#l00059">RTT::base::AttributeBase::getName()</a>.</p>

<p>Referenced by <a class="el" href="ConfigurationInterface_8cpp_source.html#l00060">RTT::ConfigurationInterface::copy()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a786bd9c13ab8ac9af980daaa4d0f8784"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Service.html">Service</a>* RTT::DataFlowInterface::mservice</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The parent <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>. </p>
<p>May be null in exceptional cases. </p>

<p>Definition at line <a class="el" href="DataFlowInterface_8hpp_source.html#l00284">284</a> of file <a class="el" href="DataFlowInterface_8hpp_source.html">DataFlowInterface.hpp</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00097">RTT::DataFlowInterface::addEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00135">RTT::DataFlowInterface::addLocalEventPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00059">RTT::DataFlowInterface::addPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00253">RTT::DataFlowInterface::clear()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00128">RTT::DataFlowInterface::dataOnPort()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00055">RTT::DataFlowInterface::getOwner()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00165">RTT::DataFlowInterface::removePort()</a>, <a class="el" href="Service_8cpp_source.html#l00059">RTT::Service::Service()</a>, and <a class="el" href="DataFlowInterface_8cpp_source.html#l00229">RTT::DataFlowInterface::setPortDescription()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rtt/scripting/<a class="el" href="StateMachineService_8hpp_source.html">StateMachineService.hpp</a></li>
<li>rtt/scripting/<a class="el" href="StateMachineService_8cpp_source.html">StateMachineService.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 10 2017 20:23:20 for Orocos Real-Time Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
