<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Orocos Real-Time Toolkit: RTT::internal::ConnFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a></li><li class="navelem"><a class="el" href="namespaceRTT_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html">ConnFactory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classRTT_1_1internal_1_1ConnFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RTT::internal::ConnFactory Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class provides the basic tools to create channels that represent connections between two ports.  
 <a href="classRTT_1_1internal_1_1ConnFactory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ConnFactory_8hpp_source.html">rtt/internal/ConnFactory.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e6084977534b007af7b60293459ca85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e6084977534b007af7b60293459ca85"></a>
virtual <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a8e6084977534b007af7b60293459ca85">inputPort</a> (std::string const &amp;name) const =0</td></tr>
<tr class="memdesc:a8e6084977534b007af7b60293459ca85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new InputPort&lt;T&gt; object where T is the type represented by this TypeInfo object. <br/></td></tr>
<tr class="separator:a8e6084977534b007af7b60293459ca85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06866691dabe4e94a84074f6dd67d78e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06866691dabe4e94a84074f6dd67d78e"></a>
virtual <a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a06866691dabe4e94a84074f6dd67d78e">outputPort</a> (std::string const &amp;name) const =0</td></tr>
<tr class="memdesc:a06866691dabe4e94a84074f6dd67d78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new OutputPort&lt;T&gt; object where T is the type represented by this TypeInfo object. <br/></td></tr>
<tr class="separator:a06866691dabe4e94a84074f6dd67d78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b6b7d809a508f51cf7dd0af2259748"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a80b6b7d809a508f51cf7dd0af2259748">buildDataStorage</a> (<a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy) const =0</td></tr>
<tr class="memdesc:a80b6b7d809a508f51cf7dd0af2259748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates single data or buffered storage for this type.  <a href="#a80b6b7d809a508f51cf7dd0af2259748">More...</a><br/></td></tr>
<tr class="separator:a80b6b7d809a508f51cf7dd0af2259748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201dd38c725e5e3de7c9a3465f8b8797"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a201dd38c725e5e3de7c9a3465f8b8797">buildChannelOutput</a> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy) const =0</td></tr>
<tr class="memdesc:a201dd38c725e5e3de7c9a3465f8b8797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the output endpoint of a communication channel and adds it to an <a class="el" href="classRTT_1_1InputPort.html" title="A component&#39;s data input port. ">InputPort</a>.  <a href="#a201dd38c725e5e3de7c9a3465f8b8797">More...</a><br/></td></tr>
<tr class="separator:a201dd38c725e5e3de7c9a3465f8b8797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4224c94c2fc87d16e5122a4f9737f5"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#ade4224c94c2fc87d16e5122a4f9737f5">buildChannelInput</a> (<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> &amp;port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy) const =0</td></tr>
<tr class="memdesc:ade4224c94c2fc87d16e5122a4f9737f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the input endpoint (starting point) of a communication channel and adds it to an <a class="el" href="classRTT_1_1OutputPort.html" title="A component&#39;s data output port. ">OutputPort</a>.  <a href="#ade4224c94c2fc87d16e5122a4f9737f5">More...</a><br/></td></tr>
<tr class="separator:ade4224c94c2fc87d16e5122a4f9737f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b8ab00d0b5cd4bb58bee977ba65119"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
internal::SharedConnectionBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a19b8ab00d0b5cd4bb58bee977ba65119">buildSharedConnection</a> (<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> *output_port, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> *input_port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy) const =0</td></tr>
<tr class="memdesc:a19b8ab00d0b5cd4bb58bee977ba65119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an existing or creates a new shared connection object for the given output port, input port and connection policy.  <a href="#a19b8ab00d0b5cd4bb58bee977ba65119">More...</a><br/></td></tr>
<tr class="separator:a19b8ab00d0b5cd4bb58bee977ba65119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a14b0f95b11aead16d69544e4d24aad48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14b0f95b11aead16d69544e4d24aad48"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a14b0f95b11aead16d69544e4d24aad48">buildDataStorage</a> (<a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy, const T &amp;initial_value=T())</td></tr>
<tr class="memdesc:a14b0f95b11aead16d69544e4d24aad48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates the connection element that will store data inside the connection, based on the given policy.  <a href="#a14b0f95b11aead16d69544e4d24aad48">More...</a><br/></td></tr>
<tr class="separator:a14b0f95b11aead16d69544e4d24aad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689d143d185d8bd250bc93bb954f3348"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a689d143d185d8bd250bc93bb954f3348"><td class="memTemplItemLeft" align="right" valign="top">static <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a689d143d185d8bd250bc93bb954f3348">buildChannelInput</a> (<a class="el" href="classRTT_1_1OutputPort.html">OutputPort</a>&lt; T &gt; &amp;port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy, bool force_unbuffered=false)</td></tr>
<tr class="memdesc:a689d143d185d8bd250bc93bb954f3348"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the process of building a connection between two ports, this method builds the input half (starting from the <a class="el" href="classRTT_1_1OutputPort.html" title="A component&#39;s data output port. ">OutputPort</a>).  <a href="#a689d143d185d8bd250bc93bb954f3348">More...</a><br/></td></tr>
<tr class="separator:a689d143d185d8bd250bc93bb954f3348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1751024fb8eec133ccddfb7995944f19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1751024fb8eec133ccddfb7995944f19"><td class="memTemplItemLeft" align="right" valign="top">static <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a1751024fb8eec133ccddfb7995944f19">buildChannelOutput</a> (<a class="el" href="classRTT_1_1InputPort.html">InputPort</a>&lt; T &gt; &amp;port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy, T const &amp;initial_value=T())</td></tr>
<tr class="memdesc:a1751024fb8eec133ccddfb7995944f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the process of building a connection between two ports, this method builds the output part of the channel, that is the half that is connected to the input port.  <a href="#a1751024fb8eec133ccddfb7995944f19">More...</a><br/></td></tr>
<tr class="separator:a1751024fb8eec133ccddfb7995944f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2b3e530474507e06a83d75bedd61ba"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#aea2b3e530474507e06a83d75bedd61ba">findSharedConnection</a> (<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> *output_port, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> *input_port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy, SharedConnectionBase::shared_ptr &amp;shared_connection)</td></tr>
<tr class="memdesc:aea2b3e530474507e06a83d75bedd61ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an existing or creates a new shared connection object for the given output port, input port and connection policy.  <a href="#aea2b3e530474507e06a83d75bedd61ba">More...</a><br/></td></tr>
<tr class="separator:aea2b3e530474507e06a83d75bedd61ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957c385690217a6eb38622edfec53105"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a957c385690217a6eb38622edfec53105"><td class="memTemplItemLeft" align="right" valign="top">static <br class="typebreak"/>
SharedConnectionBase::shared_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a957c385690217a6eb38622edfec53105">buildSharedConnection</a> (<a class="el" href="classRTT_1_1OutputPort.html">OutputPort</a>&lt; T &gt; *output_port, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> *input_port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="memdesc:a957c385690217a6eb38622edfec53105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an existing or creates a new shared connection object for the given output port, input port and connection policy.  <a href="#a957c385690217a6eb38622edfec53105">More...</a><br/></td></tr>
<tr class="separator:a957c385690217a6eb38622edfec53105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb257ca47cb10ab7db3425589b47c16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aacb257ca47cb10ab7db3425589b47c16"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#aacb257ca47cb10ab7db3425589b47c16">createConnection</a> (<a class="el" href="classRTT_1_1OutputPort.html">OutputPort</a>&lt; T &gt; &amp;output_port, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;input_port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="memdesc:aacb257ca47cb10ab7db3425589b47c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a connection from a local output_port to a local or remote input_port.  <a href="#aacb257ca47cb10ab7db3425589b47c16">More...</a><br/></td></tr>
<tr class="separator:aacb257ca47cb10ab7db3425589b47c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3442dff9c8e0cab5858a32ec0cc4f7e6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3442dff9c8e0cab5858a32ec0cc4f7e6"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a3442dff9c8e0cab5858a32ec0cc4f7e6">createStream</a> (<a class="el" href="classRTT_1_1OutputPort.html">OutputPort</a>&lt; T &gt; &amp;output_port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="memdesc:a3442dff9c8e0cab5858a32ec0cc4f7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates, attaches and checks an outbound stream to an Output port.  <a href="#a3442dff9c8e0cab5858a32ec0cc4f7e6">More...</a><br/></td></tr>
<tr class="separator:a3442dff9c8e0cab5858a32ec0cc4f7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21f07d3aea4446b0c602d7f20858e46"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa21f07d3aea4446b0c602d7f20858e46"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#aa21f07d3aea4446b0c602d7f20858e46">createStream</a> (<a class="el" href="classRTT_1_1InputPort.html">InputPort</a>&lt; T &gt; &amp;input_port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="memdesc:aa21f07d3aea4446b0c602d7f20858e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates, attaches and checks an inbound stream to an Input port.  <a href="#aa21f07d3aea4446b0c602d7f20858e46">More...</a><br/></td></tr>
<tr class="separator:aa21f07d3aea4446b0c602d7f20858e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a017c44dbb60f76485cd44f29c3962"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7a017c44dbb60f76485cd44f29c3962"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>createAndCheckSharedConnection</b> (<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> *output_port, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> *input_port, SharedConnectionBase::shared_ptr shared_connection, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="separator:ae7a017c44dbb60f76485cd44f29c3962"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:acd66073aec554f1f3671e1f891ef7b8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd66073aec554f1f3671e1f891ef7b8f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>createAndCheckConnection</b> (<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> &amp;output_port, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;input_port, base::ChannelElementBase::shared_ptr channel_input, base::ChannelElementBase::shared_ptr channel_output, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="separator:acd66073aec554f1f3671e1f891ef7b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fbbbff3dff5b7060cf74618a9d3fe0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21fbbbff3dff5b7060cf74618a9d3fe0"></a>
static <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>createAndCheckStream</b> (<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> &amp;output_port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy, base::ChannelElementBase::shared_ptr channel_input, <a class="el" href="structRTT_1_1internal_1_1StreamConnID.html">StreamConnID</a> *conn_id)</td></tr>
<tr class="separator:a21fbbbff3dff5b7060cf74618a9d3fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd528e7de3cae856be81b56a94fb010"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfd528e7de3cae856be81b56a94fb010"></a>
static <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>createAndCheckStream</b> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;input_port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy, base::ChannelElementBase::shared_ptr channel_output, <a class="el" href="structRTT_1_1internal_1_1StreamConnID.html">StreamConnID</a> *conn_id)</td></tr>
<tr class="separator:abfd528e7de3cae856be81b56a94fb010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287527aeaeae4b5bd520a07d338a1f21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a287527aeaeae4b5bd520a07d338a1f21"></a>
static <br class="typebreak"/>
base::ChannelElementBase::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>buildRemoteChannelOutput</b> (<a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> &amp;output_port, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;input_port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="separator:a287527aeaeae4b5bd520a07d338a1f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760585ae988fd85116fcbd58db8a3b77"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a760585ae988fd85116fcbd58db8a3b77"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a760585ae988fd85116fcbd58db8a3b77">createOutOfBandConnection</a> (<a class="el" href="classRTT_1_1OutputPort.html">OutputPort</a>&lt; T &gt; &amp;output_port, <a class="el" href="classRTT_1_1InputPort.html">InputPort</a>&lt; T &gt; &amp;input_port, <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;policy)</td></tr>
<tr class="memdesc:a760585ae988fd85116fcbd58db8a3b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This code is for setting up an in-process out-of-band connection.  <a href="#a760585ae988fd85116fcbd58db8a3b77">More...</a><br/></td></tr>
<tr class="separator:a760585ae988fd85116fcbd58db8a3b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides the basic tools to create channels that represent connections between two ports. </p>
<p>The ports and type transports use these functions to setup connections. The interface may change as the needs of these 'users' change. </p>

<p>Definition at line <a class="el" href="ConnFactory_8hpp_source.html#l00094">94</a> of file <a class="el" href="ConnFactory_8hpp_source.html">ConnFactory.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ade4224c94c2fc87d16e5122a4f9737f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual base::ChannelElementBase::shared_ptr RTT::internal::ConnFactory::buildChannelInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the input endpoint (starting point) of a communication channel and adds it to an <a class="el" href="classRTT_1_1OutputPort.html" title="A component&#39;s data output port. ">OutputPort</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The output port to connect the channel's input end to. </td></tr>
    <tr><td class="paramname">policy</td><td>Describes the kind of connection requested by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created endpoint. </dd></dl>

</div>
</div>
<a class="anchor" id="a689d143d185d8bd250bc93bb954f3348"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static base::ChannelElementBase::shared_ptr RTT::internal::ConnFactory::buildChannelInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1OutputPort.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_unbuffered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the process of building a connection between two ports, this method builds the input half (starting from the <a class="el" href="classRTT_1_1OutputPort.html" title="A component&#39;s data output port. ">OutputPort</a>). </p>
<p>The <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> may require to install a buffer at the output side of the channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The output port to which the connection is added. </td></tr>
    <tr><td class="paramname">policy</td><td>The policy dictating which kind of buffer must be installed. The transport and other parameters are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#a201dd38c725e5e3de7c9a3465f8b8797" title="Creates the output endpoint of a communication channel and adds it to an InputPort. ">buildChannelOutput</a> </dd></dl>

<p>Definition at line <a class="el" href="ConnFactory_8hpp_source.html#l00224">224</a> of file <a class="el" href="ConnFactory_8hpp_source.html">ConnFactory.hpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00216">RTT::ConnPolicy::buffer_policy</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00373">RTT::base::MultipleOutputsChannelElementBase::connected()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00071">RTT::base::ChannelElementBase::connectTo()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00223">RTT::base::ChannelElementBase::getBufferPolicy()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00209">RTT::base::ChannelElementBase::getConnPolicy()</a>, <a class="el" href="OutputPort_8hpp_source.html#l00333">RTT::OutputPort&lt; T &gt;::getEndpoint()</a>, <a class="el" href="OutputPort_8hpp_source.html#l00173">RTT::OutputPort&lt; T &gt;::getLastWrittenValue()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00079">RTT::base::PortInterface::getName()</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00196">RTT::ConnPolicy::lock_policy</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00209">RTT::ConnPolicy::pull</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00213">RTT::base::ChannelElementBase::setBufferPolicy()</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00193">RTT::ConnPolicy::size</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00190">RTT::ConnPolicy::type</a>.</p>

</div>
</div>
<a class="anchor" id="a201dd38c725e5e3de7c9a3465f8b8797"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual base::ChannelElementBase::shared_ptr RTT::internal::ConnFactory::buildChannelOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the output endpoint of a communication channel and adds it to an <a class="el" href="classRTT_1_1InputPort.html" title="A component&#39;s data input port. ">InputPort</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The input port to connect the channel's output end to. </td></tr>
    <tr><td class="paramname">policy</td><td>Describes the kind of connection requested by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created endpoint. </dd></dl>

</div>
</div>
<a class="anchor" id="a1751024fb8eec133ccddfb7995944f19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static base::ChannelElementBase::shared_ptr RTT::internal::ConnFactory::buildChannelOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1InputPort.html">InputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>initial_value</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the process of building a connection between two ports, this method builds the output part of the channel, that is the half that is connected to the input port. </p>
<p>The returned value is the connection element that should be connected to the end of the input-half.</p>
<p>The <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> may require to install a buffer at the output side of the channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The input port to which the connection is added. </td></tr>
    <tr><td class="paramname">policy</td><td>The policy dictating which kind of buffer must be installed. The transport and other parameters are ignored. </td></tr>
    <tr><td class="paramname">initial_value</td><td>The value to use to initialize the connection's storage buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1internal_1_1ConnFactory.html#ade4224c94c2fc87d16e5122a4f9737f5" title="Creates the input endpoint (starting point) of a communication channel and adds it to an OutputPort...">buildChannelInput</a> </dd></dl>

<p>Definition at line <a class="el" href="ConnFactory_8hpp_source.html#l00310">310</a> of file <a class="el" href="ConnFactory_8hpp_source.html">ConnFactory.hpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00216">RTT::ConnPolicy::buffer_policy</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00270">RTT::base::MultipleInputsChannelElementBase::connected()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00071">RTT::base::ChannelElementBase::connectTo()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00223">RTT::base::ChannelElementBase::getBufferPolicy()</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00209">RTT::base::ChannelElementBase::getConnPolicy()</a>, <a class="el" href="InputPort_8hpp_source.html#l00227">RTT::InputPort&lt; T &gt;::getEndpoint()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00079">RTT::base::PortInterface::getName()</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00196">RTT::ConnPolicy::lock_policy</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00209">RTT::ConnPolicy::pull</a>, <a class="el" href="ChannelInterface_8cpp_source.html#l00213">RTT::base::ChannelElementBase::setBufferPolicy()</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00193">RTT::ConnPolicy::size</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00190">RTT::ConnPolicy::type</a>.</p>

</div>
</div>
<a class="anchor" id="a80b6b7d809a508f51cf7dd0af2259748"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual base::ChannelElementBase::shared_ptr RTT::internal::ConnFactory::buildDataStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates single data or buffered storage for this type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>Describes the kind of storage requested by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a storage element. </dd></dl>

</div>
</div>
<a class="anchor" id="a14b0f95b11aead16d69544e4d24aad48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRTT_1_1base_1_1ChannelElement.html">base::ChannelElement</a>&lt;T&gt;* RTT::internal::ConnFactory::buildDataStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initial_value</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method creates the connection element that will store data inside the connection, based on the given policy. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd><p class="startdd">: shouldn't this belong in the template type info ? This allows the type lib to choose which locked/lockfree algorithms are implemented and leaves out 4x code generation for each alternative in each compilation unit. Contra: needs T in typelib. </p>
<p class="enddd">: since setDataSample, initial_value is no longer needed. </p>
</dd></dl>

<p>Definition at line <a class="el" href="ConnFactory_8hpp_source.html#l00157">157</a> of file <a class="el" href="ConnFactory_8hpp_source.html">ConnFactory.hpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00216">RTT::ConnPolicy::buffer_policy</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00196">RTT::ConnPolicy::lock_policy</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00193">RTT::ConnPolicy::size</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00190">RTT::ConnPolicy::type</a>.</p>

</div>
</div>
<a class="anchor" id="a19b8ab00d0b5cd4bb58bee977ba65119"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual internal::SharedConnectionBase::shared_ptr RTT::internal::ConnFactory::buildSharedConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> *&#160;</td>
          <td class="paramname"><em>output_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> *&#160;</td>
          <td class="paramname"><em>input_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find an existing or creates a new shared connection object for the given output port, input port and connection policy. </p>
<p>If an existing shared connection has been found, also checks if it matches the given policy and output an error otherwise. The input and output port arguments are optional and can be NULL pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_port</td><td>The output port to connect the channel's input end to (optional). </td></tr>
    <tr><td class="paramname">input_port</td><td>The output port to connect the channel's output end to (optional). </td></tr>
    <tr><td class="paramname">policy</td><td>Describes the kind of storage requested by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classRTT_1_1internal_1_1SharedConnectionBase.html" title="Base class for shared connection elements. ">SharedConnectionBase</a> element. </dd></dl>

</div>
</div>
<a class="anchor" id="a957c385690217a6eb38622edfec53105"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SharedConnectionBase::shared_ptr RTT::internal::ConnFactory::buildSharedConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1OutputPort.html">OutputPort</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>output_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> *&#160;</td>
          <td class="paramname"><em>input_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find an existing or creates a new shared connection object for the given output port, input port and connection policy. </p>
<p>If an existing shared connection has been found, also checks if it matches the given policy and output an error otherwise. The input and output port arguments are optional and can be NULL pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_port</td><td>The output port to connect the channel's input end to (optional). </td></tr>
    <tr><td class="paramname">input_port</td><td>The output port to connect the channel's output end to (optional). </td></tr>
    <tr><td class="paramname">policy</td><td>Describes the kind of storage requested by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classRTT_1_1internal_1_1SharedConnectionBase.html" title="Base class for shared connection elements. ">SharedConnectionBase</a> element. </dd></dl>

<p>Definition at line <a class="el" href="ConnFactory_8hpp_source.html#l00405">405</a> of file <a class="el" href="ConnFactory_8hpp_source.html">ConnFactory.hpp</a>.</p>

<p>References <a class="el" href="InputPortInterface_8cpp_source.html#l00133">RTT::base::InputPortInterface::createConnection()</a>, <a class="el" href="OutputPort_8hpp_source.html#l00173">RTT::OutputPort&lt; T &gt;::getLastWrittenValue()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00079">RTT::base::PortInterface::getName()</a>, <a class="el" href="PortInterface_8cpp_source.html#l00071">RTT::base::PortInterface::isLocal()</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00232">RTT::ConnPolicy::mandatory</a>.</p>

</div>
</div>
<a class="anchor" id="aacb257ca47cb10ab7db3425589b47c16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool RTT::internal::ConnFactory::createConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1OutputPort.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>input_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a connection from a local output_port to a local or remote input_port. </p>
<p>This function contains all logic to decide on how connections must be created to local or remote input ports.</p>
<p>In order to set up out-of-band communication between input_port and output_port, use a different transport number in the policy parameter than the transport of the input port. </p>

<p>Definition at line <a class="el" href="ConnFactory_8hpp_source.html#l00471">471</a> of file <a class="el" href="ConnFactory_8hpp_source.html">ConnFactory.hpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00216">RTT::ConnPolicy::buffer_policy</a>, <a class="el" href="PortInterface_8cpp_source.html#l00067">RTT::base::PortInterface::connectedTo()</a>, <a class="el" href="OutputPort_8hpp_source.html#l00173">RTT::OutputPort&lt; T &gt;::getLastWrittenValue()</a>, <a class="el" href="PortInterface_8hpp_source.html#l00079">RTT::base::PortInterface::getName()</a>, <a class="el" href="PortInterface_8cpp_source.html#l00071">RTT::base::PortInterface::isLocal()</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00238">RTT::ConnPolicy::transport</a>.</p>

<p>Referenced by <a class="el" href="OutputPort_8hpp_source.html#l00304">RTT::OutputPort&lt; T &gt;::createConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="a760585ae988fd85116fcbd58db8a3b77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool RTT::internal::ConnFactory::createOutOfBandConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1OutputPort.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1InputPort.html">InputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This code is for setting up an in-process out-of-band connection. </p>
<p>This means that both input and output port are present in the same process. This function is used when the policy dictates a transport protocol, but both ports are local. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the out-of-band connection was successfully setup. </dd></dl>

<p>Definition at line <a class="el" href="ConnFactory_8hpp_source.html#l00589">589</a> of file <a class="el" href="ConnFactory_8hpp_source.html">ConnFactory.hpp</a>.</p>

<p>References <a class="el" href="OutputPort_8hpp_source.html#l00173">RTT::OutputPort&lt; T &gt;::getLastWrittenValue()</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00256">RTT::ConnPolicy::name_id</a>.</p>

</div>
</div>
<a class="anchor" id="a3442dff9c8e0cab5858a32ec0cc4f7e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool RTT::internal::ConnFactory::createStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1OutputPort.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates, attaches and checks an outbound stream to an Output port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_port</td><td>The port to connect the stream to. </td></tr>
    <tr><td class="paramname">policy</td><td>The policy dictating which transport to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the stream could be created and connected to output_port. </dd></dl>

<p>Definition at line <a class="el" href="ConnFactory_8hpp_source.html#l00545">545</a> of file <a class="el" href="ConnFactory_8hpp_source.html">ConnFactory.hpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00256">RTT::ConnPolicy::name_id</a>.</p>

<p>Referenced by <a class="el" href="InputPort_8hpp_source.html#l00205">RTT::InputPort&lt; T &gt;::createStream()</a>, and <a class="el" href="OutputPort_8hpp_source.html#l00309">RTT::OutputPort&lt; T &gt;::createStream()</a>.</p>

</div>
</div>
<a class="anchor" id="aa21f07d3aea4446b0c602d7f20858e46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool RTT::internal::ConnFactory::createStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1InputPort.html">InputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates, attaches and checks an inbound stream to an Input port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_port</td><td>The port to connect the stream to. </td></tr>
    <tr><td class="paramname">policy</td><td>The policy dictating which transport to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the stream could be created and connected to input_port. </dd></dl>

<p>Definition at line <a class="el" href="ConnFactory_8hpp_source.html#l00562">562</a> of file <a class="el" href="ConnFactory_8hpp_source.html">ConnFactory.hpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00256">RTT::ConnPolicy::name_id</a>.</p>

</div>
</div>
<a class="anchor" id="aea2b3e530474507e06a83d75bedd61ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ConnFactory::findSharedConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html">base::OutputPortInterface</a> *&#160;</td>
          <td class="paramname"><em>output_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> *&#160;</td>
          <td class="paramname"><em>input_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> const &amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SharedConnectionBase::shared_ptr &amp;&#160;</td>
          <td class="paramname"><em>shared_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find an existing or creates a new shared connection object for the given output port, input port and connection policy. </p>
<p>If an existing shared connection has been found, also checks if it matches the given policy and output an error otherwise. The input and output port arguments are optional and can be NULL pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_port</td><td>The output port to connect the channel's input end to (optional). </td></tr>
    <tr><td class="paramname">input_port</td><td>The output port to connect the channel's output end to (optional). </td></tr>
    <tr><td class="paramname">policy</td><td>Describes the kind of storage requested by the user </td></tr>
    <tr><td class="paramname">shared_connection</td><td>A reference to a <a class="el" href="classRTT_1_1internal_1_1SharedConnectionBase.html" title="Base class for shared connection elements. ">SharedConnectionBase</a> pointer that will point to the found instance or an empty pointer, if either no connection has been found or the found connection was invalid for the given ports and policy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an exiting <a class="el" href="classRTT_1_1internal_1_1SharedConnectionBase.html" title="Base class for shared connection elements. ">SharedConnectionBase</a> instance could be found. </dd></dl>

<p>Definition at line <a class="el" href="ConnFactory_8cpp_source.html#l00262">262</a> of file <a class="el" href="ConnFactory_8cpp_source.html">ConnFactory.cpp</a>.</p>

<p>References <a class="el" href="PortInterface_8hpp_source.html#l00079">RTT::base::PortInterface::getName()</a>, <a class="el" href="PortInterface_8cpp_source.html#l00109">RTT::base::PortInterface::getSharedConnection()</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00256">RTT::ConnPolicy::name_id</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rtt/internal/<a class="el" href="ConnFactory_8hpp_source.html">ConnFactory.hpp</a></li>
<li>rtt/internal/<a class="el" href="ConnFactory_8cpp_source.html">ConnFactory.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 10 2017 22:54:01 for Orocos Real-Time Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
