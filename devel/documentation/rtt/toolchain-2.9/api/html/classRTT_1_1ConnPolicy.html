<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Orocos Real-Time Toolkit: RTT::ConnPolicy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a></li><li class="navelem"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classRTT_1_1ConnPolicy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RTT::ConnPolicy Class Reference<div class="ingroups"><a class="el" href="group__Ports.html">Data Flow Ports</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A connection policy object describes how a given connection should behave.  
 <a href="classRTT_1_1ConnPolicy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ConnPolicy_8hpp_source.html">rtt/ConnPolicy.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a508c0b397027e4d238726876a8109c98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a508c0b397027e4d238726876a8109c98"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a508c0b397027e4d238726876a8109c98">ConnPolicy</a> ()</td></tr>
<tr class="memdesc:a508c0b397027e4d238726876a8109c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> instance based on the current default settings as returned by <a class="el" href="classRTT_1_1ConnPolicy.html#aa08426926b4f150a6871de3a98672ab7" title="Returns the process-wide default ConnPolicy that serves as a template for new ConnPolicy instances...">ConnPolicy::Default()</a>. <br/></td></tr>
<tr class="separator:a508c0b397027e4d238726876a8109c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d530653f7af6434a806a74f4a091abc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a7d530653f7af6434a806a74f4a091abc">ConnPolicy</a> (int <a class="el" href="classRTT_1_1ConnPolicy.html#a3b2c137e8a91f64c9bbbf90d2bf1065f">type</a>)</td></tr>
<tr class="memdesc:a7d530653f7af6434a806a74f4a091abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> instance based on the current default settings as returned by <a class="el" href="classRTT_1_1ConnPolicy.html#aa08426926b4f150a6871de3a98672ab7" title="Returns the process-wide default ConnPolicy that serves as a template for new ConnPolicy instances...">ConnPolicy::Default()</a>, but overrides the type.  <a href="#a7d530653f7af6434a806a74f4a091abc">More...</a><br/></td></tr>
<tr class="separator:a7d530653f7af6434a806a74f4a091abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d02deb43ce98ce52f5633c488e01f6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a9d02deb43ce98ce52f5633c488e01f6f">ConnPolicy</a> (int <a class="el" href="classRTT_1_1ConnPolicy.html#a3b2c137e8a91f64c9bbbf90d2bf1065f">type</a>, int <a class="el" href="classRTT_1_1ConnPolicy.html#a81987dec8fc26fd596223728663f9a03">lock_policy</a>)</td></tr>
<tr class="memdesc:a9d02deb43ce98ce52f5633c488e01f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> instance based on the current default settings as returned by <a class="el" href="classRTT_1_1ConnPolicy.html#aa08426926b4f150a6871de3a98672ab7" title="Returns the process-wide default ConnPolicy that serves as a template for new ConnPolicy instances...">ConnPolicy::Default()</a>, but overrides the type and lock_policy.  <a href="#a9d02deb43ce98ce52f5633c488e01f6f">More...</a><br/></td></tr>
<tr class="separator:a9d02deb43ce98ce52f5633c488e01f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa08426926b4f150a6871de3a98672ab7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#aa08426926b4f150a6871de3a98672ab7">Default</a> ()</td></tr>
<tr class="memdesc:aa08426926b4f150a6871de3a98672ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the process-wide default <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> that serves as a template for new <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> instances.  <a href="#aa08426926b4f150a6871de3a98672ab7">More...</a><br/></td></tr>
<tr class="separator:aa08426926b4f150a6871de3a98672ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdc5cde7d480646930f53f3ddae45a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a3cdc5cde7d480646930f53f3ddae45a4">buffer</a> (int <a class="el" href="classRTT_1_1ConnPolicy.html#a86aca1d2334c9d0cdd59dbb25a2d8d8c">size</a>, int <a class="el" href="classRTT_1_1ConnPolicy.html#a81987dec8fc26fd596223728663f9a03">lock_policy</a>=LOCK_FREE, bool init_connection=false, bool <a class="el" href="classRTT_1_1ConnPolicy.html#adbb615689773110a6c329c8b631fa1ee">pull</a>=false)</td></tr>
<tr class="memdesc:a3cdc5cde7d480646930f53f3ddae45a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a policy for a (lock-free) fifo buffer connection of a given size.  <a href="#a3cdc5cde7d480646930f53f3ddae45a4">More...</a><br/></td></tr>
<tr class="separator:a3cdc5cde7d480646930f53f3ddae45a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e226c7c31f4032d4bd00387a5da6189"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a7e226c7c31f4032d4bd00387a5da6189">circularBuffer</a> (int <a class="el" href="classRTT_1_1ConnPolicy.html#a86aca1d2334c9d0cdd59dbb25a2d8d8c">size</a>, int <a class="el" href="classRTT_1_1ConnPolicy.html#a81987dec8fc26fd596223728663f9a03">lock_policy</a>=LOCK_FREE, bool init_connection=false, bool <a class="el" href="classRTT_1_1ConnPolicy.html#adbb615689773110a6c329c8b631fa1ee">pull</a>=false)</td></tr>
<tr class="memdesc:a7e226c7c31f4032d4bd00387a5da6189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a policy for a (lock-free) <b>circular</b> fifo buffer connection of a given size.  <a href="#a7e226c7c31f4032d4bd00387a5da6189">More...</a><br/></td></tr>
<tr class="separator:a7e226c7c31f4032d4bd00387a5da6189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd35a8498d2e4e9d2f0ed2c15651edd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#abcd35a8498d2e4e9d2f0ed2c15651edd">data</a> (int <a class="el" href="classRTT_1_1ConnPolicy.html#a81987dec8fc26fd596223728663f9a03">lock_policy</a>=LOCK_FREE, bool init_connection=true, bool <a class="el" href="classRTT_1_1ConnPolicy.html#adbb615689773110a6c329c8b631fa1ee">pull</a>=false)</td></tr>
<tr class="memdesc:abcd35a8498d2e4e9d2f0ed2c15651edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a policy for a (lock-free) shared data connection of a given size.  <a href="#abcd35a8498d2e4e9d2f0ed2c15651edd">More...</a><br/></td></tr>
<tr class="separator:abcd35a8498d2e4e9d2f0ed2c15651edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3b2c137e8a91f64c9bbbf90d2bf1065f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b2c137e8a91f64c9bbbf90d2bf1065f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a3b2c137e8a91f64c9bbbf90d2bf1065f">type</a></td></tr>
<tr class="memdesc:a3b2c137e8a91f64c9bbbf90d2bf1065f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DATA, BUFFER or CIRCULAR_BUFFER. <br/></td></tr>
<tr class="separator:a3b2c137e8a91f64c9bbbf90d2bf1065f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aca1d2334c9d0cdd59dbb25a2d8d8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86aca1d2334c9d0cdd59dbb25a2d8d8c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a86aca1d2334c9d0cdd59dbb25a2d8d8c">size</a></td></tr>
<tr class="memdesc:a86aca1d2334c9d0cdd59dbb25a2d8d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the connection is a buffered connection, the size of the buffer. <br/></td></tr>
<tr class="separator:a86aca1d2334c9d0cdd59dbb25a2d8d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81987dec8fc26fd596223728663f9a03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81987dec8fc26fd596223728663f9a03"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a81987dec8fc26fd596223728663f9a03">lock_policy</a></td></tr>
<tr class="memdesc:a81987dec8fc26fd596223728663f9a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the locking policy on the connection. <br/></td></tr>
<tr class="separator:a81987dec8fc26fd596223728663f9a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da839ba68d6ff35ddc44171562ed356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a5da839ba68d6ff35ddc44171562ed356">init</a></td></tr>
<tr class="memdesc:a5da839ba68d6ff35ddc44171562ed356"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, one should initialize the connection's value with the last value written on the writer port.  <a href="#a5da839ba68d6ff35ddc44171562ed356">More...</a><br/></td></tr>
<tr class="separator:a5da839ba68d6ff35ddc44171562ed356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb615689773110a6c329c8b631fa1ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#adbb615689773110a6c329c8b631fa1ee">pull</a></td></tr>
<tr class="memdesc:adbb615689773110a6c329c8b631fa1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, then the sink will have to pull data.  <a href="#adbb615689773110a6c329c8b631fa1ee">More...</a><br/></td></tr>
<tr class="separator:adbb615689773110a6c329c8b631fa1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c005b8ed967bd83ba1392e71e1234b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#aa2c005b8ed967bd83ba1392e71e1234b">buffer_policy</a></td></tr>
<tr class="memdesc:aa2c005b8ed967bd83ba1392e71e1234b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The policy on how buffer elements will be installed for this connection, which influences the behavior of reads and writes if the port has muliple connections.  <a href="#aa2c005b8ed967bd83ba1392e71e1234b">More...</a><br/></td></tr>
<tr class="separator:aa2c005b8ed967bd83ba1392e71e1234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70f15548f9b856b0a4dbd8e09bab102"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#ac70f15548f9b856b0a4dbd8e09bab102">max_threads</a></td></tr>
<tr class="memdesc:ac70f15548f9b856b0a4dbd8e09bab102"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of threads that will access the connection data or buffer object.  <a href="#ac70f15548f9b856b0a4dbd8e09bab102">More...</a><br/></td></tr>
<tr class="separator:ac70f15548f9b856b0a4dbd8e09bab102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9cce505121d17b64ee2b9da3bd5580"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a9a9cce505121d17b64ee2b9da3bd5580">mandatory</a></td></tr>
<tr class="memdesc:a9a9cce505121d17b64ee2b9da3bd5580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the connection described by this connection policy is mandatory, which means that write operations will fail if the connection could not be served, e.g.  <a href="#a9a9cce505121d17b64ee2b9da3bd5580">More...</a><br/></td></tr>
<tr class="separator:a9a9cce505121d17b64ee2b9da3bd5580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6dc850be01332f49787012ab499a9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a3e6dc850be01332f49787012ab499a9d">transport</a></td></tr>
<tr class="memdesc:a3e6dc850be01332f49787012ab499a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The prefered transport used.  <a href="#a3e6dc850be01332f49787012ab499a9d">More...</a><br/></td></tr>
<tr class="separator:a3e6dc850be01332f49787012ab499a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4b2c1bc23e0b582bc3b42689c49a67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a6b4b2c1bc23e0b582bc3b42689c49a67">data_size</a></td></tr>
<tr class="memdesc:a6b4b2c1bc23e0b582bc3b42689c49a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suggest the payload size of the data sent over this channel.  <a href="#a6b4b2c1bc23e0b582bc3b42689c49a67">More...</a><br/></td></tr>
<tr class="separator:a6b4b2c1bc23e0b582bc3b42689c49a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914fd52d0a23a50c3c3f19919c663737"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ConnPolicy.html#a914fd52d0a23a50c3c3f19919c663737">name_id</a></td></tr>
<tr class="memdesc:a914fd52d0a23a50c3c3f19919c663737"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of this connection.  <a href="#a914fd52d0a23a50c3c3f19919c663737">More...</a><br/></td></tr>
<tr class="separator:a914fd52d0a23a50c3c3f19919c663737"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a726a81c40d7cc97b589d96ed5f1f5547"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a726a81c40d7cc97b589d96ed5f1f5547"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>UNBUFFERED</b> = -1</td></tr>
<tr class="separator:a726a81c40d7cc97b589d96ed5f1f5547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d2a18c4366b19f6734fbe57857c857"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86d2a18c4366b19f6734fbe57857c857"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>DATA</b> = 0</td></tr>
<tr class="separator:a86d2a18c4366b19f6734fbe57857c857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d871403e8e20e181a7903a64205ba38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d871403e8e20e181a7903a64205ba38"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER</b> = 1</td></tr>
<tr class="separator:a1d871403e8e20e181a7903a64205ba38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2bd5850c74d02bc081221c7446a245"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd2bd5850c74d02bc081221c7446a245"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>CIRCULAR_BUFFER</b> = 2</td></tr>
<tr class="separator:abd2bd5850c74d02bc081221c7446a245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910ed6f89c5b02dc9c798f6f64637e2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a910ed6f89c5b02dc9c798f6f64637e2b"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>UNSYNC</b> = 0</td></tr>
<tr class="separator:a910ed6f89c5b02dc9c798f6f64637e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573b7f8f3261cf88baa33bc8d696b41b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a573b7f8f3261cf88baa33bc8d696b41b"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>LOCKED</b> = 1</td></tr>
<tr class="separator:a573b7f8f3261cf88baa33bc8d696b41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9308ca50d496dde2aee612494ae755a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9308ca50d496dde2aee612494ae755a"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>LOCK_FREE</b> = 2</td></tr>
<tr class="separator:ad9308ca50d496dde2aee612494ae755a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94b40d3dffe447677b02117696549fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af94b40d3dffe447677b02117696549fa"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>PUSH</b> = false</td></tr>
<tr class="separator:af94b40d3dffe447677b02117696549fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb943667fbfe3fab9ec70ce2668b542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbb943667fbfe3fab9ec70ce2668b542"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>PULL</b> = true</td></tr>
<tr class="separator:afbb943667fbfe3fab9ec70ce2668b542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A connection policy object describes how a given connection should behave. </p>
<p>Various parameters are available:</p>
<ul>
<li>
<p class="startli">the connection type: DATA, BUFFER, CIRCULAR_BUFFER or UNBUFFERED. On a data connection, the reader will have only access to the last written value. On a buffered connection, a <em>size</em> number of elements can be stored until the reader reads them. BUFFER drops newer samples on full, CIRCULAR_BUFFER drops older samples on full. UNBUFFERED is only valid for output streaming connections.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">the locking policy: LOCKED, LOCK_FREE or UNSYNC. This defines how locking is done in the connection. For now, only three policies are available. LOCKED uses mutexes, LOCK_FREE uses a lock free method and UNSYNC means there's no synchronisation at all (not thread safe). The latter should be used only when there is no contention (simultaneous write-read).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">if, upon connection, the last value that has been written on the writer end should be written on the connection as well to initialize it. This flag has an effect only if the writer has keepsLastWrittenValue() set to true (see <a class="el" href="classRTT_1_1base_1_1OutputPortInterface.html#a385a6ad5d277e736bbda2ce3ae3e4173" title="Change the setting for keeping the last written value. ">OutputPortInterface::keepLastWrittenValue()</a>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">if the data is pushed or pulled on the connection. This has an effect only on multi-process communication. In the pushed case (the default), new data is actively pushed to the reader's process. In the pulled case, data must be requested by the reader.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">the buffer policy, which controls how multiple connections to the same input or output port are handled in case of concurrent or subsequent read and write operations. See <a class="el" href="group__Ports.html#gadc680c5e9ed12ee0889933483c89b7ea">BufferPolicy</a> to see all available options. Not all combinations of buffer policies and the pull flag are valid and non-standard transports can have additional restrictions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">if the connection is mandatory. Mandatory connections will let the write() call fail if the new sample cannot be successfully written. Default connections are not mandatory.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">the transport type. Can be used to force a certain kind of transports. The number is a <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute. ">RTT</a> transport id. When the transport type is zero, local in-process communication is used, unless one of the ports is remote. If the transport type deviates from the default remote transport of one of the ports, an out-of-band transport is setup using that type.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">the data size. Some protocols require a hint on big the data will be, especially if the data is dynamically sized (like std::vector&lt;double&gt;). If you leave this empty (recommended), the protocol will try to guess it. The unit of data size is protocol dependent.</p>
<p class="endli"></p>
</li>
<li>
the name of the connection. Can be used to coordinate out of band transport such that they can find each other by name. In practice, the name contains a port number or file descriptor to be opened. You only need to provide a name_id if you're using out-of-band transports without supervisor, for example, when using MQueues without Corba. </li>
</ul>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00107">107</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7d530653f7af6434a806a74f4a091abc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RTT::ConnPolicy::ConnPolicy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> instance based on the current default settings as returned by <a class="el" href="classRTT_1_1ConnPolicy.html#aa08426926b4f150a6871de3a98672ab7" title="Returns the process-wide default ConnPolicy that serves as a template for new ConnPolicy instances...">ConnPolicy::Default()</a>, but overrides the type. </p>
<p>You should not use this contructor anymore and prefer the static methods <a class="el" href="classRTT_1_1ConnPolicy.html#abcd35a8498d2e4e9d2f0ed2c15651edd">ConnPolicy::data()</a>, <a class="el" href="classRTT_1_1ConnPolicy.html#a3cdc5cde7d480646930f53f3ddae45a4">ConnPolicy::buffer()</a>, etc. instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="ConnPolicy_8cpp_source.html#l00122">122</a> of file <a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d02deb43ce98ce52f5633c488e01f6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RTT::ConnPolicy::ConnPolicy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> instance based on the current default settings as returned by <a class="el" href="classRTT_1_1ConnPolicy.html#aa08426926b4f150a6871de3a98672ab7" title="Returns the process-wide default ConnPolicy that serves as a template for new ConnPolicy instances...">ConnPolicy::Default()</a>, but overrides the type and lock_policy. </p>
<p>You should not use this contructor anymore and prefer the static methods <a class="el" href="classRTT_1_1ConnPolicy.html#abcd35a8498d2e4e9d2f0ed2c15651edd">ConnPolicy::data()</a>, <a class="el" href="classRTT_1_1ConnPolicy.html#a3cdc5cde7d480646930f53f3ddae45a4">ConnPolicy::buffer()</a>, etc. instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
    <tr><td class="paramname">lock_policy</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="ConnPolicy_8cpp_source.html#l00135">135</a> of file <a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3cdc5cde7d480646930f53f3ddae45a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> RTT::ConnPolicy::buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_policy</em> = <code>LOCK_FREE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_connection</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pull</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a policy for a (lock-free) fifo buffer connection of a given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the buffer in this connection </td></tr>
    <tr><td class="paramname">lock_policy</td><td>The locking policy </td></tr>
    <tr><td class="paramname">init_connection</td><td>If an initial sample should be pushed into the buffer upon creation. </td></tr>
    <tr><td class="paramname">pull</td><td>In inter-process cases, should the consumer pull itself ? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified policy. </dd></dl>

<p>Definition at line <a class="el" href="ConnPolicy_8cpp_source.html#l00077">77</a> of file <a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00203">init</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00196">lock_policy</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00209">pull</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00193">size</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00190">type</a>.</p>

<p>Referenced by <a class="el" href="OutputPortInterface_8cpp_source.html#l00087">RTT::base::OutputPortInterface::createBufferConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e226c7c31f4032d4bd00387a5da6189"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> RTT::ConnPolicy::circularBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_policy</em> = <code>LOCK_FREE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_connection</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pull</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a policy for a (lock-free) <b>circular</b> fifo buffer connection of a given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the buffer in this connection </td></tr>
    <tr><td class="paramname">lock_policy</td><td>The locking policy </td></tr>
    <tr><td class="paramname">init_connection</td><td>If an initial sample should be pushed into the buffer upon creation. </td></tr>
    <tr><td class="paramname">pull</td><td>In inter-process cases, should the consumer pull itself ? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified policy. </dd></dl>

<p>Definition at line <a class="el" href="ConnPolicy_8cpp_source.html#l00088">88</a> of file <a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00203">init</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00196">lock_policy</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00209">pull</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00193">size</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00190">type</a>.</p>

</div>
</div>
<a class="anchor" id="abcd35a8498d2e4e9d2f0ed2c15651edd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> RTT::ConnPolicy::data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_policy</em> = <code>LOCK_FREE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_connection</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pull</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a policy for a (lock-free) shared data connection of a given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_policy</td><td>The locking policy </td></tr>
    <tr><td class="paramname">init_connection</td><td>If the data object should be initialised with the last value of the <a class="el" href="classRTT_1_1OutputPort.html" title="A component&#39;s data output port. ">OutputPort</a> upon creation. </td></tr>
    <tr><td class="paramname">pull</td><td>In inter-process cases, should the consumer pull data itself ? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified policy. </dd></dl>

<p>Definition at line <a class="el" href="ConnPolicy_8cpp_source.html#l00099">99</a> of file <a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8hpp_source.html#l00203">init</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00196">lock_policy</a>, <a class="el" href="ConnPolicy_8hpp_source.html#l00209">pull</a>, and <a class="el" href="ConnPolicy_8hpp_source.html#l00190">type</a>.</p>

<p>Referenced by <a class="el" href="OutputPortInterface_8cpp_source.html#l00084">RTT::base::OutputPortInterface::createDataConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="aa08426926b4f150a6871de3a98672ab7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ConnPolicy.html">ConnPolicy</a> &amp; RTT::ConnPolicy::Default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the process-wide default <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> that serves as a template for new <a class="el" href="classRTT_1_1ConnPolicy.html" title="A connection policy object describes how a given connection should behave. ">ConnPolicy</a> instances. </p>
<p>This method returns a non-const reference and you can change the defaults. This is not thread-safe and should only be done very early in the deployment phase, before the first component is loaded and before connecting ports. </p>

<p>Definition at line <a class="el" href="ConnPolicy_8cpp_source.html#l00071">71</a> of file <a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a>.</p>

<p>References <a class="el" href="ConnPolicy_8cpp_source.html#l00109">ConnPolicy()</a>.</p>

<p>Referenced by <a class="el" href="RealTimeTypekitGlobals_8cpp_source.html#l00053">RTT::types::RealTimeTypekitPlugin::loadGlobals()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa2c005b8ed967bd83ba1392e71e1234b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTT::ConnPolicy::buffer_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The policy on how buffer elements will be installed for this connection, which influences the behavior of reads and writes if the port has muliple connections. </p>
<p>See <a class="el" href="group__Ports.html#gadc680c5e9ed12ee0889933483c89b7ea">BufferPolicy</a> enum for possible options. </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00216">216</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="ConnFactory_8hpp_source.html#l00224">RTT::internal::ConnFactory::buildChannelInput()</a>, <a class="el" href="ConnFactory_8hpp_source.html#l00310">RTT::internal::ConnFactory::buildChannelOutput()</a>, <a class="el" href="ConnFactory_8hpp_source.html#l00157">RTT::internal::ConnFactory::buildDataStorage()</a>, <a class="el" href="ConnFactory_8hpp_source.html#l00471">RTT::internal::ConnFactory::createConnection()</a>, and <a class="el" href="ChannelBufferElement_8hpp_source.html#l00109">RTT::internal::ChannelBufferElement&lt; T &gt;::read()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b4b2c1bc23e0b582bc3b42689c49a67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RTT::ConnPolicy::data_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suggest the payload size of the data sent over this channel. </p>
<p>Connections can use this value to optimize transmission or prepare the communication channel for real-time communication. This value might be overruled by the transport protocol if it can make a better guess. The interpretation of data_size is transport specific. It may be bytes, it may be something else. Leave this value set to zero, unless the transport documents otherwise. </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00248">248</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="RemotePorts_8cpp_source.html#l00122">RTT::corba::RemoteInputPort::buildRemoteChannelOutput()</a>, <a class="el" href="RemotePorts_8cpp_source.html#l00275">RTT::corba::RemoteOutputPort::createConnection()</a>, and <a class="el" href="RemotePorts_8cpp_source.html#l00200">RTT::corba::RemoteInputPort::createConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="a5da839ba68d6ff35ddc44171562ed356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConnPolicy::init</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, one should initialize the connection's value with the last value written on the writer port. </p>
<p>This is only possible if the writer port has the keepsLastWrittenValue() flag set (i.e. if it remembers what was the last written value). </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00203">203</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="ConnPolicy_8cpp_source.html#l00077">buffer()</a>, <a class="el" href="ConnPolicy_8cpp_source.html#l00088">circularBuffer()</a>, and <a class="el" href="ConnPolicy_8cpp_source.html#l00099">data()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a9cce505121d17b64ee2b9da3bd5580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConnPolicy::mandatory</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the connection described by this connection policy is mandatory, which means that write operations will fail if the connection could not be served, e.g. </p>
<p>due to a full input buffer or because of a broken remote connection. By default, all connections are mandatory. </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00232">232</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="RemotePorts_8cpp_source.html#l00122">RTT::corba::RemoteInputPort::buildRemoteChannelOutput()</a>, and <a class="el" href="ConnFactory_8hpp_source.html#l00405">RTT::internal::ConnFactory::buildSharedConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="ac70f15548f9b856b0a4dbd8e09bab102"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTT::ConnPolicy::max_threads</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of threads that will access the connection data or buffer object. </p>
<p>This only needs to be specified for lock-free data structures. If 0, the number of threads will be determined by a simple heuristic depending on the read and write policies of the connection. </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00224">224</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a914fd52d0a23a50c3c3f19919c663737"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string RTT::ConnPolicy::name_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of this connection. </p>
<p>May be used by transports to define a 'topic' or lookup name to connect two data streams. If you leave this empty (recommended), the protocol will choose an appropriate name itself. Only specify a name to work around name clashes or if the transport protocol documents to do so. </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00256">256</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="RemotePorts_8cpp_source.html#l00122">RTT::corba::RemoteInputPort::buildRemoteChannelOutput()</a>, <a class="el" href="RemotePorts_8cpp_source.html#l00275">RTT::corba::RemoteOutputPort::createConnection()</a>, <a class="el" href="RemotePorts_8cpp_source.html#l00200">RTT::corba::RemoteInputPort::createConnection()</a>, <a class="el" href="ConnFactory_8hpp_source.html#l00589">RTT::internal::ConnFactory::createOutOfBandConnection()</a>, <a class="el" href="ConnFactory_8hpp_source.html#l00545">RTT::internal::ConnFactory::createStream()</a>, and <a class="el" href="ConnFactory_8cpp_source.html#l00262">RTT::internal::ConnFactory::findSharedConnection()</a>.</p>

</div>
</div>
<a class="anchor" id="adbb615689773110a6c329c8b631fa1ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ConnPolicy::pull</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, then the sink will have to pull data. </p>
<p>Otherwise, it is pushed from the source. In both cases, the reader side is notified that new data is available by <a class="el" href="classRTT_1_1base_1_1ChannelElementBase.html#aa985c67248dbe492db1f53b5b7c54c21" title="Signals that there is new data available on this channel By default, the channel element forwards the...">base::ChannelElementBase::signal()</a> </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00209">209</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="ConnPolicy_8cpp_source.html#l00077">buffer()</a>, <a class="el" href="ConnFactory_8hpp_source.html#l00224">RTT::internal::ConnFactory::buildChannelInput()</a>, <a class="el" href="ConnFactory_8hpp_source.html#l00310">RTT::internal::ConnFactory::buildChannelOutput()</a>, <a class="el" href="RemotePorts_8cpp_source.html#l00122">RTT::corba::RemoteInputPort::buildRemoteChannelOutput()</a>, <a class="el" href="ConnPolicy_8cpp_source.html#l00088">circularBuffer()</a>, <a class="el" href="ConnPolicy_8cpp_source.html#l00099">data()</a>, and <a class="el" href="RemoteChannelElement_8hpp_source.html#l00138">RTT::corba::RemoteChannelElement&lt; T &gt;::transferSamples()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e6dc850be01332f49787012ab499a9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTT::ConnPolicy::transport</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The prefered transport used. </p>
<p>0 is local (in process), a higher number is used for inter-process or networked communication transports. </p>

<p>Definition at line <a class="el" href="ConnPolicy_8hpp_source.html#l00238">238</a> of file <a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a>.</p>

<p>Referenced by <a class="el" href="RemotePorts_8cpp_source.html#l00122">RTT::corba::RemoteInputPort::buildRemoteChannelOutput()</a>, and <a class="el" href="ConnFactory_8hpp_source.html#l00471">RTT::internal::ConnFactory::createConnection()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rtt/<a class="el" href="ConnPolicy_8hpp_source.html">ConnPolicy.hpp</a></li>
<li>rtt/<a class="el" href="ConnPolicy_8cpp_source.html">ConnPolicy.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 5 2017 16:25:31 for Orocos Real-Time Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
