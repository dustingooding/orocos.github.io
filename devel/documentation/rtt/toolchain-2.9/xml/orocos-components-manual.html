<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Orocos Component Builder's Manual</title><link rel="stylesheet" type="text/css" href="orocos-html.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><meta name="description" content="This document gives an introduction to building your own components for the Orocos ( Open RObot COntrol Software ) project." /></head><body><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="idp46525568120160"></a>
      The Orocos Component Builder's Manual
    </h1></div><div><h2 class="subtitle"><span class="emphasis"><em>Open RObot COntrol Software</em></span>
    </h2></div><div><h2 class="subtitle">2.9.0</h2></div><div><p class="copyright">Copyright © 2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014 Peter Soetens</p></div><div><p class="copyright">Copyright © 2006,2007,2008 FMTC</p></div><div><div class="legalnotice"><a id="idp46525571648768"></a><p>
	Orocos Real-Time Toolkit Version 2.9.0.
      </p><p>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<a class="ulink" href="http://www.fsf.org/copyleft/fdl.html" target="_top">http://www.fsf.org/copyleft/fdl.html</a>.
      </p></div></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><p>
	This document gives an introduction to building your own
	components for the <a class="ulink" href="http://www.orocos.org" target="_top"><acronym class="acronym">Orocos</acronym></a> <span class="emphasis"><em> ( Open
	RObot COntrol Software ) </em></span> project.
      </p></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="#idp46525571042304">1. How to Read this Manual</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525571660272">1. Component Interfaces</a></span></dt><dt><span class="section"><a href="#idp46525568126608">2. Component Implementation</a></span></dt><dt><span class="section"><a href="#idp46525570304752">3. Orocos Toolchain Overview</a></span></dt></dl></dd><dt><span class="chapter"><a href="#orocos-taskcontext">2. Setting up the Component Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#task-context-intro">1. Introduction</a></span></dt><dt><span class="section"><a href="#idp46525576967360">2. Hello World !</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525576871216">2.1. Using the Deployer</a></span></dt><dt><span class="section"><a href="#idp46525574748864">2.2. Starting your First Application</a></span></dt><dt><span class="section"><a href="#idp46525568015376">2.3. Displaying a TaskContext</a></span></dt><dt><span class="section"><a href="#idp46525575484160">2.4. Listing the Interface</a></span></dt><dt><span class="section"><a href="#idp46525575491744">2.5. Calling an Operation</a></span></dt><dt><span class="section"><a href="#idp46525575496176">2.6. Sending a Operation</a></span></dt><dt><span class="section"><a href="#idp46525575504240">2.7. Changing Values</a></span></dt><dt><span class="section"><a href="#idp46525575511648">2.8. Reading and Writing Ports</a></span></dt><dt><span class="section"><a href="#idp46525575517760">2.9. Last Words</a></span></dt></dl></dd><dt><span class="section"><a href="#basic-task">3. Creating a Basic Component</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525575553376">3.1. Task Application Code</a></span></dt><dt><span class="section"><a href="#idp46525575582608">3.2. Starting a Component</a></span></dt><dt><span class="section"><a href="#task-ports">3.3. Data Flow Ports</a></span></dt><dt><span class="section"><a href="#task-operations">3.4. The OperationCaller/Operation Interface</a></span></dt><dt><span class="section"><a href="#task-attr-rep">3.5. The Attributes and Properties Interface</a></span></dt><dt><span class="section"><a href="#idp46525578970240">3.6. A TaskContext's Error states</a></span></dt></dl></dd><dt><span class="section"><a href="#connect-tasks">4. Connecting Services</a></span></dt><dd><dl><dt><span class="section"><a href="#connect-peers">4.1. Connecting Peer Components</a></span></dt><dt><span class="section"><a href="#setup-data-flow">4.2. Setting up the Data Flow</a></span></dt><dt><span class="section"><a href="#idp46525579035120">4.3. Disconnecting Tasks</a></span></dt></dl></dd><dt><span class="section"><a href="#task-services">5. Providing and Requiring Services</a></span></dt><dt><span class="section"><a href="#run-tasks">6. Using Tasks</a></span></dt><dd><dl><dt><span class="section"><a href="#task-property-config">6.1. Task Property Configuration and XML format</a></span></dt><dt><span class="section"><a href="#idp46525579082448">6.2. Task Scripts</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525579104384">7. Deploying Components</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525579106128">7.1. Overview</a></span></dt><dt><span class="section"><a href="#idp46525579117984">7.2. Embedded TaskCore Deployment</a></span></dt><dt><span class="section"><a href="#idp46525579122784">7.3. Embedded TaskContext Deployment: C++ Interface</a></span></dt><dt><span class="section"><a href="#idp46525579131104">7.4. Full TaskContext Deployment: Dynamic Interface</a></span></dt><dt><span class="section"><a href="#idp46525579132496">7.5. Putting it together</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525579139680">8. Advanced Techniques</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525579145984">8.1. Polymorphism : Task Interfaces</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#orocos-scripting">3. Orocos RTT Scripting Reference</a></span></dt><dd><dl><dt><span class="section"><a href="#intro">1. Introduction</a></span></dt><dt><span class="section"><a href="#program-syntax-general-concepts">2. General Scripting Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#program-syntax-comments">2.1. Comments</a></span></dt><dt><span class="section"><a href="#program-syntax-identifiers">2.2. Identifiers</a></span></dt><dt><span class="section"><a href="#program-syntax-expressions">2.3. Expressions</a></span></dt><dt><span class="section"><a href="#idp46525581677824">2.4. Parsing and Loading Programs</a></span></dt></dl></dd><dt><span class="section"><a href="#program-syntax">3. Orocos Program Scripts</a></span></dt><dd><dl><dt><span class="section"><a href="#program-semantics">3.1. Program Execution Semantics</a></span></dt><dt><span class="section"><a href="#program-syntax-specifics">3.2. Program Syntax</a></span></dt><dt><span class="section"><a href="#idp46525581730480">3.3. Setting Task Attributes and Properties</a></span></dt><dt><span class="section"><a href="#idp46525581733168">3.4. <span class="symbol">function</span></a></span></dt><dt><span class="section"><a href="#idp46525581741024">3.5. Calling functions</a></span></dt><dt><span class="section"><a href="#idp46525581745056">3.6. <span class="symbol">return</span></a></span></dt><dt><span class="section"><a href="#idp46525581749264">3.7. Waiting : The 'yield' statement</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525581751888">4. Starting and Stopping Programs from scripts</a></span></dt><dt><span class="section"><a href="#idp46525581756608">5. Orocos State Descriptions : The Real-Time State Machine</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525581757312">5.1. Introduction</a></span></dt><dt><span class="section"><a href="#idp46525581759840">5.2. StateMachine Mechanism</a></span></dt><dt><span class="section"><a href="#idp46525581788176">5.3. Parsing and Loading StateMachines</a></span></dt><dt><span class="section"><a href="#idp46525581799664">5.4. Defining StateMachines</a></span></dt><dt><span class="section"><a href="#instantiating">5.5. Instantiating Machines: SubMachines and RootMachines</a></span></dt><dt><span class="section"><a href="#idp46525581871056">5.6. Starting and Stopping StateMachines from scripts</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525581891728">6. Program and State Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#orocos-corba">4. Distributing Orocos Components with CORBA</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525586666576">1. The CORBA Transport</a></span></dt><dt><span class="section"><a href="#idp46525587249424">2. Setup CORBA Naming (Required!)</a></span></dt><dt><span class="section"><a href="#idp46525585909808">3. Connecting CORBA components</a></span></dt><dt><span class="section"><a href="#idp46525584767392">4. In-depth information</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525584768704">4.1. Status</a></span></dt><dt><span class="section"><a href="#idp46525584774160">4.2. Limitations</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525584778208">5. Code Examples</a></span></dt><dt><span class="section"><a href="#idp46525586944400">6. Timing and time-outs</a></span></dt><dt><span class="section"><a href="#idp46525586947552">7. Orocos Corba Interfaces</a></span></dt><dt><span class="section"><a href="#idp46525586956784">8. The Naming Service</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525586961856">8.1. Example</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#orocos-mqueue">5. Real-time Inter-Process Data Flow using MQueue</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525594756512">1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525593489440">1.1. Status</a></span></dt><dt><span class="section"><a href="#idp46525593580272">1.2. Requirements and Setup</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525593672656">2. Transporting user types.</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525594056896">2.1. Transporting 'simple' data types</a></span></dt><dt><span class="section"><a href="#idp46525591232128">2.2. Transporting 'complex' data types</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525587038176">3. Connecting ports using the MQueue transport</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525587040592">3.1. Bare C++ connection</a></span></dt><dt><span class="section"><a href="#idp46525587045552">3.2. CORBA managed connections</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#orocos-corelib">6. Core Primitives Reference</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597607536">1. Introduction</a></span></dt><dt><span class="section"><a href="#corelib-activities">2. Activities</a></span></dt><dd><dl><dt><span class="section"><a href="#corelib-periodic-activity">2.1. Executing a Function Periodically</a></span></dt><dt><span class="section"><a href="#corelib-non-periodic-activity">2.2. Non Periodic Activity Semantics</a></span></dt><dt><span class="section"><a href="#idp46525586985760">2.3. Selecting the Scheduler</a></span></dt><dt><span class="section"><a href="#corelib-slave-activity">2.4. Custom or Slave Activities</a></span></dt><dt><span class="section"><a href="#corelib-threads">2.5. Configuring the Threads from Activities</a></span></dt></dl></dd><dt><span class="section"><a href="#corelib-events">3. Signals</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597213648">3.1. Signal Basics</a></span></dt><dt><span class="section"><a href="#idp46525597233856">3.2. <code class="function">setup()</code> and the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Handle.html">Handle</a> object</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525597241840">4. Time Measurement and Conversion</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597242592">4.1. The TimeService</a></span></dt><dt><span class="section"><a href="#idp46525597245824">4.2. Usage Example</a></span></dt></dl></dd><dt><span class="section"><a href="#corelib-attributes">5. Attributes</a></span></dt><dt><span class="section"><a href="#corelib-properties">6. Properties</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597255808">6.1. Introduction</a></span></dt><dt><span class="section"><a href="#idp46525597263120">6.2. Grouping Properties in a PropertyBag</a></span></dt><dt><span class="section"><a href="#idp46525597273728">6.3. Marshalling and Demarshalling Properties (Serialization)</a></span></dt></dl></dd><dt><span class="section"><a href="#corelib-extras">7. Extra Stuff</a></span></dt><dd><dl><dt><span class="section"><a href="#corelib-buffers-data">7.1. Buffers and DataObjects</a></span></dt></dl></dd><dt><span class="section"><a href="#corelib-logging">8. Logging</a></span></dt></dl></dd><dt><span class="chapter"><a href="#orocos-os">7. OS Abstraction Reference</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525605535504">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525604422496">1.1. Real-time OS Abstraction</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525602496528">2. The Operating System Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525603076768">2.1. Basics</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525604264336">3. OS directory Structure</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525600638512">3.1. The RTAI/LXRT OS target</a></span></dt><dt><span class="section"><a href="#idp46525600642064">3.2. Porting Orocos to other Architectures / OSes</a></span></dt><dt><span class="section"><a href="#idp46525600646416">3.3. OS Header Files</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525597359280">4. Using Threads and Real-time Execution of Your Program</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597359984">4.1. Writing the Program main()</a></span></dt><dt><span class="section"><a href="#idp46525597386112">4.2. The Orocos Thread</a></span></dt><dt><span class="section"><a href="#idp46525597417264">4.3. Synchronisation Primitives</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#orocos-fdi">8. Hardware Device Interfaces</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525607949296">1. The Orocos Device Interface (<acronym class="acronym">DI</acronym>)</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597335888">1.1. Structure</a></span></dt><dt><span class="section"><a href="#idp46525609135440">1.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525603291104">2. The Device Interface Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525603292896">2.1. Physical IO</a></span></dt><dt><span class="section"><a href="#idp46525603229616">2.2. Logical Device Interfaces</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525603232800">3. Porting Device Drivers to Device Interfaces</a></span></dt><dt><span class="section"><a href="#idp46525603234336">4. Interface Name Serving</a></span></dt></dl></dd></dl></div><div class="list-of-figures"><p><strong>List of Figures</strong></p><dl><dt>1.1. <a href="#fig-orocos-framework">
	  Orocos Toolchain as Middleware
	</a></dt><dt>2.1. <a href="#fig-task-peers">
	Typical application example for distributed control
      </a></dt><dt>2.2. <a href="#fig-hello-world-deployment">
	  Dynamic vs static loading of components
	</a></dt><dt>2.3. <a href="#fig-hello-world">
	Schematic Overview of the Hello Component.
      </a></dt><dt>2.4. <a href="#fig-a-task-context-intro">
	Schematic Overview of a TaskContext
      </a></dt><dt>2.5. <a href="#fig-component-states">
	TaskContext State Diagram
      </a></dt><dt>2.6. <a href="#fig-task-execution">
	Executing a TaskContext
      </a></dt><dt>2.7. <a href="#fig-data-flow-ports">
	  Data flow ports are connected with a connection policy
	</a></dt><dt>2.8. <a href="#fig-ext-component-states">
	  Extended TaskContext State Diagram
	</a></dt><dt>2.9. <a href="#fig-ext-runtime-states">
	  Possible Run-Time failure.
	</a></dt><dt>2.10. <a href="#fig-comp-levels">
	  Component Deployment Levels
	</a></dt><dt>2.11. <a href="#fig-deployment-example">
	  Example Component Deployment.
	</a></dt><dt>3.1. <a href="#idp46525581769536">State Change Semantics in Reactive Mode</a></dt><dt>3.2. <a href="#idp46525581780576">State Change Semantics in Automatic Mode</a></dt><dt>7.1. <a href="#idp46525604915040">OS Interface overview</a></dt><dt>8.1. <a href="#idp46525607199952">Device Interface Overview</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>2.1. <a href="#execution-types-table">Execution Types</a></dt><dt>2.2. <a href="#calling-combination-table">Call/Send and ClientThread/OwnThread Combinations</a></dt><dt>2.3. <a href="#method-args-table">Operation Return &amp; Argument Types</a></dt><dt>2.4. <a href="#property-types-table">C++ &amp; Property Types</a></dt><dt>3.1. <a href="#idp46525579202160">array and string constructors</a></dt><dt>6.1. <a href="#idp46525597304112">Logger Log Levels</a></dt><dt>7.1. <a href="#idp46525600647680">Header Files</a></dt><dt>8.1. <a href="#idp46525603294160">Physical IO Classes</a></dt></dl></div><div class="list-of-examples"><p><strong>List of Examples</strong></p><dl><dt>2.1. <a href="#idp46525579040768">Setting up a Service</a></dt><dt>2.2. <a href="#idp46525579044896">Using a Service</a></dt><dt>3.1. <a href="#idp46525581662336">string and array creation</a></dt><dt>3.2. <a href="#idp46525581801584">StateMachine Definition Format</a></dt><dt>3.3. <a href="#idp46525581893200">StateMachine Example (state.osd)</a></dt><dt>3.4. <a href="#idp46525581895296">Program example (program.ops)</a></dt><dt>6.1. <a href="#idp46525597207152">Example Periodic Thread Interaction</a></dt><dt>6.2. <a href="#core-event-example">Using Signals</a></dt><dt>6.3. <a href="#idp46525597228224">Signal Types</a></dt><dt>6.4. <a href="#idp46525597251552">Creating attributes</a></dt><dt>6.5. <a href="#idp46525597259584">Using properties</a></dt><dt>6.6. <a href="#idp46525597288112">Accessing a Buffer</a></dt><dt>6.7. <a href="#idp46525597294496">Accessing a DataObject</a></dt><dt>6.8. <a href="#idp46525597331504">Using the Logger class</a></dt><dt>7.1. <a href="#idp46525603197232">Locking a Mutex</a></dt><dt>8.1. <a href="#example_name_service">Using the name service</a></dt></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="idp46525571042304"></a>Chapter 1. How to Read this Manual</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#idp46525571660272">1. Component Interfaces</a></span></dt><dt><span class="section"><a href="#idp46525568126608">2. Component Implementation</a></span></dt><dt><span class="section"><a href="#idp46525570304752">3. Orocos Toolchain Overview</a></span></dt></dl></div><p>
      This manual is for Software developers who wish to write their own software components using
      the Orocos Toolchain. The HTML version of this manual links to the API documentation of all
      classes.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525571660272"></a>1. Component Interfaces</h2></div></div></div><p>
      The most important Chapters to get started building a component
      are presented first. Orocos components are implemented using the
      'TaskContext' class and the following Chapter explains step by
      step how to define the interface of your component, such that
      you can interact with your component from a user interface
      or other component.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525568126608"></a>2. Component Implementation</h2></div></div></div><p>
      For implementing algorithms within your component, various C++
      function <span class="emphasis"><em>hooks</em></span> are present in wich you
      can place custom C++ code. As your component's functionality grows,
      you can extend its <span class="emphasis"><em>scripting</em></span> interface
      and call your algorithms from a script.
    </p><p>
      The Orocos Scripting Chapter details how to write programs and
      state machines. "Advanced Users" may benefit from this Chapter
      as well since the scripting language allows to 'program'
      components without recompiling the source.
    </p><p>
			If you're familiar with the Lua programming language, you can
			also implement components an statemachines in real-time Lua scripts.
			Check out the <a class="ulink" href="http://www.orocos.org/wiki/orocos/toolchain/luacookbook" target="_top">Lua Cookbook</a> website.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525570304752"></a>3. Orocos Toolchain Overview</h2></div></div></div><p>
	The Toolchain allows setup, distribution and
	the building of real-time software components. It is
	sometimes refered to as 'middleware' because it sits
	between the application and the Operating System.
	It takes care of the real-time communication and execution of 
	software components.
      </p><div class="figure"><a id="fig-orocos-framework"></a><p class="title"><strong>Figure 1.1. 
	  Orocos Toolchain as Middleware
	</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/FrameworkOverview.png" alt="Orocos Toolchain as Middleware" /></div></div></div><br class="figure-break" /><p>
	The <a class="ulink" href="http://www.orocos.org/toolchain" target="_top">Toolchain
	</a> provides a limited set of components for application
	development. The Orocos Component Library (OCL) is a
	collection of infrastructure components for building applications.
			</p><p>
  The Toolchain contains components for <a class="ulink" href="http://www.orocos.org/stable/documentation/ocl/v2.x/doc-xml/orocos-deployment.html" target="_top">component deployment</a> and
  <a class="ulink" href="http://www.orocos.org/stable/documentation/rtt/v2.x/doc-xml/orocos-transports-corba.html" target="_top">distribution</a>, <a class="ulink" href="http://www.orocos.org/wiki/Using_real-time_logging" target="_top">real-time status logging</a> and 
	<a class="ulink" href="http://www.orocos.org/stable/documentation/ocl/v2.x/doc-xml/orocos-reporting.html" target="_top">data reporting</a>. It
	also contains tools for <a class="ulink" href="http://www.orocos.org/wiki/orocos/toolchain/getting-started/using-orocreate-pkg" target="_top">creating component packages</a>,
	extremely <a class="ulink" href="http://www.orocos.org/wiki/orocos/toolchain/getting-started/cmake-and-building" target="_top">simple build instructions</a> and <a class="ulink" href="http://www.rock-robotics.org/orogen/" target="_top">
	code generators</a> for plain C++ structs and <a class="ulink" href="http://www.ros.org/wiki/orocos_toolchain_ros" target="_top">ROS messages</a>.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="orocos-taskcontext"></a>Chapter 2. Setting up the Component Interface</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#task-context-intro">1. Introduction</a></span></dt><dt><span class="section"><a href="#idp46525576967360">2. Hello World !</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525576871216">2.1. Using the Deployer</a></span></dt><dt><span class="section"><a href="#idp46525574748864">2.2. Starting your First Application</a></span></dt><dt><span class="section"><a href="#idp46525568015376">2.3. Displaying a TaskContext</a></span></dt><dt><span class="section"><a href="#idp46525575484160">2.4. Listing the Interface</a></span></dt><dt><span class="section"><a href="#idp46525575491744">2.5. Calling an Operation</a></span></dt><dt><span class="section"><a href="#idp46525575496176">2.6. Sending a Operation</a></span></dt><dt><span class="section"><a href="#idp46525575504240">2.7. Changing Values</a></span></dt><dt><span class="section"><a href="#idp46525575511648">2.8. Reading and Writing Ports</a></span></dt><dt><span class="section"><a href="#idp46525575517760">2.9. Last Words</a></span></dt></dl></dd><dt><span class="section"><a href="#basic-task">3. Creating a Basic Component</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525575553376">3.1. Task Application Code</a></span></dt><dt><span class="section"><a href="#idp46525575582608">3.2. Starting a Component</a></span></dt><dt><span class="section"><a href="#task-ports">3.3. Data Flow Ports</a></span></dt><dt><span class="section"><a href="#task-operations">3.4. The OperationCaller/Operation Interface</a></span></dt><dt><span class="section"><a href="#task-attr-rep">3.5. The Attributes and Properties Interface</a></span></dt><dt><span class="section"><a href="#idp46525578970240">3.6. A TaskContext's Error states</a></span></dt></dl></dd><dt><span class="section"><a href="#connect-tasks">4. Connecting Services</a></span></dt><dd><dl><dt><span class="section"><a href="#connect-peers">4.1. Connecting Peer Components</a></span></dt><dt><span class="section"><a href="#setup-data-flow">4.2. Setting up the Data Flow</a></span></dt><dt><span class="section"><a href="#idp46525579035120">4.3. Disconnecting Tasks</a></span></dt></dl></dd><dt><span class="section"><a href="#task-services">5. Providing and Requiring Services</a></span></dt><dt><span class="section"><a href="#run-tasks">6. Using Tasks</a></span></dt><dd><dl><dt><span class="section"><a href="#task-property-config">6.1. Task Property Configuration and XML format</a></span></dt><dt><span class="section"><a href="#idp46525579082448">6.2. Task Scripts</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525579104384">7. Deploying Components</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525579106128">7.1. Overview</a></span></dt><dt><span class="section"><a href="#idp46525579117984">7.2. Embedded TaskCore Deployment</a></span></dt><dt><span class="section"><a href="#idp46525579122784">7.3. Embedded TaskContext Deployment: C++ Interface</a></span></dt><dt><span class="section"><a href="#idp46525579131104">7.4. Full TaskContext Deployment: Dynamic Interface</a></span></dt><dt><span class="section"><a href="#idp46525579132496">7.5. Putting it together</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525579139680">8. Advanced Techniques</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525579145984">8.1. Polymorphism : Task Interfaces</a></span></dt></dl></dd></dl></div><div class="abstract"><p class="title"><strong>Abstract</strong></p><p>
	This document describes the <acronym class="acronym">Orocos</acronym> Component Model, which
	allows to design Real-Time software components which
	transparently communicate with each other.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="task-context-intro"></a>1. Introduction</h2></div></div></div><p>
      This manual documents how multi-threaded components can be
      defined in <acronym class="acronym">Orocos</acronym> such that they form a thread-safe
      robotics/machine control application.  Each control component is
      defined as a "TaskContext", which defines the environment or
      "context" in which an application specific task is executed. The
      context is described by the three Orocos primitives: Operation, Property,
      and Data Port. This document defines how a user
      can write his own task context and how it can be used in an
      application.
    </p><div class="figure"><a id="fig-task-peers"></a><p class="title"><strong>Figure 2.1. 
	Typical application example for distributed control
      </strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/TaskPeers2.png" alt="Typical application example for distributed control" /><div class="caption"><p>
	    Components are loaded into the process by a deployer,
	    which gets its configuration through an XML file.
	    Communication between processes is transparant to the
	    component, but your data must be known to Orocos
	    (cfr 'typekits' and 'transports'). Most new users start
	    with a single process however, using the 'deployer'
	    application.
	  </p></div></div></div></div><br class="figure-break" /><p>
      A component is a basic unit of functionality which executes one
      or more (real-time) programs in a single thread.  The program
      can vary from a mere C/C++ function over a real-time program
      script to a real-time hierarchical state machine. The focus is
      completely on thread-safe time determinism. Meaning, that the
      system is free of priority-inversions, and all operations are
      lock-free.  Real-time components can communicate with non
      real-time components (and vice verse) transparently.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	In this manual, the words task and component are used as equal
	words, meaning a software component built using the C++
	TaskContext class.
      </p></td></tr></table></div><p>
      The Orocos Component Model enables :
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Lock free, thread-safe, inter-component communication in a single process.</p></li><li class="listitem"><p>Thread-safe, inter-process communication between (distributed) processes.</p></li><li class="listitem"><p>Communication between hard Real-Time and non Real-Time components.</p></li><li class="listitem"><p>Deterministic execution time during communication
	  for the higher priority thread.</p></li><li class="listitem"><p>Synchronous and asynchronous communication between components.</p></li><li class="listitem"><p>Interfaces for run-time component introspection.</p></li><li class="listitem"><p>C++ class implementations and scripting interface for all the above.</p></li></ul></div><p>
    </p><p>
      The Scripting chapter gives more details about script syntax
      for state machines and programs.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525576967360"></a>2. Hello World !</h2></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>
				Before you proceed, make sure you printed the <a class="ulink" href="http://www.orocos.org/stable/documentation/rtt/v2.x/doc-xml/orocos_cheat_sheet.pdf" target="_top">Orocos Cheat Sheet</a> and
				<a class="ulink" href="http://www.orocos.org/stable/documentation/rtt/v2.x/doc-xml/rtt_cheat_sheet.pdf" target="_top">RTT Cheat Sheet</a> ! They will definately guide you through this lengthy
				text.
			</p></td></tr></table></div><p>
      This section introduces tasks through the "hello world"
      application, for which you will create a component package using the
			<span class="command"><strong>orocreate-pkg</strong></span> command on the command line:
			</p><pre class="programlisting">$	rosrun ocl orocreate-pkg HelloWorld    # ... for ROS users 
			</pre><p>
			</p><pre class="programlisting">$	orocreate-pkg HelloWorld    # ... for non-ROS users 
			</pre><p>
    </p><p>
			In a properly configured installation, you'll be able to enter this
			directory and build your package right away:
			</p><pre class="programlisting">$	cd HelloWorld
$ make
			</pre><p>
			In case you are <span class="emphasis"><em>not</em></span> using ROS to manage your packages, you also need to 
			install your package:
			</p><pre class="programlisting">$ make install
			</pre><p>
		</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525576871216"></a>2.1. Using the Deployer</h3></div></div></div><p>
	The way we interact with TaskContexts during development of an
	Orocos application is through the <span class="emphasis"><em>deployer
	</em></span>.  This application consists of the 
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../../../ocl/v2.x/api/html/classOCL_1_1DeploymentComponent.html">DeploymentComponent</a> which is responsible
	for creating applications out of component libraries and the 
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../../../ocl/v2.x/api/html/classOCL_1_1DeploymentComponent.html">DeploymentComponent</a>  which is a powerful console
	tool which helps you to explore, execute and debug
	componentss in running
	programs. 
			</p><p>
			The TaskBrowser uses the GNU readline library to easily enter
			commands to the tasks in your system. This means you can press
			TAB to complete your commands or press the up arrow to scroll
			through previous commands. 
      </p><p>
				You can start the deployer in any directory like this:
				</p><pre class="programlisting"> $ deployer-gnulinux
				</pre><p>
				or in a ROS environment:
				</p><pre class="programlisting"> $ rosrun ocl deployer-gnulinux
				</pre><p>
			</p><p>
				This is going to be your primary tool to explore the Orocos
				component model so get your seatbelts fastened!
			</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525574748864"></a>2.2. Starting your First Application</h3></div></div></div><p>
	Now let's start the HelloWorld application we just created with
	<span class="command"><strong>orocreate-pkg</strong></span>.
      </p><p>
	Create an 'helloworld.ops' Orocos Program Script (ops) file with
	these contents:
	</p><pre class="programlisting">
 require("print")        // necessary for 'print.ln'
 import("HelloWorld")    // 'HelloWorld' is a directory name to import      

 print.ln("Script imported HelloWorld package:")
 displayComponentTypes() // Function of the DeploymentComponent
 
 loadComponent("Hello", "HelloWorld") // Creates a new component of type 'HelloWorld'
 print.ln("Script created Hello Component with period: " + Hello.getPeriod() )
</pre><p>
        and load it into the deployer using this command:
	<span class="command"><strong>$ deployer-gnulinux -s helloworld.ops -linfo</strong></span>
	This command imports the HelloWorld package and any component library 
	in there. Then it creates a component with name "Hello". We call this
	a dynamic deployment, since the decision to create components is done
	at run-time.
			</p><p>
			You could also create your component in a C++ program. We call this
			static deployment, since the components are fixed at compilation time.
			The figure below illustrates this difference:
      </p><div class="figure"><a id="fig-hello-world-deployment"></a><p class="title"><strong>Figure 2.2. 
	  Dynamic vs static loading of components
	</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/HelloDeployment.png" alt="Dynamic vs static loading of components" /><div class="caption"><p>The 'helloworld' executable is a static deployment of one component in a process, which
	    means it is hard-coded in the helloworld.cpp file.
	    In contrast, using the deployer application allows you to load a component library dynamically.
	    </p></div></div></div></div><br class="figure-break" /><p>
      The output of the deployer should be similar to what we show below. Finally, type <span class="command"><strong>cd
	Hello</strong></span> to start with the exercise.
      </p><pre class="screen">
0.000 [ Info   ][Logger] Real-time memory: 14096 bytes free of 20480 allocated.
0.000 [ Info   ][Logger] No RTT_COMPONENT_PATH set. Using default: <span class="emphasis"><em>.../rtt/install/lib/orocos</em></span>
0.000 [ Info   ][Logger] plugin 'rtt' not loaded before.

<span class="emphasis"><em>...</em></span>

0.046 [ Info   ][Logger] Loading Service or Plugin scripting in TaskContext Deployer
0.047 [ Info   ][Logger] Found complete interface of requested service 'scripting'
0.047 [ Info   ][Logger] Running Script helloworld.ops ...
0.050 [ Info   ][DeploymentComponent::import] Importing directory <span class="emphasis"><em>.../HelloWorld/lib/orocos/gnulinux</em></span> ...
0.050 [ Info   ][DeploymentComponent::import] Loaded component type 'HelloWorld'
Script imported HelloWorld package:
I can create the following component types: 
   HelloWorld
   OCL::ConsoleReporting
   OCL::FileReporting
   OCL::HMIConsoleOutput
   OCL::HelloWorld
   OCL::TcpReporting
   OCL::TimerComponent
   OCL::logging::Appender
   OCL::logging::FileAppender
   OCL::logging::LoggingService
   OCL::logging::OstreamAppender
   TaskContext
0.052 [ Info   ][Thread] Creating Thread for scheduler: 0
0.052 [ Info   ][Hello] Thread created with scheduler type '0', priority 0, cpu affinity 15 and period 0.
HelloWorld constructed !
0.052 [ Info   ][DeploymentComponent::loadComponent] Adding Hello as new peer:  OK.
Script created Hello Component with period: 0
0.053 [ Info   ][Thread] Creating Thread for scheduler: 0
0.053 [ Info   ][TaskBrowser] Thread created with scheduler type '0', priority 0, cpu affinity 15 and period 0.
   Switched to : Deployer
0.053 [ Info   ][Logger] Entering Task Deployer

  This console reader allows you to browse and manipulate TaskContexts.
  You can type in an operation, expression, create or change variables.
  (type 'help' for instructions and 'ls' for context info)
    TAB completion and HISTORY is available ('bash' like)

Deployer [S]&gt; cd Hello
   Switched to : Hello
Hello [S]&gt;
      </pre><p>
	The first <span class="command"><strong>[ Info ]</strong></span> lines are printed by the
	Orocos <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Logger.html">Logger</a>, which has been
	configured to display informative messages to
	console with the <span class="command"><strong>-linfo</strong></span> program option.
	Normally, only warnings or worse are displayed by
	Orocos. You can always watch the log file 'orocos.log' in the
	same directory to see all messages.  After the <span class="command"><strong>[Log
	Level]</strong></span>, the <span class="command"><strong>[Origin]</strong></span> of the
	message is printed, and finally the message itself. These
	messages leave a trace of what was going on in the main()
	function before the prompt appeared.
      </p><p>
	Depending on what you type, the TaskBrowser will act
	differently.  The built-in commands <span class="command"><strong>cd</strong></span>,
	<span class="command"><strong>help</strong></span>, <span class="command"><strong>quit</strong></span>,
	<span class="command"><strong>ls</strong></span> etc,  are seen as commands to the TaskBrowser
	itself, if you typed something else, it tries to execute your
	command according to the Orocos scripting language syntax.
      </p><pre class="screen">
Hello[R] &gt; <span class="command"><strong>1+1</strong></span>
   = <span class="command"><strong>2</strong></span>
      </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525568015376"></a>2.3. Displaying a TaskContext</h3></div></div></div><p>
      A component's interface consists of: Attributes and Properties, Operations,
      and Data Flow ports which are all public.
      The class <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a> 
      groups all these interfaces and serves as the basic building
      block of applications. A component developer 'builds'
      these interfaces using the instructions found in this manual.
    </p><div class="figure"><a id="fig-hello-world"></a><p class="title"><strong>Figure 2.3. 
	Schematic Overview of the Hello Component.
      </strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/HelloWorld.png" alt="Schematic Overview of the Hello Component." /><div class="caption"><p>Our hello world component.
	  </p></div></div></div></div><br class="figure-break" /><p>
	To display the contents of the current component, type
	<span class="command"><strong>ls</strong></span>, and switch to one of the listed peers
	with <span class="command"><strong>cd</strong></span>, while <span class="command"><strong>cd ..</strong></span>
	takes you one peer back in history. We have two peers here:
	the Deployer and your component, Hello.
      </p><pre class="screen">
Hello [S]&gt; <span class="command"><strong>ls</strong></span>

 Listing TaskContext Hello[S] :

 Configuration Properties: (none)

 Provided Interface:
  Attributes   : (none)
  Operations   : activate cleanup configure error getCpuAffinity getPeriod inFatalError inRunTimeError isActive isConfigured isRunning setCpuAffinity setPeriod start stop trigger update 

 Data Flow Ports: (none)

 Services: 
(none)

 Requires Operations :  (none)
 Requests Services   :  (none)

 Peers        : (none)
Hello [S]&gt;
      </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>To get a quick overview of the commands, type
	<span class="command"><strong>help</strong></span>.
	</p></td></tr></table></div><p>
	The first line shows the status between square brackets. The [S] here
	means that the component is in the stopped state. Other states can 
	be 'R' - Running, 'U' - Unconfigured, 'E' - run-time Error, 'F' - Fatal error,
	'X' - C++ eXception in user code.
      </p><p>
	First you get a list of the Properties and Attributes
	(alphabetical) of the current component. Properties are meant
	for configuration and can be written to disk. Attributes export
	a C++ class value to the interface, to be usable by scripts or
	for debugging and are not persistent.
      </p><p>
	Next, the operations of this component are listed: each component
	has some universal functions like activate, start, getPeriod etc.
      </p><p>
				You can see that the component is pretty empty: no data flow ports,
				services or peers. We will add some of these right away.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525575484160"></a>2.4. Listing the Interface</h3></div></div></div><p>
	To get an overview of the Task's interface, you can use the help
	command, for example <span class="emphasis"><em>help this</em></span> or <span class="emphasis"><em>help this.activate</em></span>
	or just short: <span class="emphasis"><em>help activate</em></span>
			</p><pre class="screen">
Hello [R]&gt; <span class="command"><strong>help this</strong></span>

Printing Interface of 'Hello' :

 <span class="emphasis"><em>activate</em></span>( ) : bool
   Activate the Execution Engine of this TaskContext (= events and commands).
 <span class="emphasis"><em>cleanup</em></span>( ) : bool
   Reset this TaskContext to the PreOperational state (write properties etc).
...
   Stop the Execution Engine of this TaskContext.

Hello [R]&gt; <span class="command"><strong>help getPeriod</strong></span>
 <span class="emphasis"><em>getPeriod</em></span>( ) : double
Get the configured execution period. -1.0: no thread associated, 0.0: non periodic, &gt; 0.0: the period.

Hello [R]&gt; 
      </pre><p>
	Now we get more details about the operations
	registered in the public interface. We see now that
	the <span class="emphasis"><em>getPeriod</em></span> operations takes no arguments
	You can invoke each operation right away.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525575491744"></a>2.5. Calling an Operation</h3></div></div></div><pre class="screen">
Hello [R]&gt; <span class="command"><strong>getPeriod()</strong></span>
 = <span class="command"><strong>0</strong></span>
      </pre><p>
	Operations are called directly and the TaskBrowser prints the
	result. The return value of getPeriod() was a double, which is
	0. This works just like calling a 'C' function.
	You can express calling explicitly by writing:
	<span class="command"><strong>getPeriod.call()</strong></span>.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525575496176"></a>2.6. Sending a Operation</h3></div></div></div><p>
	When an operation is <span class="emphasis"><em>sent</em></span> to
	the Hello component, another thread will execute it on
	behalf of the sender. Each sent method returns a SendHandle object.
      </p><pre class="screen">
Hello [R]&gt; <span class="command"><strong>getPeriod.send()</strong></span>
 = (unknown_t)
      </pre><p>
	The returned SendHandle must be stored in a SendHandle attribute
	to be useful:
      </p><pre class="screen">
Hello [R]&gt; <span class="command"><strong>var SendHandle sh</strong></span>
Hello [R]&gt; <span class="command"><strong>sh = getPeriod.send()</strong></span>
 = true
Hello [R]&gt; <span class="command"><strong>sh.collectIfDone( ret )</strong></span>
 = SendSuccess
Hello [R]&gt; <span class="command"><strong>ret</strong></span>
 = 0
      </pre><p>
				SendHandles are further explained down the document.
				They are not required understanding for a first discovery
				of the Orocos world.
			</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525575504240"></a>2.7. Changing Values</h3></div></div></div><p>
	Besides calling or sending component methods, you can alter the
	attributes of any task, program or state machine. The
	TaskBrowser will confirm validity of the assignment with
	the contents of the variable. Since Hello doesn't have any 
	attributes, we create one dynamically:
      </p><pre class="screen">
Hello [R]&gt; <span class="command"><strong>var string the_attribute = "HelloWorld"</strong></span>
Hello [R]&gt; <span class="command"><strong>the_attribute</strong></span>
 = <span class="command"><strong>Hello World</strong></span>
Hello [R]&gt; <span class="command"><strong>the_attribute = "Veni Vidi Vici !"</strong></span>
 = <span class="command"><strong>"Veni Vidi Vici !"</strong></span>
Hello [R]&gt; <span class="command"><strong>the_attribute</strong></span>
 = <span class="command"><strong>Veni Vidi Vici !</strong></span>
      </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525575511648"></a>2.8. Reading and Writing Ports</h3></div></div></div><p>
	The Data Ports allow seamless communication of calculation or 
	measurement results between components. Adding and using ports is
	described in <a class="xref" href="#task-ports" title="3.3. Data Flow Ports">Section 3.3, “Data Flow Ports”</a>.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525575517760"></a>2.9. Last Words</h3></div></div></div><p>
	Last but not least, hitting TAB twice, will show you a list of
	possible completions, such as peers, services or methods.
      </p><p>
	TAB completion works even across peers, such that you can type
	a TAB completed command to another peer than the current peer.
      </p><p>
	In order to quit the TaskBrowser, enter <span class="command"><strong>quit</strong></span>:
      </p><pre class="screen">
 Hello [R]&gt; <span class="command"><strong>quit</strong></span>

1575.720 [ Info   ][ExecutionEngine::setActivity] Hello is disconnected from its activity.
1575.741 [ Info   ][Logger] Orocos Logging Deactivated.      
      </pre><p>
	The TaskBrowser Component is application independent, so that
	your end user-application might need a more suitable
	interface. However, for testing and inspecting what is
	happening inside your real-time programs, it is a very useful
	tool. The next sections show how you can add properties,
	methods etc to a TaskContext.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	  If you want a more in-depth tutorial, see the rtt-exercises
	  package which covers each aspect also shown in this manual.
	</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="basic-task"></a>3. Creating a Basic Component</h2></div></div></div><p>
      Components are 
      implemented by subclassing the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a> class.
      It is useful speaking of a context because it defines
      the context in which an activity (a program) operates. 
      It defines the interface of the component, its properties,
      its peer components and uses its
      <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> to execute its
      programs and to process asynchronous messages.
    </p><p>
      This section walks you through the definition of an example component
      in order to show you how you could build your own component.
    </p><p>
      A  new component is constructed as :
    </p><p>
      </p><pre class="programlisting">
  #include &lt;rtt/TaskContext.hpp&gt;
  #include &lt;rtt/Component.hpp&gt;

  // we assume this is done in all the following code listings :
  using namespace RTT;

  class MyTask : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
  public:
       ATask(const std::string&amp; name) : public TaskContext(name) {}
  };

  // from Component.hpp:
  OCL_CREATE_COMPONENT( MyTask );
      </pre><p>
    </p><p>
      The constructor argument is the (unique) name of the component.
			You should create the component template and the CMakeLists.txt
			file using the <span class="command"><strong>orocreate-pkg</strong></span> program such
			that this compiles right away as in the HelloWorld example above:
			</p><pre class="programlisting">
				$ orocreate-pkg mytask
			</pre><p>
		</p><p>
			You can load this package in a deployer by using the <span class="command"><strong>import</strong></span>
			command at the TaskBrowser prompt and verify that it contains components 
      using <span class="command"><strong>displayComponentTypes()</strong></span> in the
      TaskBrowser. After import, <span class="command"><strong>loadComponent("the_task","MyTask")</strong></span>
      loads a new component instance into the process:
    </p><pre class="programlisting">
      $ deployer-gnulinux
      ...
			Deployer [S]&gt; import("mytask")    // 'mytask' is a directory name to import      
			Deployer [S]&gt; displayComponentTypes() // lists 'MyTask' among others
			...
			MyTask
			...
			Deployer [S]&gt; loadComponent("the_task", "MyTask") // Creates a new component of type 'MyTask'
		</pre><div class="figure"><a id="fig-a-task-context-intro"></a><p class="title"><strong>Figure 2.4. 
	Schematic Overview of a TaskContext
      </strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ATaskContext.png" alt="Schematic Overview of a TaskContext" /><div class="caption"><p>
	    The component offers services through operations, and requests
	    them through operation callers. The Data Flow is the propagation of data from
	    one task to another, where one producer can have multiple
	    consumers and the other way around.
	  </p></div></div></div></div><br class="figure-break" /><p>
      The beating hart of the component is its Execution Engine will check
      for new messages in it's queue and execute programs which are
      running in the task. When a TaskContext is created, the ExecutionEngine 
      is always running. The complete state flow of a TaskContext is shown in
      <a class="xref" href="#fig-component-states" title="Figure 2.5.  TaskContext State Diagram">Figure 2.5, “
	TaskContext State Diagram
      ”</a>. You can add code in the TaskContext
      by implementing *Hook() functions, which will be called by the ExecutionEngine
      when it is in a certain state or transitioning between states.
    </p><div class="figure"><a id="fig-component-states"></a><p class="title"><strong>Figure 2.5. 
	TaskContext State Diagram
      </strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ComponentStates.png" alt="TaskContext State Diagram" /><div class="caption"><p>
	    During creation, a component is in the
	    <code class="function">Init</code> state. When constructed, it
	    enters the <code class="function">PreOperational</code> or
	    <code class="function">Stopped</code> (default) state. If it enters
	    the PreOperational state after construction, it requires
	    an additional <code class="function">configure()</code> call before
	    it can be <code class="function">start()</code>'ed. The figure
	    shows that for each API function, a user 'hook' is
	    available.
	  </p></div></div></div></div><br class="figure-break" /><p>
      The first section goes into detail on how to use these hooks.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525575553376"></a>3.1. Task Application Code</h3></div></div></div><p>
      The user application code is filled in by inheriting from the
      <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a> and implementing the
      'Hook' functions. There are five such functions which are called
      when a TaskContext's state changes.
    </p><p>
      The user may insert his configuration-time setup/cleanup code in the
      <code class="function">configureHook()</code> (read XML, print status
      messages etc.) and <code class="function">cleanupHook()</code> (write
      XML, free resources etc.).
    </p><p>
      The run-time (or: real-time) application code belongs in the
      <code class="function">startHook()</code>,
      <code class="function">updateHook()</code> and
      <code class="function">stopHook()</code> functions.
    </p><pre class="programlisting">class MyTask 
    : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
  public:
       MyTask(std::string name) 
         : <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>(name)
       {
          // see later on what to put here.
       }
  
       /**
        * This function is for the configuration code.
        * Return false to abort configuration.
        */
       bool configureHook() {
          // ...
          return true;
       }

       /**
        * This function is for the application's start up code.
        * Return false to abort start up.
        */
       bool startHook() {
          // ...
          return true;
       }

       /**
        * This function is called by the Execution Engine.
        */
       void updateHook() {
          // Your component's algorithm/code goes in here.
       }

       /**
        * This function is called when the task is stopped.
        */
       void stopHook() {
          // Your stop code after last updateHook()
       }

       /**
        * This function is called when the task is being deconfigured.
        */
       void cleanupHook() {
          // Your configuration cleanup code
       }
  };</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>
	By default, the TaskContext enters the
	<code class="function">Stopped</code> state 
	(<a class="xref" href="#fig-component-states" title="Figure 2.5.  TaskContext State Diagram">Figure 2.5, “
	TaskContext State Diagram
      ”</a>)
	when it is created, which
	makes <code class="function">configure()</code> an optional call. 
      </p></td></tr></table></div><p> If you want to <span class="emphasis"><em>force</em></span> the user to call
    configure() of your TaskContext, set the TaskState in your constructor
    as such:
    </p><pre class="programlisting">class MyTask 
    : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
  public:
       MyTask(std::string name) 
         : <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>(name, <span class="emphasis"><em>PreOperational</em></span>) // demand configure() call.
       {
          //...
       }
  };</pre><p>
      When <code class="function">configure()</code> is called, the
      <code class="function">configureHook()</code> (which <span class="emphasis"><em>you</em></span>
      must implement!) is executed and must return
      false if it failed. The TaskContext drops to the
      <code class="function">PreOperational</code> state in that case.
      When <code class="function">configureHook()</code> succeeds, the
      TaskContext enters the <code class="function">Stopped</code> state
      and is ready to run.
    </p><p>
      A TaskContext in the <code class="function">Stopped</code> state
      (<a class="xref" href="#fig-component-states" title="Figure 2.5.  TaskContext State Diagram">Figure 2.5, “
	TaskContext State Diagram
      ”</a>)
      may be <code class="function">start()</code>'ed upon which
      <code class="function">startHook()</code> is called once and may abort
      the start up sequence by returning false. If true, it enters the
      <code class="function">Running</code> state and
      <code class="function">updateHook()</code> is called (a)periodically by
      the ExecutionEngine, see below.  When the task is
      <code class="function">stop()</code>'ed, <code class="function">stopHook()</code>
      is called after the last <code class="function">updateHook()</code> and
      the TaskContext enters the <code class="function">Stopped</code> state
      again. Finally, by calling <code class="function">cleanup()</code>, the
      <code class="function">cleanupHook()</code> is called and the TaskContext
      enters the <code class="function">PreOperational</code> state.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525575582608"></a>3.2. Starting a Component</h3></div></div></div><p>
	The functionality of a component, i.e. its algorithm, is executed
	by its internal Execution Engine.  To run a TaskContext, you
	need to use one of the
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1ActivityInterface.html">ActivityInterface</a> classes from the
	RTT, most likely <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a>.  This
	relation is shown in <a class="xref" href="#fig-task-execution" title="Figure 2.6.  Executing a TaskContext">Figure 2.6, “
	Executing a TaskContext
      ”</a>.
	The Activity class allocates a thread which executes the
	Execution Engine. The chosen
	<code class="classname">Activity</code> object will run
	the Execution Engine, which will in turn call the
	application's hooks above. When created, the TaskContext is assigned
	the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a> by default.
	It offers an internal thread which can receive messagse
	and process events but is not periodicly executing
	updateHook().
      </p><div class="figure"><a id="fig-task-execution"></a><p class="title"><strong>Figure 2.6. 
	Executing a TaskContext
      </strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/TaskContextExecution.png" alt="Executing a TaskContext" /><div class="caption"><p>You can make a TaskContext 'active' by creating
	  an Activity object which executes its Execution Engine.
	  </p></div></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525575592736"></a>3.2.1. Periodic Execution</h4></div></div></div><p>
	A common task in control is executing an algorithm periodically.
	This is done by attaching an activity to the Execution Engine
	which has a periodic execution time set.
	</p><pre class="programlisting">
  #include &lt;rtt/Activity.hpp&gt;

  using namespace RTT;

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>* a_task = new MyTask("the_task");
  // Set a periodic activity with priority=5, period=1000Hz
  a_task-&gt;setActivity( new <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a>( 5, 0.001 ));
  // ... start the component:
  a_task-&gt;start(); 
  // ...
  a_task-&gt;stop();</pre><p>
	Which will run the Execution Engine of "ATask" with a
	frequency of 1kHz. This is the frequency at which state
	machines are evaluated, program steps taken, methods and
	messages are accepted and executed and the application code in
	<code class="function">updateHook()</code> is run. Normally this activity
	is always running, but you can stop and start it too.
      </p><p>
	You don't need to create a new Activity if you want to switch
	to periodic execution, you can also use the <code class="function">setPeriod</code>
	function:
	</p><pre class="programlisting">
  // In your TaskContext's configureHook():
  bool configureHook() {
      return this-&gt;setPeriod(0.001); // set to 1000Hz execution mode.
  }</pre><p>
	An <code class="function">updateHook()</code> function of a periodic
	task could look like:
	</p><pre class="programlisting">  class MyTask 
    : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
  public:
       // ...
  
       /**
        * This function is periodically called.
        */
       void updateHook() {
          // Your algorithm for periodic execution goes inhere
          double result;
          if ( inPort.read(result) == NewData )
              outPort.write( result * 2.0 ); // only write if new data arrived.
       }

  };</pre><p>You can find more detailed information in
       <a class="xref" href="#corelib-activities" title="2. Activities">Section 2, “Activities”</a> in the CoreLib
       reference.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525575602688"></a>3.2.2. Default Component Execution Semantics</h4></div></div></div><p>
	A TaskContext is run by default by a non periodic RTT:Activity object. This
	is useful when <code class="function">updateHook()</code> only needs
	to process data when it arrives on a port or must wait on
	network connections or does any other blocking operation.
      </p><p>
	Upon start(), the Execution Engine waits for new methods or data to
	come in to be executed. Each time such an event happens, the user's
	application code (<code class="function">updateHook()</code>) is called 
	after the Execution Engine did its work.
      </p><p>
	An <code class="function">updateHook()</code> function of a non periodic
	task could look like:
	</p><pre class="programlisting">  class MyTask 
    : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
  public:
       // ...
  
       /**
        * This function is only called by the Execution Engine 
        * when 'trigger()' is called or an event or command arrives.
        */
       void updateHook() {
            // Your blocking algorithm goes inhere
            char* data;
            double timeout = 0.02; // 20ms
            int rv = my_socket_read(data, timeout);

            if (rv == 0) {
               // process data
               this-&gt;stateUpdate(data);
            }
	    <span class="emphasis"><em>
            // This is special for non periodic activities, it makes
            // the TaskContext call updateHook() again after
            // commands and events are processed.</em></span>
            this-&gt;getActivity()-&gt;trigger(); 
       }

  };</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/icons/warning.png" /></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>
	  Non periodic activities should be used with care and with
	  much thought in combination with scripts (see later). The
	  ExecutionEngine will do <span class="emphasis"><em>absolutely
	  nothing</em></span> if no asynchronous methods or <span class="emphasis"><em>asynchronous
	  events</em></span> or no <span class="emphasis"><em>trigger</em></span> comes
	  in.  This may lead to surprising 'bugs' when program scripts
	  or state machine scripts are executed, as they will only
	  progress upon these events and seem to be stalled otherwise.
	</p></td></tr></table></div><p>You can find more detailed information in
       <a class="xref" href="#corelib-activities" title="2. Activities">Section 2, “Activities”</a> in the CoreLib
       reference.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="task-ports"></a>3.3. Data Flow Ports</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Purpose"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Purpose</th></tr><tr><td align="left" valign="top"><p>A component has ports in order to send or receive a
	  stream of data. The algorithm writes Output ports to publish
	  data to other components, while input ports allow an
	  algorithm to receive data from other components.  A
	  component can be woken up if data arrives at one or more
	  input ports or it can 'poll' for new data on its input
	  ports.
	</p><p>
	  Reading and writing data ports is always real-time and
	  thread-safe, on the condition that copying your data
	  (i.e. your operator= ) is as well.
	</p></td></tr></table></div><p>
	Each component defines its data exchange ports and connections
	transmit data from one port to another. A Port is defined by a
	name, unique within that component, the data type it wants to
	exchange and if its for reading (Input) or writing (Output) data samples.
	Finally,
	you can opt that new data on selected Input ports wake up your task.
	The example below shows all these possibilities.
      </p><p>
	Each connection between an Output port and an Input port can
	be tuned for your setup: buffering of data, thread-safety
	and initialisation of the connection are parameters provided
	by the user when the connection is created. We call these
	<span class="emphasis"><em>Connection Policies</em></span> and use the
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1ConnPolicy.html">ConnPolicy</a>
	object when creating the connection between ports.
      </p><div class="figure"><a id="fig-data-flow-ports"></a><p class="title"><strong>Figure 2.7. 
	  Data flow ports are connected with a connection policy
	</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/DataFlowPorts.png" alt="Data flow ports are connected with a connection policy" /><div class="caption"><p>
	      This figure shows that input and output ports
	      can be connected in an N:M way. See
	      <a class="xref" href="#setup-data-flow" title="4.2. Setting up the Data Flow">Section 4.2, “Setting up the Data Flow”</a> on how to connect ports and
	      which connection policy to choose.
	    </p></div></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525575625488"></a>3.3.1. Which data can be transfered ?</h4></div></div></div><p>
	  The data flow implementation can pass on any data type 'X', given
	  that its class provides:
	  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>A default constructor: X::X()</p></li><li class="listitem"><p>An assignment operator: const X&amp; X::operator=(const X&amp; )</p></li></ul></div><p>
	  For real-time data transfer (see also <a class="xref" href="#guarantee-rt-data-flow" title="3.3.3. Guaranteeing Real-Time data flow">Section 3.3.3, “Guaranteeing Real-Time data flow”</a>) the operator= must be
	  real-time when assigning equal sized objects. When assigning not
	  equal sized objects, your operator= should free the memory and
	  allocate enough room for the new size.
	</p><p>
	  In addition, if you want to send your data out of your
	  process to another process or host, it will additionally
	  need:
	  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Registration of 'X' with the type system (see the manual about Typekits)</p></li><li class="listitem"><p>A transport for the data type registered with the type system (see the transport (ROS,CORBA,MQueue,...) documentation)</p></li></ul></div><p>
	  The standard C++ and std::vector&lt;double&gt; data types are
	  already included in the RTT library for real-time transfer
	  and out of process transport.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525575631776"></a>3.3.2. Setting up the Data Flow Interface</h4></div></div></div><p>
	  Any kind of data can be exchanged (also user defined C/C++ types)
	  but for readability, only the 'double' C type is used here.
	  </p><pre class="programlisting">  #include &lt;rtt/Port.hpp&gt;
  using namespace RTT;

  class MyTask
    : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
    // Input port: We'll let this one wake up our thread
    <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1InputPort.html">InputPort</a>&lt;double&gt; evPort;

    // Input port: We will poll this one
    <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1InputPort.html">InputPort</a>&lt;double&gt; inPort;

    // Output ports are allways 'send and forget'
    <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1OutputPort.html">OutputPort</a>&lt;double&gt; outPort;
  public:
    // ...
    MyTask(std::string name)
      : <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>(name)
    {
       // an 'EventPort' is an InputPort which wakes our task up when data arrives.
       this-&gt;ports()-&gt;addEventPort( "evPort", evPort ).doc( "Input Port that raises an event." );

       // These ports do not wake up our task
       this-&gt;ports()-&gt;addPort( "inPort", inPort ).doc( "Input Port that does *not* raise an event." );
       this-&gt;ports()-&gt;addPort( "outPort", outPort ).doc( "Output Port, here write our data to." );

       // more additions to follow, see below
     }

     // ...
  };</pre><p>
      </p><p>
	The example starts with declaring all the ports of MyTask. A
	template parameter '&lt;double&gt;' specifies the type of data
	the task wants to exchange through that port. Logically, if
	input and output are to be connected, they must agree on this type.
	The name is given in the addPort() function. This
	name can be used to 'match' ports between connected tasks
	( using 'connectPorts', see <a class="xref" href="#connect-tasks" title="4. Connecting Services">Section 4, “Connecting Services”</a> ),
	but it is possible <span class="emphasis"><em>and preferred</em></span> to connect Ports with different names
	using the Orocos deployer.
      </p><p>
	There are two ways to add a port to the TaskContext interface:
	using <code class="function">addPort()</code>
	or <code class="function">addEventPort()</code>. In the latter case,
	new data arriving on the port will wake up ('trigger') the
	activity of our TaskContext and updateHook() get's executed.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	  Only <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1InputPort.html">InputPort</a> can be added as EventPort and
	  will cause your component to be triggered (ie wake up and
	  call updateHook).
	</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="guarantee-rt-data-flow"></a>3.3.3. Guaranteeing Real-Time data flow</h4></div></div></div><p>
	  The data flow implementation is written towards hard real-time data
	  transfer, if the data type allows it. Simple data types, like
	  a double or struct with only data which can be copied without
	  causing memory allocations work out of the box. No special measures
	  must be taken and the port is immediately ready to use.
	</p><p>
	  If however, your type is more complex, like a std::vector
	  or other dynamically sized object, additional setup steps
	  must be done. First, the type must guarantee that its
	  operator=() is real-time in case two equal-sized objects
	  are used. Second, before sending the first data
	  to the port, a properly sized data sample must be given
	  to the output port. An example:
	  </p><pre class="programlisting">  OutputPort&lt;std::vector&lt;double&gt; &gt; myport("name");

  // create an example data sample of size 10:
  std::vector&lt;double&gt; example(10, 0.0);

  // show it to the port (this is a not real-time operation):
  myport.setDataSample( example );
	    
  // Now we are fine ! All items sent into the port of size 10 or less will
  // be passed on in hard real-time.  
  myport.write( example ); // hard real-time.
</pre><p>
          setDataSample does not actually send the data to all receivers,
	  it just uses this sample to initiate the connection, such that
	  any subsequent writes to the port with a similar sample will
	  be hard real-time. If you omit this call, data transfer will
	  proceed, but the RTT makes no guarantees about real-timeness
	  of the transfer.
	</p><p>
	  The same procedure holds if you use transports to send data
	  to other processes or hosts. However, it will be the transport
	  protocol that determines if the transfer is real-time or not.
	  For example, CORBA transports are not hard real-time, while
	  MQueue transports are.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525575647392"></a>3.3.4. Using the Data Flow Interface in C++</h4></div></div></div><p>
	  The Data Flow interface is used by your task from within
	  the program scripts or its <code class="function">updateHook()</code>
	  method. Logically the script or method reads the inbound
	  data, calculates something and writes the outbound data.
	</p><pre class="programlisting">  #include &lt;rtt/Port.hpp&gt;
  using namespace RTT;

  class MyTask
    : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
     // ...Constructor sets up Ports, see above.

     bool startHook() {
       // Check validity of (all) Ports:
       if ( !inPort.connected() ) {
          // No connection was made, can't do my job !
          return false;
       }
       if ( !outPort.connected() ) {
          // ... not necessarily an error, a connection may be
          // made while we are running.
       }
       return true;
     }

     /**
      * Note: use updateHook(const std::vector&lt;PortInterface*&gt;&amp;)
      * instead for having information about the updated event 
      * driven ports.
      */
     void updateHook() {

       double val = 0.0; 

       // Possible return values are: NoData, OldData and NewData.
       if ( inPort.read(val) == RTT::NewData ) {
         // <span class="emphasis"><em>update val...</em></span>
         outPort.write( val );
       }
     }
     // ...
  };</pre><p>
	  It is wise to check in the <code class="function">startHook()</code>
	  ( or earlier: in <code class="function">configureHook()</code> )
	  function if all necessary ports are
	  <code class="function">connected()</code>.  At this point, the task
	  start up can still be aborted by returning false. Otherwise,
	  a write to an unconnected output port will be discarded,
	  while a read from an unconnected input port returns NoData.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525575654928"></a>3.3.5. Using Data Flow in Scripts</h4></div></div></div><p>
	  When a Port is added, it becomes available to the
	  Orocos scripting system such that (part of) the calculation
	  can happen in a script. Also, the TaskBrowser can then
	  be used to inspect the contents of the DataFlow on-line.
	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In scripting, it is currently not yet possible to 
	    know which event port woke your task up.</p></td></tr></table></div><p>
	  A small program script could be loaded into MyTask with
	  the following contents:
	  </p><pre class="programlisting">  program MyControlProgram {
    var double the_K  = K        // read task property, see later.
    var double setp_d

    while ( true ) {
      if ( SetPoint_X.read( setp_d ) != NoData ) {   // read Input Port
        var double in_d = 0.0;
        Data_R.read( in_d )             // read Input Port
        var double out_d = (setp_d - in_d) * the_K  // Calculate
        Data_W.write( out_d )          // write Data Port
      }
      yield       // this is a 'yield' point to avoid inifinite spinning.
    }
  } </pre><p>
         The program "MyControlProgram" starts with declaring
	 two variables and reading the task's Property 'K'.
	 Then it goes into an endless loop, trying to Pop
	 a set point value from the "SetPoint_X" Port. If that succeeds (new or old data present)
	 the  "Data_R" Port is read and a simple 
	 calculation is done. The result is written to the
	 "Data_W" OutputPort and can now be read by the other
	 end(s). Alternatively, the result may be directly
	 used by the Task in order to write it to a device
	 or any non-task object. You can use methods (below)
	 to send data from scripts back to the C++ implementation.
	</p><p>
	  Remark that the program is executed within the thread of the component.
	  In order to avoid the endless loop, a 'wait' point
	  must be present. The "yield" command inserts such a
	  wait point and is part of the Scripting syntax.  If you plan
	  to use Scripting state machines, such a
	  <code class="function">while(true)</code> loop (and hence wait point)
	  is not necessary. See the Scripting Manual for a full
	  overview of the syntax.
	</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="task-operations"></a>3.4. The OperationCaller/Operation Interface</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Purpose"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Purpose</th></tr><tr><td align="left" valign="top"><p>A task's operations
        define which functions a component offers. Operations are grouped
        in 'services', much like C++ class methods are grouped in classes.
        OperationCallers are helper objects for calling operations.
      </p></td></tr></table></div><p>
	Operations are C/C++ functions that can be used
	in scripting or can be called from another process or accross a network.
	They take arguments and return a value.
	The return value can in return be used as an argument
	for other Operations or stored in a variable.
      </p><p>
	To add a C/C++ function to the operation interface, you
	only need to register it with <code class="function">addOperation()</code>,
	defined in <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Service.html">Service</a>.
      </p><p>
	</p><pre class="programlisting">
  #include &lt;rtt/Operation.hpp&gt;
  using namespace RTT;

  class MyTask
    : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
    public:
    void reset() { ... }
    string getName() const { ... }
    double changeParameter(double f) { ... }
    // ...
 
    MyTask(std::string name)
      : <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>(name),
    {
       // Add the method objects to the method interface:
       this-&gt;addOperation( "reset",  &amp;MyTask::reset, this, <span class="emphasis"><em>OwnThread</em></span>)
                                   .doc("Reset the system.");
       this-&gt;addOperation( "getName", &amp;MyTask::getName, this, <span class="emphasis"><em>ClientThread</em></span>)
                                   .doc("Read out the name of the system.");
       this-&gt;addOperation( "changeParameter", &amp;MyTask::changeParameter, this, <span class="emphasis"><em>OwnThread</em></span>)
                                   .doc("Change a parameter, return the old value.")
                                   .arg("New Value", "The new value for the parameter."); 

       // more additions to follow, see below
     }
     // ...
  };</pre><p>
      </p><p>
	In the above example, we wish to add 3 functions to the
	method interface: reset, getName and changeParameter. You
	need to pass the name of the function, address (function pointer) of this function
	and the object on which it must be called (this) to addOperation. Optionally,
	you may document the operation with .doc("...") and each argument with a .arg() 
	call.
      </p><p>
	Using this mechanism, any method of <span class="emphasis"><em>any</em></span>
	class can be added to a task's method interface, not just functions of a TaskContext 
	You can also add plain C functions, just omit the <span class="emphasis"><em>this</em></span> pointer.
      </p><p>
        As the last argument to addOperation, a flag can be passed which can be <span class="emphasis"><em>OwnThread</em></span>
	or <span class="emphasis"><em>ClientThread</em></span>. This allows the component implementer to choose
	if the operation, when called, is executed in the thread of the ExecutionEngine,
	or in the thread of the caller (i.e. the Client). This choice is hidden from the user
	of our operations. It allows us to choose who gets the burden of the execution of the
	function, but also allows to synchronize operation calls with the execution of
	updateHook(). Summarized in a table:
      </p><div class="table"><a id="execution-types-table"></a><p class="title"><strong>Table 2.1. Execution Types</strong></p><div class="table-contents"><table summary="Execution Types" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>ExecutionType</th><th>Requires locks in your component?</th><th>Executed at priority of</th><th>Examples</th></tr></thead><tbody><tr><td>ClientThread</td><td>Yes. For any data shared between the ClientThread-tagged operation and updateHook() or other operations.</td><td>Caller thread</td><td><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Stateless algorithms that get all data through parameters.</p></li><li class="listitem"><p>Operations of real-time components that are not real-time.</p></li><li class="listitem"><p>getName(), loadProperties("file.xml"), ... </p></li></ul></div>
		</td></tr><tr><td>OwnThread</td><td>No. Every OwnThread-tagged operation and updateHook() is executed in the thread of the component.</td><td>Component thread.</td><td><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Operations that do a lot of setup work in the component.</p></li><li class="listitem"><p>Operations which are called from several places at the same time.</p></li><li class="listitem"><p>moveToPosition(pos, time), setParameter("name", value),...</p></li></ul></div>
		</td></tr></tbody></table></div></div><br class="table-break" /><p>
	  The choice of this type is completely up to the implementor
	  of the component and can be made independently of how it
	  will be used by its clients. Clients can indicate the same
	  choice indepenently: they can Call or Send an
	  operation. This is explained in the next two sections.
	</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525575688960"></a>3.4.1. Call versus Send: the OperationCaller object</h4></div></div></div><p>
	    Operations are added to the TaskContext's inteface. To
	    call an operation from another component, you need a
	    OperationCaller object to do the work for you. It allows to modes:
	    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>calling the operation, in which case you block until the
	    operation returns its value</p></li><li class="listitem"><p>sending the operation, in which case you get a SendHandle
	    back which allows you to follow its status and collect the results.</p></li></ul></div><p>
	    One OperationCaller object always offers both choices, and they can
	    be used both interweaved, as far as the allocation scheme
	    allows it. See <a class="xref" href="#method-allocation" title="3.4.4. Executing methods in real-time.">Section 3.4.4, “Executing methods in real-time.”</a>. 
	    Calling is used by default if you don't specify which mode
	    you want to use.
	  </p><p>
	    Each OperationCaller object is
	    templated with the function signature of the operation you
	    wish to call.  For example 
	    </p><pre class="programlisting">void(int,double)</pre><p>
	    which is the signature of a
	    function returning 'void' and having two arguments: an
	    'int' and a 'double', for example, <code class="function">void foo(int
	    i, double d);</code>.
	  </p><p>
	    To setup a OperationCaller object, you need a pointer to a TaskContext object, for example
	    using the 'getPeer()' class function. Then you provide the
	    name with which the operation was registered during 'addOperation':
	</p><pre class="programlisting">  // create a method:
  TaskContext* a_task_ptr = getPeer("ATask");
  OperationCaller&lt;void(void)&gt; my_reset_meth 
       = a_task_ptr-&gt;getOperation("reset"); // void reset(void)

  // Call 'reset' of a_task:
  reset_meth();  </pre><p>
	If you wanted to send the same reset operation, you had written:
      </p><pre class="programlisting">  // Send 'reset' of a_task:
  SendHandle&lt;void(void)&gt; handle = reset_meth.send();  </pre><p>A send() always returns a SendHandle object which offers three
        methods: <code class="function">collect()</code>, 
	<code class="function">collectIfDone()</code> and <code class="function">ret()</code>.
	All three come in two forms: with arguments or without arguments.
	The form without arguments can be used if you are only interested in
	the return values of these functions. collect() and collectIfDone()
	return a SendStatus, ret() returns the return value of the operation.
	SendStatus is an enum of SendSuccess, SendNotReady or SendFailure.
	Code says it all:
      </p><pre class="programlisting">  // Send 'reset' of a_task:
  SendHandle&lt;void(void)&gt; handle = reset_meth.send();  

  // polling for reset() to complete:
  while (handle.collectIfDone() == SendNotReady )
      sleep(1);

  // blocking for reset() to complete:
  handle = reset_meth.send();
  SendStatus ss = handle.collect();
  if (ss != SendSuccess) {
      cout &lt;&lt; "Execution of reset failed." &lt;&lt; endl;
  }

  // retrieving the return value is not possible for a void(void) method. </pre><p>
	Next we move on to methods with arguments and return values by using
	the getName and changeParameter operations:
      </p><pre class="programlisting">  // used to hold the return value of getName:
  string name;
  OperationCaller&lt;string(void)&gt; name_meth = 
    a_task_ptr-&gt;getOperation("getName"); // string getName(void)

  // Call 'getName' of a_task:
  name = name_meth();
  // Equivalent to:
  name = name_meth.call();

  cout &lt;&lt; "Name was: " &lt;&lt; name &lt;&lt; endl; 

  // Send 'getName' to a_task:
  SendHandle&lt;string(void)&gt; nhandle = name.send();

  // collect takes the return value of getName() as first argument and fills it in:
  SendStatus ss = nhandle.collect(name);
  if (ss == SendSuccess) {
    cout &lt;&lt; "Name was: " &lt;&lt; name &lt;&lt; endl; 
  }

  assert( name == nhandle.ret() ); // ret() returns the same as getName() returned. 

  // hold return value of changeParameter:
  double oldvalue;
  OperationCaller&lt;double(double)&gt; mychange =
      a_task_ptr-&gt;getOperation("changeParameter"); // double changeParameter(double)

  // Call 'changeParameter' of a_task with argument '1.0'
  oldvalue = mychange( 1.0 );
  // Equivalent to:
  oldvalue = mychange.call( 1.0 );

  // Send 'changeParameter' to a_task:
  SendHandle&lt;double(double)&gt; chandle = changeParameter.send( 2.0 )

  SendStatus ss = chandle.collectIfDone( oldvalue );
  if (ss == SendSuccess) {
      cout &lt;&lt; "Oldvalue was: " &lt;&lt; oldvalue &lt;&lt; endl;
  }  </pre><p>
	 Up to 4 arguments can be given to send or call. If the signature of the OperationCaller was
	 not correct, the method invocation will be throw.
	 One can check validity of a method object with the
	 'ready()' function:
       </p><pre class="programlisting">  OperationCaller&lt;double(double)&gt; mychange = ...;
  assert( mychange.ready() );</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525575707792"></a>3.4.2. Calling/Sending Operations in Scripts</h4></div></div></div><p>
	  The syntax in scripts is the same as in C++:</p><p>
	</p><pre class="programlisting"> // call:
  var double oldvalue
  ATask.changeParameter( 0.1 )
  // or :
  set oldvalue = ATask.changeParameter( 0.1 ) // store return value 

  // send:
  var SendHandle handle;
  var SendStatus ss;
  handle = ATask.changeParameter.send( 2.0 );

  // collect non-blocking:
  while ( handle.collectIfDone( oldvalue ) ) 
     yield // see text below.
   
  // collect blocking:
  handle.collect( oldvalue ); // see text below.
</pre><p> There is an important difference between collect()
	   and collectIfDone() in scripts. collect() will block your
	   whole script, so also other scripts executed in the ExecutionEngine
	   and updateHook(). The only exception is that incomming
	   operations are still processed, such that call-backs are allowed.
	   For example: if ATask.changeParameter( 0.1 ) does in turn a send on your component,
	   this will be processed such that no dead-lock occurs.</p><p>
	   If you do not wish to block unconditionally on the completion
	   of changeParameter(), you can poll with collectIfDone(). Each time
	   the poll fails, you issue a yield (in RTT 1.x this was 'do nothing').
	   Yield causes temporary suspension of your script, such that other scripts
	   and updateHook() get a chance to run. In the next trigger
	   of your component, the program resumes and the while loop checks
	   the collectIfDone() statement again.
	 </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525575712336"></a>3.4.3. Overview: Who's executing the operation ?</h4></div></div></div><p>
	   Considering all the combinations above, 4 cases can occur:   
	 </p><div class="table"><a id="calling-combination-table"></a><p class="title"><strong>Table 2.2. Call/Send and ClientThread/OwnThread Combinations</strong></p><div class="table-contents"><table summary="Call/Send and ClientThread/OwnThread Combinations" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>OperationCaller-v \ Operation-&gt;</th><th>ClientThread</th><th>OwnThread</th></tr></thead><tbody><tr><td>Call</td><td>Executed directly by the thread that does the call()</td><td>Executed by the ExecutionEngine of the receiving component.</td></tr><tr><td>Send</td><td>Executed by the GlobalExecutionEngine. See text below.</td><td>Executed by the ExecutionEngine of the receiving component.</td></tr></tbody></table></div></div><br class="table-break" /><p>
	  This matrix shows a special case: when the client does a send() and 
	  the component defined the operation as 'ClientThread', someone else
	  needs to execute it. That's the job of the GlobalExecutionEngine.
	  Since no thread wishes to carry the burden of executing this function,
	  the GlobalExecutionEngine, which runs with the lowest priority thread in the system, 
	  picks it up.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="method-allocation"></a>3.4.4. Executing methods in real-time.</h4></div></div></div><p>
	   Calling or sending a method has a cost in terms of memory.
	   The implementations needs to allocate memory to collect the 
	   return values when a send or call is done. There are two ways
	   to claim memory: by using a real-time memory allocator or by
	   setting a fixed amount in the OperationCaller object in advance. The
	   default is using the real-time memory allocator. For mission
	   critical code, you can override this with a reserved amount,
	   which will be guaranteed always available for that object.
	 </p><p>
	   (to be completed).
	 </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="method-args-types"></a>3.4.5. Operation Argument and Return Types</h4></div></div></div><p>
	The arguments can be of any class type and type qualifier
	(const, &amp;, *,...). However, to be compatible with inter-process
	communication or the Orocos Scripting variables, it is best to follow the
	following guidelines :
	</p><div class="table"><a id="method-args-table"></a><p class="title"><strong>Table 2.3. Operation Return &amp; Argument Types</strong></p><div class="table-contents"><table summary="Operation Return &amp; Argument Types" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>C++ Type</th><th>In C++ functions passed by</th><th>Maps to Parser variable type</th></tr></thead><tbody><tr><td>Primitive C types : double, int, bool, char</td><td><span class="emphasis"><em>value</em></span> or reference</td><td>double, int, bool, char</td></tr><tr><td>C++ Container types : std::string, std::vector&lt;double&gt;</td><td><span class="emphasis"><em>(const) &amp;</em></span></td><td>string, array</td></tr><tr><td>Orocos Fixed Container types : RTT::Double6D, KDL::[Frame | Rotation | Twist | ... ]</td><td><span class="emphasis"><em>(const) &amp;</em></span></td><td>double6d, frame, rotation, twist, ...</td></tr></tbody></table></div></div><p><br class="table-break" />
      </p><p>
	Summarised, every non-class argument is best passed by value,
	and every class type is best passed by const reference. The parser
	does handle references (&amp;) in the arguments or return type as well.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="task-attr-rep"></a>3.5. The Attributes and Properties Interface</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Purpose"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Purpose</th></tr><tr><td align="left" valign="top"><p>A task's
      properties are intended to configure and tune a task with
      certain values. Properties have the advantage of being writable
      to an XML format, hence can store 'persistent' state.  For
      example, a control parameter. Attributes reflect a C++ class variable in
      the interface and can be read and written during run-time
      by a program script, having the same data as if it was a C++ function.
      </p><p>
	Reading and writing properties and attributes is real-time but
	not thread-safe and should for a <span class="emphasis"><em>running</em></span>
	component be limited to the task's own activity.
      </p></td></tr></table></div><p>
      A TaskContext may have any number of attributes or properties,
      of any type. They can be used by programs in the
      TaskContext to get (and set) configuration data.
      The task allows to store any C++ value type and
      also knows how to handle Property objects. Attributes are plain
      variables, while properties can be written to and updated from an XML file.
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525578953584"></a>3.5.1. Adding Task Attributes or Properties</h4></div></div></div><p>
	An attribute can be added in the comonent's interface
	(<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1ConfigurationInterface.html">ConfigurationInterface</a>) like this :</p><p>
	</p><pre class="programlisting">  #include &lt;rtt/Property.hpp&gt;
  #include &lt;rtt/Attribute.hpp&gt;

  class MyTask
    : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
     // we will expose these:
     bool aflag;
     int max;

     double pi;

     std::string param;
     double value;
  public:
    // ...
    MyTask(std::string name)
      : <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>(name),
        param("The String"),
        value( 1.23 ),
        aflag(false), max(5), pi(3.14)
    {
       // other code here...

       // attributes and constants don't take a .doc() description.
       this-&gt;addAttribute( "aflag", aflag );
       this-&gt;addAttribute( "max", max );
      
       this-&gt;addConstant( "pi", pi );

       this-&gt;addProperty( "Param", param ).doc("Param Description");
       this-&gt;addProperty( "Palue", value ).doc("Value Description");
     }
     // ...
  };
</pre><p>
	Which aliases an attribute of type bool and int, name 'aflag' and 'max' and initial
	value of false and 5 to the task's interface. A constant alias 'pi' is added as well.
	These methods return false if an attribute with that name already exists.
	Adding a Property is also straightforward. The property is added in a 
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1PropertyBag.html">PropertyBag</a>.
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525578958784"></a>3.5.2. Accessing Task Attributes or Properties in C++</h4></div></div></div><p>
	An attribute is used in your C++ code transparantly. For properties, you
	need their set() and get() methods to write and read them.
      </p><p>
	A external task can access attributes through an Attribute object and the getValue method:
    </p><pre class="programlisting">  Attribute&lt;bool&gt; the_flag = a_task-&gt;getValue("aflag");
  assert( the_flag.ready() );

  bool result = the_flag.get();
  assert( result == false );

  Attribute&lt;int&gt; the_max = a_task-&gt;attributes()-&gt;getAttribute("max");
  assert( the_max.ready() );
  the_max.set( 10 );
  assert( the_max.get() == 10 );</pre><p>
  The attributes 'the_flag' and 'the_max' are mirrors of the
  original attributes of the task.
      </p><p>
	See also <a class="xref" href="#corelib-properties" title="6. Properties">Section 6, “Properties”</a> in
	the Orocos CoreLib reference.
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525578962528"></a>3.5.3. Accessing Task Attributes in Scripts</h4></div></div></div><p>
	A program script can access the above attributes simply by naming them:</p><p>
	</p><pre class="programlisting">  // a program in "ATask" does :
  var double pi2 = pi * 2.
  var int    myMax = 3
  set max = myMax

  set Param = "B Value"</pre><p>
	</p><pre class="programlisting">  // an external (peer task) program does :
  var double pi2 = ATask.pi * 2.
  var int    myMax = 3
  set ATask.max = myMax	</pre><p>
	When trying to assign a value to a constant, the script parser
	will throw an exception, thus before the program is run.
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>
	  The same restrictions of <a class="xref" href="#method-args-types" title="3.4.5. Operation Argument and Return Types">Section 3.4.5, “Operation Argument and Return Types”</a> hold for
	  the attribute types, when you want to access them from program scripts.
	</p></td></tr></table></div><p>
	See also <a class="xref" href="#corelib-attributes" title="5. Attributes">Section 5, “Attributes”</a> in
	the Orocos CoreLib reference.
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525578968336"></a>3.5.4. Reading and writing Task Properties from XML</h4></div></div></div><p>
	See <a class="xref" href="#task-property-config" title="6.1. Task Property Configuration and XML format">Section 6.1, “Task Property Configuration and XML format”</a> for storing and loading
	the Properties to and from files, in order to store a TaskContext's state.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525578970240"></a>3.6. A TaskContext's Error states</h3></div></div></div><p>
	In addition to the <code class="function">PreOperational</code>,
	<code class="function">Stopped</code> and <code class="function">Running</code>
	TaskContext states, you can use two additional states for more
	advanced component behaviour: the <code class="function">Exception</code>, <code class="function">FatalError</code>
	and the <code class="function">RunTimeError</code> states. The first two are shown in
	<a class="xref" href="#fig-ext-component-states" title="Figure 2.8.  Extended TaskContext State Diagram">Figure 2.8, “
	  Extended TaskContext State Diagram
	”</a>.
      </p><div class="figure"><a id="fig-ext-component-states"></a><p class="title"><strong>Figure 2.8. 
	  Extended TaskContext State Diagram
	</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/ComponentStatesExtended.png" alt="Extended TaskContext State Diagram" /><div class="caption"><p>
	      This figure shows the extended state diagram of a
	      TaskContext.  This is <a class="xref" href="#fig-component-states" title="Figure 2.5.  TaskContext State Diagram">Figure 2.5, “
	TaskContext State Diagram
      ”</a>
	      extended with two more states: <code class="function">Exception</code>
	      and <code class="function">FatalError</code>.
	    </p></div></div></div></div><br class="figure-break" /><p>
	The <code class="function">FatalError</code> state is entered whenever
	the TaskContext's <code class="function">fatal()</code> function is
	called, and indicates that an unrecoverable error occured. 
	The ExecutionEngine is immediately
	stopped and no more functions are called. This state can
	not be left and the only next step is destruction of the component
	(hence 'Fatal').
      </p><p>
	When an exception happens in your code, the <code class="function">Exception</code> state
	is entered. Depending on the TaskState, stopHook() and cleanupHook()
	will be called to give a chance to cleanup. This state is recoverable
	with the <code class="function">recover()</code> function which drops your
	component back to the <code class="function">PreOperational</code> state,
	from which it needs to be configured again.
      </p><p>
	It is possible that non-fatal run-time errors occur which
	may require user action on one hand, but do not prevent
	the component from performing it's task, or allow degraded
	performance.
	Therefor, in the <code class="function">Running</code> state, one can
	make a transition to the<code class="function">RunTimeError</code>
	sub-state by calling <code class="function">error()</code>. See
	<a class="xref" href="#fig-ext-runtime-states" title="Figure 2.9.  Possible Run-Time failure.">Figure 2.9, “
	  Possible Run-Time failure.
	”</a>.
      </p><div class="figure"><a id="fig-ext-runtime-states"></a><p class="title"><strong>Figure 2.9. 
	  Possible Run-Time failure.
	</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/RunTimeStates.png" alt="Possible Run-Time failure." /><div class="caption"><p>
	      Th
	    </p></div></div></div></div><br class="figure-break" /><p>
	When the application code calls <code class="function">error()</code>,
	the RunTimeError state is entered and
	<code class="function">errorHook()</code> is executed instead of
	<code class="function">updateHook()</code>.  If at some moment the
	component detects that it can resume normal operation, it
	calls the <code class="function">recover()</code> function, which
	leads to the Running state again and in the next iteration,
	<code class="function">updateHook()</code> is called again.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525578998800"></a>3.6.1. Error States Example</h4></div></div></div><p>
	Here is a very simple use case, a TaskContext communicates over
	a socket with a remote device. Normally, we get a data packet
	every 10ms, but sometimes one may be missing.  When we don't
	receive 5 packets in a row, we signal this as a run time
	error. From the moment packets come in again we go back to the run
	state. Now if the data we get is corrupt, we go into
	fatal error mode, as we have no idea what the current state of
	the remote device is, and shouldn't be updating our state, as
	no one can rely on the correct functioning of the TaskContext.
      </p><p>
	Here's the pseudo code:
	</p><pre class="programlisting"> class MyComponent : public TaskContext
 {
       int faults;
 public:
       MyComponent(const std::string &amp;name) 
         : TaskContext(name), faults(0) 
       {}

 protected:
       // Read data from a buffer.
       // If ok, process data. When to many faults occur,
       // trigger a runtime error.
       void updateHook()
       {
            Data_t data;
            FlowStatus rv = input.read( data );
            if ( rv == NewData ) {
               this-&gt;stateUpdate(data);
               faults = 0;
               this-&gt;recover(); // may be an external supervisor calls this instead.
            } else {
               faults++;
               if (faults &gt; 4)
                   this-&gt;error();
            }

       }

       // Called instead of updateHook() when in runtime error state.
       void errorHook()
       {
            this-&gt;updateHook(); // just call updateHook anyway.
       }

       // Called by updateHook()
       void stateUpdate(Data_t data)
       {
            // Check for corrupt data
            if ( checkData(data) == -1 ) {
                 this-&gt;fatalError(); // we will enter the FatalError state.
            } else {
                 // data is ok: update internal state...
            }
       }
 };</pre><p>
      </p><p>
	When you want to discard the 'error' state of the component,
	call mycomp.recover().  If your component went into
	FatalError, call mycomp.reset() and mycomp.start() again for
	processing updateHook() again.
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="connect-tasks"></a>4. Connecting Services</h2></div></div></div><p>
      A Real-Time system exists of multiple concurrent
      tasks which must communicate to each other.
      TaskContext can be connected to each other
      such that they can use each other's Services.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="connect-peers"></a>4.1. Connecting Peer Components</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	    The <code class="function">addPeer</code> and <code class="function">connectPeers</code>
	    functions are used to connect TaskContexts and allow them
	    to use each other's interface. The <code class="function">connectPorts</code>
	    function sets up the data flow between tasks.
	  </p></td></tr></table></div><p>
	We call connected TaskContexts "Peers" because there is no implied
	hierarchy. A connection from one TaskContext to its
	Peer can be uni- or bi-directional. In a uni-directional connection (<code class="function">addPeer</code> ),
	only one peer can use the services of the other, while
	in a bi-directional connection (<code class="function">connectPeers</code>), both can use
	each others services.
	This allows to build strictly hierarchical topological
	networks as well as complete flat or circular networks or any
	kind of mixed network. 
      </p><p>
	Peers are connected as such (<code class="methodname">hasPeer</code> takes a string 
      argument ):</p><p>
      </p><pre class="programlisting">  // bi-directional :
  connectPeers( &amp;a_task, &amp;b_task );
  assert( a_task.hasPeer( &amp;b_task.getName() ) 
          &amp; b_task.hasPeer( &amp;a_task.getName() ) );

  // uni-directional :
  a_task.addPeer( &amp;c_task );
  assert( a_task.hasPeer( &amp;c_task.getName() ) 
          &amp; ! c_task.hasPeer( &amp;a_task.getName() ) );

  // Access the interface of a Peer:
  OperationCaller&lt;bool(void)&gt; m = a_task.getPeer( "CTask" )-&gt;getOperation("aOperationCaller");
  // etc. See interface usage in previous sections.
</pre><p>
      Both <code class="function">connectPeers</code> and <code class="function">addPeer</code>
      allow scripts or C++ code to use the interface of a connected Peer. <code class="function">connectPeers</code>
      does this connection in both directions.
    </p><p>
      From within a program script, peers can be accessed by
      merely prefixing their name to the member you want to
      access. A program <span class="emphasis"><em>within</em></span> "ATask" could
      access its peers as such :</p><p>
      </p><pre class="programlisting"> // Script:
  var bool result = CTask.aOperation() </pre><p>
      The peer connection graph can be traversed at arbitrary
      depth. Thus you can access your peer's peers.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="setup-data-flow"></a>4.2. Setting up the Data Flow</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	  In typical applications, the DeploymentComponent
	  ('deployer') will form connections between ports using a
	  program script or XML file. The manual method described
	  below is not needed in that case.
	</p></td></tr></table></div><p>
	Data Flow between TaskContexts can be setup by using <code class="function">connectPorts</code>.
	The direction of the data flow is imposed by the input/output direction of
	the ports.  The <code class="function">connectPorts(TaskContext* A, TaskContext* B)</code> function
	creates a connection between TaskContext ports when both ports 
	have the same name and type. It will never disconnect existing connections
	and only tries to add ports to existing connections or create new
	connections. The disadvantage of this approach is that you can not specify
	connection policies.
      </p><p>
	Instead of calling <code class="function">connectPorts</code>, one may connect individual ports,
	such that different named ports can be connected and a connection policy can be set.
	Suppose that Task A has a
	port a_port, Task B a b_port and Task C a c_port (all are of type PortInterface&amp;). Then
	 connections are made as follows:
	</p><pre class="programlisting">  // Create a connection with a buffer of size 10:
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1ConnPolicy.html">ConnPolicy</a> policy = RTT::ConnPolicy::buffer(10);
  a_port.connectTo( &amp;b_port, policy );
  // Create an unbuffered 'shared data' connection:
  policy = RTT::ConnPolicy::data();
  a_port.connectTo( &amp;c_port, policy );</pre><p>
	The order of connections does not matter; the following would also work:
	</p><pre class="programlisting">  b_port.connectTo( &amp;a_port, policy ); // ok...
  c_port.connectTo( &amp;a_port, policy ); // fine too.</pre><p>
        Note that you can not see from this example which port is input and which
	is output. For readability, it is recommended to write it as:
	</p><pre class="programlisting">output_port.connectTo( &amp;input_port );</pre><p>
      </p><p>
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1ConnPolicy.html">ConnPolicy</a> are powerful objects that allow you to
	connect component ports just like you want them. You can use them to create
	connections over networks or to setup fast real-time inter-process communication.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525579035120"></a>4.3. Disconnecting Tasks</h3></div></div></div><p>
      Tasks can be disconnected from a network by invoking
      <code class="function">disconnect()</code> on that task. It will
      inform all its peers that it has left the network and
      disconnect all its ports.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="task-services"></a>5. Providing and Requiring Services</h2></div></div></div><p>
      In the previous sections, we saw that you could add an operation to a
      TaskContext, and retrieve it for use in a OperationCaller object. This manual
      registration and connection process can be automated by using the
      service objects. There are two major players: <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Service.html">Service</a>
      and <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1ServiceRequester.html">ServiceRequester</a>. The
      first manages operations, the second methods. We say that the
      Service <span class="emphasis"><em>provides</em></span> operations, while
      the ServiceRequester <span class="emphasis"><em>requires</em></span> them. The first
      expresses what it can do, the second what it needs from others to do.
    </p><p>
      Here's a simple use case for two components:
    </p><div class="example"><a id="idp46525579040768"></a><p class="title"><strong>Example 2.1. Setting up a Service</strong></p><div class="example-contents"><p>The only difference between setting up a service and
      adding an operation, is by adding provides("servicename")
      in front of addOperation.
    </p><pre class="programlisting">   #include &lt;rtt/TaskContext.hpp&gt;
  #include &lt;iostream&gt;

  class MyServer : public RTT::TaskContext {
  public:
    MyServer() : TaskContext("server") {
       this-&gt;<span class="emphasis"><em>provides("display")</em></span>
             -&gt;addOperation("showErrorMsg", &amp;MyServer::showErrorMsg, this, RTT::OwnThread)
                   .doc("Shows an error on the display.")
                   .arg("code", "The error code")
                   .arg("msg","An error message");
       this-&gt;<span class="emphasis"><em>provides("display")</em></span>
             -&gt;addOperation("clearErrors", &amp;MyServer::clearErrors, this, RTT::OwnThread)
                   .doc("Clears any error on the display.");
    }
    void showErrorMsg(int code, std::string msg) {
       std::cout &lt;&lt; "Code: "&lt;&lt;code&lt;&lt;" - Message: "&lt;&lt; msg &lt;&lt;std::endl;
    }
    void clearErrors() {
       std::cout &lt;&lt; "No errors present." &lt;&lt; std::endl;
    }
  };
    </pre></div></div><br class="example-break" /><p>
       What the above code does is grouping operations in an interface that is provided
       by this component. We give this interface a name, 'display' in order to allow
       another component to find it by name. Here's an example on how to use this service:
    </p><div class="example"><a id="idp46525579044896"></a><p class="title"><strong>Example 2.2. Using a Service</strong></p><div class="example-contents"><p>The only difference between setting up a service and
      adding a OperationCaller object, is by adding requires("servicename")
      in front of addOperationCaller.
    </p><pre class="programlisting">   #include &lt;rtt/TaskContext.hpp&gt;
  #include &lt;iostream&gt;

  class MyClient : public RTT::TaskContext {
  public:
    int counter;
    OperationCaller&lt;void(int,std::string)&gt; showErrorMsg;
    OperationCaller&lt;void(void)&gt; clearErrors;

    MyClient() : TaskContext("client"), counter(0),
       showErrorMsg("showErrorMsg"), clearErrors("clearErrors")
    {
       this-&gt;<span class="emphasis"><em>requires("display")</em></span>
             -&gt;addOperationCaller(showErrorMsg);
       this-&gt;<span class="emphasis"><em>requires("display")</em></span>
             -&gt;addOperationCaller(clearErrors);
       this-&gt;setPeriod(0.1);
    }
    bool configureHook() {
       return this-&gt;requires("display")-&gt;ready();
    }

    void updateHook() {
        if (counter == 10) {
           showErrorMsg.send(101, "Counter too large!");
        }
        if (counter == 20) {
           clearErrors.send();
           counter = 0;
        }
        ++counter;
     }
  };</pre></div></div><br class="example-break" /><p> What you're seeing is this: the client has 2 OperationCaller objects
      for calling the functions in the "display" service. The method objects
      must have the same name as defined in the 'provides' lines in the previous
      listing. We check in configureHook if this interface is ready to be called.
      Update hook then calls these methods.</p><p> The remaining question is now: how is the connection done from client to
      server ? The <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1ServiceRequester.html">ServiceRequester</a> has a method 
      <code class="function">connectTo(Service*)</code> which does this connection from
      OperationCaller object to operation. If you wanted to hardcode this, it would look like:
      </p><pre class="programlisting">  bool configureHook() {
     requires("display")-&gt;connectTo( getPeer("server")-&gt;provides("display") );
     return requires("display")-&gt;ready();
  }</pre><p>
      In practice, you will use the deployer application to do the connection for
      you at run-time. See the DeploymentComponent documentation for the syntax.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="run-tasks"></a>6. Using Tasks</h2></div></div></div><p>
      This section elaborates on the interface all Task Contexts have
      from a 'Task user' perspective.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="task-property-config"></a>6.1. Task Property Configuration and XML format</h3></div></div></div><p>
	As was seen in <a class="xref" href="#task-attr-rep" title="3.5. The Attributes and Properties Interface">Section 3.5, “The Attributes and Properties Interface”</a>,
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Property.html">Property</a> objects can be
	added to a task's interface. To read and write properties from
	or to files, you can use the
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Marshalling.html">Marshalling</a> service.
	It creates or reads files in the XML Component
	Property Format such that it is human readable and modifiable.
      </p><pre class="programlisting">  // ...
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>* a_task = ...
            mname = ab-&gt;getName();
            mname = ab-&gt;getName();
  a_task-&gt;getProvider&lt;Marshalling&gt;("marshalling")-&gt;readProperties( "PropertyFile.cpf" );
  // ...
  a_task-&gt;getProvider&lt;Marshalling&gt;("marshalling")-&gt;writeProperties( "PropertyFile.cpf" ); </pre><p>
	 In order to access a service, we need both the type of the provider, <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Marshalling.html">Marshalling</a>
	 and the run-time name of the service, by default "marshalling".
       </p><p>
	 In the example, <code class="function">readProperties()</code> reads the file and updates the
	 task's properties and <code class="function">writeProperties()</code> writes the
	 given file with the properties of the task. Other functions allow to
	 share a single file with multiple tasks or update the task's
	 properties from multiple files.
       </p><p>
	 The PropertyFile.cpf file syntax can be easily learnt by
	 using <code class="function">writeProperties()</code> and looking at
	 the contents of the file. It will contain elements for each
	 Property or PropertyBag in your task.  Below is a
	 component with five properties. There are three properties at
	 the top level of which one is a PropertyBag, holding two
	 other properties.
       </p><p>
	</p><pre class="programlisting">  #include &lt;rtt/TaskContext.hpp&gt;
#include &lt;rtt/Property.hpp&gt;
#include &lt;rtt/PropertyBag.hpp&gt;

  class MyTask
    : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
     
     int i_param;
     double d_param;
     <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1PropertyBag.html">PropertyBag</a> sub_bag;
     std::string s_param;
     bool b_param;
  public:
    // ...
    MyTask(std::string name)
      : <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>(name),
        i_param(5 ),
        d_param(-3.0),
        s_param("The String"),
        b_param(false)
    {
       // other code here...

       this-&gt;addProperty("IParam", i_param ).doc("Param Description");
       this-&gt;addProperty("DParam", d_param ).doc("Param Description");
       this-&gt;addProperty("SubBag", sub_bag ).doc("SubBag Description");

       // we call addProperty on the PropertyBag object in order to 
       // create a hierarchy
       sub_bag.addProperty("SParam", s_param ).doc("Param Description");
       sub_bag.addProperty("BParam", b_param ).doc("Param Description");
     }
     // ...
  };
</pre><p>
         Using writeProperties() would produce the following XML file:
      </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE properties SYSTEM "cpf.dtd"&gt;
&lt;properties&gt;

  &lt;simple name="IParam" type="short"&gt;
    &lt;description&gt;Param Description&lt;/description&gt;
    &lt;value&gt;5&lt;/value&gt;
    &lt;/simple&gt;
  &lt;simple name="DParam" type="double"&gt;
    &lt;description&gt;Param Description&lt;/description&gt;
    &lt;value&gt;-3.0&lt;/value&gt;
  &lt;/simple&gt;

  &lt;struct name="SubBag" type="PropertyBag"&gt;
    &lt;description&gt;SubBag Description&lt;/description&gt;
    &lt;simple name="SParam" type="string"&gt;
      &lt;description&gt;Param Description&lt;/description&gt;
      &lt;value&gt;The String&lt;/value&gt;
    &lt;/simple&gt;
    &lt;simple name="BParam" type="boolean"&gt;
      &lt;description&gt;Param Description&lt;/description&gt;
      &lt;value&gt;0&lt;/value&gt;
    &lt;/simple&gt;
  &lt;/struct&gt;

&lt;/properties&gt;</pre><p> PropertyBags (nested properties) are represented as
        &lt;struct&gt; elements in this format. A &lt;struct&gt; can contain
	another &lt;struct&gt; or a &lt;simple&gt; property.
      </p><p>
	The following table lists the conversion from C++ data types
	to XML Property types.
	</p><div class="table"><a id="property-types-table"></a><p class="title"><strong>Table 2.4. C++ &amp; Property Types</strong></p><div class="table-contents"><table summary="C++ &amp; Property Types" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>C++ Type</th><th>Property type</th><th>Example valid XML &lt;value&gt; contents</th></tr></thead><tbody><tr><td>double</td><td>double</td><td>3.0</td></tr><tr><td>int</td><td><span class="emphasis"><em>short or long</em></span></td><td>-2</td></tr><tr><td>bool</td><td><span class="emphasis"><em>boolean</em></span></td><td><span class="emphasis"><em>1 or 0</em></span></td></tr><tr><td>float</td><td>float</td><td>15.0</td></tr><tr><td>char</td><td>char</td><td>c</td></tr><tr><td>std::string</td><td>string</td><td>Hello World</td></tr><tr><td>unsigned int</td><td><span class="emphasis"><em>ulong or ushort</em></span></td><td>4</td></tr></tbody></table></div></div><p><br class="table-break" />
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525579082448"></a>6.2. Task Scripts</h3></div></div></div><p>
	Orocos supports two types of scripts:
	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>An Orocos Program Script (ops) contains a <span class="emphasis"><em>Real-Time</em></span>
	  functional program which calls methods and sends commands to
	  tasks, depending on classical functional logic.</p></li><li class="listitem"><p> An Orocos State machine Description (osd)
	  script contains a <span class="emphasis"><em>Real-Time</em></span> (hierarchical)
	  state machine which dictates which program script snippets
	  are executed upon which event.  </p></li></ul></div><p>
	Both are loaded at run-time into a task. The scripts are parsed
	to an object tree, which can then be executed by the
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> of a
	task.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="task-context-programs"></a>6.2.1. Program Scripts</h4></div></div></div><p>
	  Program can be finely controlled once loaded in
	  the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Scripting.html">Scripting</a> service,
	  which delegates the execution of the script to the
	  ExecutionEngine.
	  A program can be paused, it's variables inspected
	  and reset while it is loaded in the Processor.
	  A simple program script can look like :</p><p>
	  </p><pre class="programlisting">  program foo
  {
    var int i = 1
    var double j = 2.0
    changeParameter(i,j)
  }</pre><p>
	  Any number of programs may be listed in a file.
	</p><p>
	  Orocos Programs are loaded as such into a TaskContext
	  :</p><p>
	  </p><pre class="programlisting">  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>* a_task = ...

  a_task-&gt;getProvider&lt;Scripting&gt;("scripting")-&gt;loadPrograms( "ProgramBar.ops" ); </pre><p>
	  When the Program is loaded in the Task Context, it can
	  also be controlled from other scripts or a TaskBrowser. Assuming
	  you have loaded a Program with the name 'foo', the
	  following commands are available :
	</p><pre class="screen">
  foo.start()
  foo.pause()
  foo.step()
  foo.stop()
	</pre><p>While you also can inspect its status :</p><pre class="screen">
  var bool ret
  ret = foo.isRunning()
  ret = foo.inError()
  ret = foo.isPaused()
	</pre><p>You can also inspect and change the variables of a loaded program,
	but as in any application, this should only be done
	for debugging purposes.</p><pre class="screen">
  set foo.i = 3
  var double oldj = foo.j
	</pre><p>
	  Program scripts can also be controlled in C++, but only from the
	  component having them, because we need access to the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1scripting_1_1ScriptingService.html">ScriptingService</a>
	  object, which is only available locally to the component.
	  Take a look at the
	  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1scripting_1_1ProgramInterface.html">ProgramInterface</a> class
	  reference for more program related functions. One can
	  get a pointer to a program by calling:
	</p><pre class="programlisting">  scripting::ScriptingService* sa = dynamic_cast&lt;scripting::ScriptingService*&gt;(this-&gt;getService("scripting"));
  scripting::ProgramInterface* foo = sa-&gt;getProgram("foo");
  if (foo != 0) {
    bool result = foo-&gt;start(); // try to start the program !
    if (result == false) {
       // Program could not be started.
       // Execution Engine not running ?
    }
  }</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525579097808"></a>6.2.2. State Machines</h4></div></div></div><p>
	  Hierarchical state machines are modelled in Orocos
	  with the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1scripting_1_1StateMachine.html">StateMachine</a> class.
	  They are like programs in that they can call a
	  peer task's members, but the calls are grouped
	  in a state and only executed when the state machine
	  is in that state. This section limits to showing
	  how an Orocos State Description (osd) script can be loaded in a 
	  Task Context.
	</p><p>
	  </p><pre class="programlisting">  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>* a_task = ...

  a_task-&gt;getProvider&lt;Scripting&gt;("scripting")-&gt;loadStateMachines( "StateMachineBar.osd" ); </pre><p>
	  When the State Machine is loaded in the Task Context, it can
	  also be controlled from your scripts or TaskBrowser. Assuming
	  you have instantiated a State Machine with the name 'machine', the
	  following commands are available :
	</p><pre class="screen">
  machine.activate()
  machine.start()
  machine.pause()
  machine.step()
  machine.stop()
  machine.deactivate()
  machine.reset()
  machine.reactive()
  machine.automatic() // identical to start()
  machine.requestState("StateName")
	</pre><p>As with programs, you can inspect and change the
	variables of a loaded StateMachine.</p><pre class="screen">
  set machine.myParam = ...
	</pre><p>
	  The Scripting Manual goes in great detail on how to 
	  construct and control State Machines.
	</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525579104384"></a>7. Deploying Components</h2></div></div></div><p>
      An Orocos component can be used in both embedded (&lt;1MB RAM) or
      big systems (128MB RAM), depending on how it is created or used.
      This is called <span class="emphasis"><em>Component Deployment</em></span> as the
      target receives one or more component implementations. The components
      must be adapted as such that they fit the target.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525579106128"></a>7.1. Overview</h3></div></div></div><p>
	<a class="xref" href="#fig-comp-levels" title="Figure 2.10.  Component Deployment Levels">Figure 2.10, “
	  Component Deployment Levels
	”</a> shows the
	distinction between the three levels of Component Deployment.
      </p><div class="figure"><a id="fig-comp-levels"></a><p class="title"><strong>Figure 2.10. 
	  Component Deployment Levels
	</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/DeploymentLevels.png" alt="Component Deployment Levels" /><div class="caption"><p>
	      Three levels of using or creating Components can be
	      accomplished in Orocos: Not distributed, embedded distributed
	      and fully distributed.
	    </p></div></div></div></div><br class="figure-break" /><p>
	If your application will not use distributed components and
	requires a very small footprint, the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1TaskCore.html">TaskCore</a>
	can be used. The Orocos primitives appear publicly in the interface
	and are called upon in a hard-coded way.
      </p><p>
	If you application requires a small footprint and distributed
	components, the <span class="emphasis"><em>C++ Interface</em></span> of the
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a> can be used in
	combination with a <span class="emphasis"><em>Distribution Library</em></span>
	which does the network translation. It handles a predefined
	set of data types (mostly the 'C' types) and needs to be
	adapted if other data types need to be supported. There is no
	portable distribution library available.
      </p><p>
	If footprint is of no concern to your application and you
	want to distribute any component completely transparently,
	the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a> can be used in combination
        with a <span class="emphasis"><em>Remoting Library</em></span> which does the
        network translation. A CORBA implementation of such a library is
	being developed on. It is a write-once, use-many implementation,
	which can pick up user defined types, without requiring modifications.
	It uses the <span class="emphasis"><em>Orocos Type System</em></span> to manage user 
	defined types. 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525579117984"></a>7.2. Embedded TaskCore Deployment</h3></div></div></div><p>
	A TaskCore is nothing more than a place holder for the
	Execution Engine and application code functions
	(<code class="function">configureHook()</code>, <code class="function">cleanupHook()</code>,
	<code class="function">startHook()</code>, <code class="function">updateHook()</code>
	and <code class="function">stopHook()</code> ). The Component
	interface is built up by placing the Orocos primitives
	as public class members in a TaskCore subclass. Each
	component that wants to use this TaskCore must get a
	'hard coded' pointer to it (or the interface it implements)
	and invoke the command, method etc. Since Orocos is by
	no means informed of the TaskCore's interface, it can not
	distribute a TaskCore.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525579122784"></a>7.3. Embedded TaskContext Deployment: C++ Interface</h3></div></div></div><p>
	Instead of putting the Orocos primitives in the public
	interface of a subclass of TaskCore, one can subclass a
	TaskContext and register the primitives to the
	<span class="emphasis"><em>Local C++ Interface</em></span>. This is a reduced
	interface of the TaskContext, which allows distribution
	by the use of a <span class="emphasis"><em>Distribution Library</em></span>.
      </p><p>
	The process goes as such: A component inherits from
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a> and has some
	Orocos primitives as class members. Instead of calling:
      </p><pre class="programlisting">  this-&gt;add<span class="emphasis"><em>Operation</em></span>("name", &amp;foo).doc("Description").arg("Arg1","Arg1 Description");</pre><p>
	and providing a description for the primitive as well as
	each argument, one writes:
      </p><pre class="programlisting">  this-&gt;add<span class="emphasis"><em>LocalOperation</em></span>("name", &amp;foo );</pre><p>
	This functions does no more than a pointer registration, but already allows
	all C++ code in the same process space to use the added primitive.
      </p><p>
	In order to access the interface of such a Component,
	the user code may use:
      </p><pre class="programlisting">  taskA-&gt;get<span class="emphasis"><em>LocalOperation</em></span>("name");</pre><p>
	You can only distribute this component if an implementation of a
	Distribution Library is present. The specification of
	this library, and the application setup is in left to another
	design document.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525579131104"></a>7.4. Full TaskContext Deployment: Dynamic Interface</h3></div></div></div><p>
	In case you are building your components as instructed in this
	manual, your component is ready for distribution as-is, given
	a Remoting library is used. The Orocos CORBA package implements
	such a Remoting library. 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525579132496"></a>7.5. Putting it together</h3></div></div></div><p>
	Using the three levels of deployment in one application is
	possible as well. To save space or execution efficiency,
	one can use TaskCores to implement local (hidden) functionality
	and export publicly visible interface using a TaskContext.
	<a class="xref" href="#fig-deployment-example" title="Figure 2.11.  Example Component Deployment.">Figure 2.11, “
	  Example Component Deployment.
	”</a> is an
	small example of a TaskContext which uses two TaskCores to
	delegate work to. The Execution Engines may run in one or
	multiple threads.
      </p><div class="figure"><a id="fig-deployment-example"></a><p class="title"><strong>Figure 2.11. 
	  Example Component Deployment.
	</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/CoreVsContext.png" alt="Example Component Deployment." /><div class="caption"><p>
	    </p></div></div></div></div><br class="figure-break" /></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525579139680"></a>8. Advanced Techniques</h2></div></div></div><p>
      If you master the above methods of setting up tasks, this section
      gives some advanced uses for integrating your existing application
      framework in Orocos Tasks.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525579145984"></a>8.1. Polymorphism : Task Interfaces</h3></div></div></div><p>
	Most projects have define their own task interfaces in C++.
	Assume you have a class with the following interface :
      </p><pre class="programlisting">
  class DeviceInterface
  {
  public:
    /**
     * Set/Get a parameter. Returns false if parameter is read-only.
     */
    virtual bool setParameter(int parnr, double value) = 0;
    virtual double getParameter(int parnr) const = 0;

    /**
     * Get the newest data.
     * Return false on error.
     */
    virtual bool updateData() = 0;
    virtual bool updated() const = 0;

    /**
     * Get Errors if any.
     */
    virtual int getError() const = 0;
  };</pre><p>
	Now suppose you want to do make this interface available,
	such that program scripts of other tasks can access this 
	interface. Because you have many devices, you surely want
	all of them to be accessed transparently from a supervising
	task. Luckily for you, C++ polymorphism can be transparently
	adopted in Orocos TaskContexts. This is how it goes.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525579149024"></a>8.1.1. Step 1 : Export the interface</h4></div></div></div><p>We construct a TaskContext, which exports your
	C++ interface to a task's interface.
	</p><pre class="programlisting">
  #include &lt;rtt/TaskContext.hpp&gt;
  #include &lt;rtt/Operation.hpp&gt;
  #include "DeviceInterface.hpp"

  class TaskDeviceInterface
    : public DeviceInterface,
      public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>
  {
  public:
      TaskDeviceInterface()
        : <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>( "DeviceInterface" )
      {
         this-&gt;setup();
      }

      void setup() 
      {
         // Add client thread operations :
         this-&gt;addOperation("setParameter",
                    &amp;DeviceInterface::setParameter, this, ClientThread)
                        .doc("Set a device parameter.")
	                .arg("Parameter", "The number of the parameter.")
	                .arg("New Value", "The new value for the parameter."); 

         this-&gt;addOperation("getParameter",
                     &amp;DeviceInterface::getParameter, this, ClientThread)
                          .doc("Get a device parameter.")
                          .arg("Parameter", "The number of the parameter.");
         this-&gt;addOperation("getError",
                     &amp;DeviceInterface::getError, this, ClientThread)
                          .doc("Get device error status.");

         // Add own thread operations :
         this-&gt;addOperation("updateData",
                          &amp;DeviceInterface::updateData, this, OwnThread)
                              .doc(&amp;DeviceInterface::updated)
                              .arg("Command data acquisition." );
      }
  };</pre><p>
	  The above listing just combines all operations which were introduced
	  in the previous sections. Also note that the TaskContext's name
	  is fixed to "DeviceInterface". This is not obligatory though.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525579153648"></a>8.1.2. Step 2 : Inherit from the new interface</h4></div></div></div><p>Your DeviceInterface implementations now
	  only need to inherit from <code class="classname">TaskDeviceInterface</code>
	  to instantiate a Device TaskContext :
	</p><pre class="programlisting">
  #include "TaskDeviceInterface.hpp"

  class MyDevice_1 
    : public TaskDeviceInterface
  {
  public:

    bool setParameter(int parnr, double value) {
      // ...
    }
    double getParameter(int parnr) const {      // ...
    }
    // etc.
  };
	</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525579156160"></a>8.1.3. Step 3 : Add the task to other tasks</h4></div></div></div><p>
	  The new TaskContext can now be added to other tasks.
	  If needed, an alias can be given such that the
	  peer task knows this task under another name.
	  This allows the user to access different incarnations
	  of the same interface from a task.
	</p><pre class="programlisting">
	  // now add it to the supervising task :
  MyDevice_1 mydev;
  supervisor.addPeer( &amp;mydev, "device" );
	</pre><p>
	  From now on, the "supervisor" task will be able to access
	  "device". If the implementation changes, the same interface
	  can be reused without changing the programs in the supervisor.
	</p><p>
	  A big warning needs to be issued though : if you change a
	  peer at run-time (after parsing programs),
	  you need to reload all the programs, functions,
	  state contexts which use that peer so that they reference
	  the new peer and its C++ implementation.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525579159600"></a>8.1.4. Step 4 : Use the task's interface</h4></div></div></div><p>To make the example complete, here is an example
	script which could run in the supervisor task :
	</p><pre class="programlisting">
  program ControlDevice
  {
     const int par1 = 0
     const int par2 = 1
     device.setParameter(par1, supervisor.par1 )
     device.setParameter(par2, supervisor.par2 )

     while ( device.getError() == 0 ) 
     {
        if ( this.updateDevice("device") == true )
           device.updateData()
     }
     this.handleError("device", device.getError() )
  }</pre><p>To start this program from the TaskBrowser, browse to supervisor
	  and type the command :</p><pre class="screen">
  ControlDevice.start()
	</pre><p>
	  When  the program "ControlDevice" is started,
	  it initialises some parameters from its own attributes.
	  Next, the program goes into a loop and sends updateData commands
	  to the device as long as underlying supervisor (i.e. "this") logic requests
	  an update and no error is reported. This code guarantees that
	  no two updateData commands will intervene each other since the
	  program waits for the commands completion or error.
	  When the device returns
	  an error, the supervisor can then handle the error of the
	  device and restart the program if needed.
	</p><p>
	  The advantages of this program over classical C/C++ functions are :
	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If any error occurs (i.e. a method returns false),
	    the program stops and other programs or state contexts can
	    detect this and take appropriate action.</p></li><li class="listitem"><p>The  "<code class="function">device.updateData()</code>" call waits
	    for completion of the remote operation.</p></li><li class="listitem"><p>While the program waits for <code class="function">updateData()</code>
	      to complete, it does not block other programs, etc within
	      the same TaskContext and thread.
	    </p></li><li class="listitem"><p>
	      There is no need for additional synchronisation primitives
	      between the supervisor and the device since the operations 
	      have the OwnThread execution type. Which leads to :
	    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>The operation is executed at the priority of the device's
		  thread, and not the supervisor's priority.</p></li><li class="listitem"><p>The operation can never corrupt data of the device's thread,
		  since it is <span class="emphasis"><em>serialised</em></span>(executed after)
		  with the programs running in that thread.
		</p></li></ul></div></li></ul></div></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="orocos-scripting"></a>Chapter 3. Orocos RTT Scripting Reference</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#intro">1. Introduction</a></span></dt><dt><span class="section"><a href="#program-syntax-general-concepts">2. General Scripting Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#program-syntax-comments">2.1. Comments</a></span></dt><dt><span class="section"><a href="#program-syntax-identifiers">2.2. Identifiers</a></span></dt><dt><span class="section"><a href="#program-syntax-expressions">2.3. Expressions</a></span></dt><dt><span class="section"><a href="#idp46525581677824">2.4. Parsing and Loading Programs</a></span></dt></dl></dd><dt><span class="section"><a href="#program-syntax">3. Orocos Program Scripts</a></span></dt><dd><dl><dt><span class="section"><a href="#program-semantics">3.1. Program Execution Semantics</a></span></dt><dt><span class="section"><a href="#program-syntax-specifics">3.2. Program Syntax</a></span></dt><dt><span class="section"><a href="#idp46525581730480">3.3. Setting Task Attributes and Properties</a></span></dt><dt><span class="section"><a href="#idp46525581733168">3.4. <span class="symbol">function</span></a></span></dt><dt><span class="section"><a href="#idp46525581741024">3.5. Calling functions</a></span></dt><dt><span class="section"><a href="#idp46525581745056">3.6. <span class="symbol">return</span></a></span></dt><dt><span class="section"><a href="#idp46525581749264">3.7. Waiting : The 'yield' statement</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525581751888">4. Starting and Stopping Programs from scripts</a></span></dt><dt><span class="section"><a href="#idp46525581756608">5. Orocos State Descriptions : The Real-Time State Machine</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525581757312">5.1. Introduction</a></span></dt><dt><span class="section"><a href="#idp46525581759840">5.2. StateMachine Mechanism</a></span></dt><dt><span class="section"><a href="#idp46525581788176">5.3. Parsing and Loading StateMachines</a></span></dt><dt><span class="section"><a href="#idp46525581799664">5.4. Defining StateMachines</a></span></dt><dt><span class="section"><a href="#instantiating">5.5. Instantiating Machines: SubMachines and RootMachines</a></span></dt><dt><span class="section"><a href="#idp46525581871056">5.6. Starting and Stopping StateMachines from scripts</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525581891728">6. Program and State Example</a></span></dt></dl></div><div class="abstract"><p class="title"><strong>Abstract</strong></p><p>
	This document describes the <acronym class="acronym">Orocos</acronym> Real-Time Scripting service
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="intro"></a>1. Introduction</h2></div></div></div><p>
      The <acronym class="acronym">Orocos</acronym> Scripting language allows users of the <acronym class="acronym">Orocos</acronym> system to write
      programs and state machines controlling the system in a
      user-friendly realtime script language.  The advantage of scripting is
      that it is easily extendible and does not need recompilation of
      the main program.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="program-syntax-general-concepts"></a>2. General Scripting Concepts</h2></div></div></div><p>
      Before starting to explain Program Syntax, it is necessary to
      explain some general concepts that are used throughout the
      program syntax.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="program-syntax-comments"></a>2.1. Comments</h3></div></div></div><p>
	  Various sorts of comments are supported in the syntax.  Here
	  is a small listing showing the various syntaxes:
	  </p><pre class="programlisting">
  # A perl-style comment, starting at a '#', and running until
  # the end of the line.
  
  // A C++/Java style comment, starting at '//', and running
  // until the end of the line.
  
  /* A C-style comment, starting at '/*', and running until
     the first closing */ /* Nesting is not allowed, that's
     why I have to start a new comment here :-) 
  */
	  </pre><p>
	  Whitespace is in general ignored, except for the fact that it
	  is used to separate tokens.
	</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="program-syntax-identifiers"></a>2.2. Identifiers</h3></div></div></div><p>
	  Identifiers are names that the user can assign to variables,
	  constants, aliases, labels.  The same identifier can only be
	  used once, except that for labels you can use an identifier
	  that has already been used as a variable, constant or alias.
	  However, this is generally a bad idea, and you shouldn't do
	  it.
	</p><p>
	  Some words cannot be used as identifiers, because they are
	  reserved by the <acronym class="acronym">Orocos</acronym> Scripting Framework, either for
	  current use, or for future expansions.  These are called
	  keywords.  The current list of reserved keywords is included
	  here:
	  </p><table border="0" summary="Simple list" class="simplelist"><tr><td>alias</td><td>double</td><td>if</td><td>then</td></tr><tr><td>and</td><td>else</td><td>include</td><td>time</td></tr><tr><td>break</td><td>end</td><td>int</td><td>to</td></tr><tr><td>bool</td><td>export</td><td>next</td><td>true</td></tr><tr><td>char</td><td>local</td><td>not</td><td>try</td></tr><tr><td>catch</td><td>false</td><td>or</td><td>uint</td></tr><tr><td>const</td><td>for</td><td>return</td><td>until</td></tr><tr><td>define</td><td>foreach</td><td>set</td><td>var</td></tr><tr><td>do</td><td>global</td><td>string</td><td>while</td></tr></table><p>
	  These, and all variations on the (upper- or lower-) case of
	  each of the letters are reserved, and cannot be used as
	  identifiers. 
	</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="program-syntax-expressions"></a>2.3. Expressions</h3></div></div></div><p>
	  Expressions are a general concept used throughout the Parser
	  system.  Expressions represent values that can be calculated
	  at runtime (like a+b).  They can be used as arguments to
	  functions, conditions and whatmore.  Expressions implicitly
	  are of a certain type, and the Parser system does strong
	  type-checking.  Expressions can be constructed in various
	  ways, that are described below...
	</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525579188592"></a>2.3.1. Literals</h4></div></div></div><p>
	    Literal values of various types are supported: string,
	    int, double, bool.  Boolean literals are either the word
	    "true" or the word "false".  Integer literals are normal,
	    positive or negative integers.  Double literals are C/C++
	    style double-precision floating point literals.  The only
	    difference is that in order for the Parser to be able to
	    see the difference with integers, we require a dot to be
	    present.  String literals are surrounded by double quotes,
	    and can contain all the normal C/C++ style escaped
	    characters.  Here are some examples:
	    </p><pre class="programlisting">
  // a string with some escaped letters:
  "\"OROCOS rocks, \" my mother said..."
  // a normal integer
  -123
  // a double literal
  3.14159265358979
  // and another one..
  1.23e10  	    </pre><p>
  	  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525579191424"></a>2.3.2. Constants, Variables and Aliases</h4></div></div></div><p>
	    Constants, variables and aliases allow you to work with
	    data in an easier way.  A constant is a name which is
	    assigned a value at <span class="emphasis"><em>parse time</em></span>, and
	    keeps that value throughout the rest of the program.  A
	    variable gets its value assigned at
	    <span class="emphasis"><em>runtime</em></span> and can be changed at other
	    places in the program.  An alias does not carry a value,
	    it is defined with an expression, for which it acts as an
	    alias or an <span class="emphasis"><em>abbreviation</em></span> during the
	    rest of the program.  All of them can always be used as
	    expressions.  Here is some code showing how to use them.
	  </p><pre class="programlisting">
  // define a variable of type int, called counter,
  // and give it the initial value 0.
  var int counter = 0
  // add 1 to the counter variable
  counter = counter + 1
  
  // make the name "counterPlusOne" an alias for the
  // expression counter + 1.  After this, using
  // counterPlusOne is completely equivalent to writing
  // counter + 1
  alias int counterPlusOne = counter + 1
  // you can assign an arbitrarily complex expression
  // to an alias
  alias int reallycomplexalias = ( ( counter + 8 ) / 3 )*robot.position

  // define a constant of type double, with name "pi"
  const double pi = 3.14159265358979
  const double pi2 = 2*pi       // ok, pi2 is 6.28...
  const int turn = counter * pi // warning ! turn will be 0 !

  // define a constant at _parse-time_ !
  const totalParams = table.getNbOfParams()</pre><p>
	    Variables, constants and aliases are defined for the
	    following types: bool, int, double, string and array.
	    The Orocos Typekit System allows any application or
	    library to extend these types.
	  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525579196768"></a>2.3.3. Strings and Arrays</h4></div></div></div><p>
	    For convenience, two variable size types have been
	    added to the parser : <span class="type">string</span> and <span class="type">array</span>.
	    They are special because their contents have variable size.
	    For example a string can be empty or contain 10 characters. The
	    same holds for an array, which contains doubles. String and array
	    are thus container types. They are mapped on <span class="type">std::string</span>
	    and <span class="type">std::vector&lt;double&gt;</span>. To access them safely from
	    a task method or command, you need to to pass them by const reference : 
	    <span class="type">const std::string&amp; s</span>, <span class="type">const std::vector&lt;double&gt;&amp; v</span>.
	  </p><p>Container types can be used in two ways : with a predefined
	    capacity (ie the <span class="emphasis"><em>possibility</em></span> to hold N items),
	    or with a free capacity, where capacity is expanded as there is need for it.
	    The former way is necessary for real-time programs, the latter can only be
	    used in non real-time tasks, since it may cause a memory allocation when
	    capacity limits are exceeded. The following table lists all available
	    constructors:
	  </p><div class="table"><a id="idp46525579202160"></a><p class="title"><strong>Table 3.1. array and string constructors</strong></p><div class="table-contents"><table summary="array and string constructors" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Copy Syntax (copy done at run-time)</th><th>Pre-allocate syntax (init done at parse-time)</th><th>Notes</th></tr></thead><tbody><tr><td><pre class="programlisting">var string x = string()</pre></td><td><pre class="programlisting">var string x</pre></td><td>Creates an empty string. (<span class="type">std::string</span>)</td></tr><tr><td><pre class="programlisting">var string x = string("Hello World")</pre></td><td><pre class="programlisting">var string x("Hello World")</pre></td><td>Creates a string with contents "Hello World".</td></tr><tr><td><pre class="programlisting">var array x = array()</pre></td><td><pre class="programlisting">var array x</pre></td><td>Creates an empty array. (<span class="type">std::vector&lt;double&gt;)</span></td></tr><tr><td><pre class="programlisting">var array x = array(10)</pre></td><td><pre class="programlisting">var array x(10)</pre></td><td>Creates an array with 10 elements, all equal to 0.0.</td></tr><tr><td><pre class="programlisting">var array x = array(10, 3.0)</pre></td><td><pre class="programlisting">var array x(10, 3.0)</pre></td><td>Creates an array with 10 elements, all equal to 3.0.</td></tr><tr><td><pre class="programlisting">var array x = array(1.0, 2.0, 3.0)</pre></td><td><pre class="programlisting">var array x(1.0, 2.0, 3.0)</pre></td><td>Creates an array with 3 elements: {1.0, 2.0, 3.0}. Any number of
		arguments may be given.</td></tr></tbody></table></div></div><br class="table-break" /><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/icons/warning.png" /></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>The 'Copy Syntax' syntax leads to not
	real-time scripts because the size is expanded at run-time.  See the examples below. </p></td></tr></table></div><div class="example"><a id="idp46525581662336"></a><p class="title"><strong>Example 3.1. string and array creation</strong></p><div class="example-contents"><pre class="programlisting">  // A free string and free array :
  // applestring is expanded to contain 6 characters (non real-time)
  var string applestring = "apples"

  // values is expanded to contain 15 elements (non real-time)
  var array  values      = array(15)         

  // A fixed string and fixed array :
  var string fixstring(10)  // may contain a string of maximum 10 characters
  
  fixstring  = applestring   // ok, enough capacity
  fixstring  = "0123456789x" // allocates new memory (non real-time).


  var array  fixvalues(10)  // fixvalues pre-allocated 10 elements
  var array  morevalues(20) // arrays are initialised with n doubles of value 0.0 

  fixvalues  = morevalues  // will cause allocation in 'fixvalues'
  morevalues = fixvalues   // ok, morevalues has enough capacity, now contains 10 doubles

  fixvalues  = morevalues  // ok, since morevalues only contains 10 items.

  values     = array(20)   // expand values to contain 20 doubles. (non real-time) 

  var array list(1.0, 2.0, 3.0, 4.0) // list contains {1.0, 2.0, 3.0, 4.0}
  var array biglist;                 // creates an empty array
  biglist = list           // 'biglist' is now equal to 'list' (non real-time)
	  </pre></div></div><br class="example-break" /><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>
	      The 'size' value given upon construction (array(10) or string(17)) must be a
	      <span class="emphasis"><em>legal expression at parse time and is only
	      evaluated once</em></span>. The safest method is using a
	      literal integer ( i.e. (10) like in the examples ), but if you
	      create a Task constant or variable which holds an
	      integer, you can also use it as in :
	      </p><pre class="programlisting">  var array example( 5 * numberOfItems )</pre><p>
	      The expression may not contain any
	      program variables, these will all be zero upon parse
	      time ! The following example is <span class="emphasis"><em>a common mistake</em></span>
	      also :
	      </p><pre class="programlisting">  numberOfItems = 10
  var array example( 5 * numberOfItems )</pre><p>
              Which will not lead to '50', but to '5 times the
	      value of numberOfItems, being still zero, when the program is parsed.
	    </p></td></tr></table></div><p>Another property of container types is that you can index (use []) their
	    contents. The index may be any expression that return an int.
	  </p><pre class="programlisting">
  // ... continued
  // Set an item of a container :
  for (var int i=0; i &lt; 20; i = i+1)
       values[i] = 1.0*i

  // Get an item of a container :
  var double sum
  for (var int i=0; i &lt; 20; i = i+1)
       sum = sum + values[i]  </pre><p>
	    If an assignment tries to set an item out of range, the assignment will fail,
	    if you try to read an item out of range, the result will return 0.0, or for
	    strings, the null character.
	  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581671120"></a>2.3.4. Operators</h4></div></div></div><p>
	    Expressions can be combined using the C-style operators
	    that you are already familiar with if you have ever
	    programmed in C, C++ or Java.  Most operators are
	    supported, except for the if-then-else operator ("a?b:c") and the
	    "++/--" post-/pre- increment operators.
	    The precedence is the same as the one used in C, C++,
	    Java and similar languages. In general all that you would
	    expect, is present.
	  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581672896"></a>2.3.5. The '.' Operator</h4></div></div></div><p>
	    When a data type is a C++ struct or class, it contains fields
	    which you might want to access directly. These can be accessed
	    for reading or writing by using a dot '.' and the name of the
	    field:
	    </p><pre class="programlisting">  var mydata d1;

  d1.count = 1;
  d1.name  = "sample";</pre><p>
	  </p><p>
	    Some value types, like array and string,
	    are containing <span class="emphasis"><em>read-only</em></span> values
	    or useful information about their size and capacity:
	    </p><pre class="programlisting">  var string s1 = "abcdef"

  // retrieve size and capacity of a string :
  var int size = s1.size
  var int cap  = s1.capacity</pre><p>
	    </p><pre class="programlisting">  var array a1( 10 )
  var array a2(20) = a1

  // retrieve size and capacity of a array :
  var int size = a2.size      // 10
  var int cap  = a2.capacity  // 20</pre><p>
	  </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581677824"></a>2.4. Parsing and Loading Programs</h3></div></div></div><p>
	Before we go on describing the details of the programs syntax,
	we show how you can load a program in your Real-Time Task.
      </p><p>
	The easiest way is to use the DeploymentComponent where you
	can specify a script to load in the application's 
	deployment XML file or using the TaskBrowser. 
	You can also do it in C++, as described	below.
      </p><p>
	The example below is for a program script
	<code class="filename">programs.ops</code> which contains a program
	with the name "progname".
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581680896"></a>2.4.1. In the TaskBrowser</h4></div></div></div><p>
	This is the easiest procedure. You need to tell the
	taskbrowser that you want the scripting service and
	then use the scripting service to load the program
	script:
      </p><pre class="programlisting">  Component [R]&gt; .provide scripting
  Trying to locate service 'scripting'...
  Service 'scripting' loaded in Component
  Component [R]&gt; scripting.loadPrograms("programs.ops")
    = true
  Component [R]&gt; progname.start()
    = true
      </pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581683184"></a>2.4.2. In C++ code </h4></div></div></div><p>
	Parsing the program is done using the 'getProvider'
	function to call the scripting service's functions:
      </p><pre class="programlisting">
  #include &lt;rtt/Activity.hpp&gt;
  #include &lt;rtt/TaskContext.hpp&gt;
  #include &lt;rtt/scripting/Scripting.hpp&gt;

  using namespace RTT;

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>   tc;
  tc.setActivity( new <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a>(5, 0.01) );

  // Watch Logger output for errors :
  tc.getProvider&lt;<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Scripting.html">Scripting</a>&gt;("scripting")-&gt;loadPrograms("program.ops");

  // start a program :
  tc.getProvider&lt;Scripting&gt;("scripting")-&gt;startProgram("progname");
</pre><p>
	The Scripting service will load all programs and functions
	into 'tc'.The program "progname" is then started. Programs can also
	be started from within other scripts.
      </p><p>
        In case you wish to have a pointer to a program script object
	(<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1scripting_1_1ProgramInterface.html">ProgramInterface</a>),
	you can have so only from within the owner TaskContext by
	writing:
      </p><pre class="programlisting">
  // Services are always accessed using a shared_ptr
  // cast the "scripting" RTT::Service to an RTT::scripting::ScriptingService shared_ptr:
  RTT::scripting::ScriptingService::shared_ptr ss 
     = boost::dynamic_pointer_cast&lt;<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1scripting_1_1ScriptingService.html">ScriptingService</a>&gt;( this-&gt;provides()-&gt;getService("scripting") );

  ProgramInterfacePtr p = ss-&gt;getProgram("progname");

  // start a program :
  p-&gt;start();</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="program-syntax"></a>3. Orocos Program Scripts</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="program-semantics"></a>3.1. Program Execution Semantics</h3></div></div></div><p>
	An <acronym class="acronym">Orocos</acronym> program script is a list of statements, quite similar
	to a C program. Programs can call C/C++ functions and functions
	can be loaded into the system, such that other programs
	can call them. Program scripts are executed by the Execution Engine.
      </p><p>
	In general, program statements are executed immediately one after
	the other. However, when the program needs to wait for a result,
	the Execution Engine temporarily postpones program execution and
	will try again in the next execution period. This
	happens typically when yield was called. Calling operations
	and expressions on the other hand typically do not impose a
	yield, and thus are executed immediately after each other.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="program-syntax-specifics"></a>3.2. Program Syntax</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581695264"></a>3.2.1. <span class="symbol">program</span></h4></div></div></div><p> A program is formed like this: </p><pre class="programlisting">  program progname {
    // an arbitrary number of statements
  }	</pre><p>
	  The statements are executed in order, starting at the first
	  and following the logical execution path imposed by your
	  program's structure. If any of the statements causes a
	  run-time error, the Program Processor will put the program
	  in the error state and stop executing it.  It is the task of
	  other logic (like state machines, see below) to detect such
	  failures.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581698208"></a>3.2.2. Variables and Assignments</h4></div></div></div><p>
	  A variable is declared with the <span class="symbol">var</span> keyword
	  and can be changed using the <span class="symbol">=</span> symbol.
	  It looks like this:
	  </p><pre class="programlisting">
  var int a, b, c;
  a = 3 * (b = (5 * (c = 1))); // a = 15, b = 5, c = 1
	  </pre><p>
	  The semicolon at the end of the line is optional, but when omitted,
	  a newline must be used to indicate a new statement.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581701264"></a>3.2.3. The if then else Statement</h4></div></div></div><p>	A Program script can contain if..then..else blocks, very similar
	to C syntax, except that the <span class="emphasis"><em>then</em></span> word is mandatory
	and that the braces () can be omitted.
	For example:
	</p><pre class="programlisting">  var int x = 3

  if <span class="emphasis"><em>x == 3</em></span> then <span class="emphasis"><em> x = 4</em></span> 
  else <span class="emphasis"><em>x = 5</em></span>

  // or :
  if <span class="emphasis"><em>(x == 3)</em></span> then {
    <span class="emphasis"><em>x = 4</em></span>
    // ...
  } else {
    <span class="emphasis"><em>x = 5</em></span>
    // ...
  }</pre><p>
	  It is thus possible to group statements. Each statement can
	  be another if clause. An else is always referring to the last
	  if, just like in C/C++. If you like, you can also write
	  parentheses around the condition. The else statement is
	  optional.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581707232"></a>3.2.4. The for Statement</h4></div></div></div><p>
	  The for statement is almost equal to the C language.
	  The first statement initialises a variable or is empty.
	  The condition contains a boolean expression (use 'true'
	  to simulate an empty condition).
	  The second statement changes a variable or is empty.
	  </p><pre class="programlisting">
  // note the <span class="emphasis"><em>var</em></span> when declaring i:
  for ( <span class="emphasis"><em>var int i = 0</em></span>; <span class="emphasis"><em>i != 10</em></span>; <span class="emphasis"><em>i = i + 1</em></span> )
        <span class="emphasis"><em>log("Hello World")</em></span>
  // or group:
  for ( <span class="emphasis"><em>i = 0</em></span>; <span class="emphasis"><em>i &lt; b</em></span>; <span class="emphasis"><em>i = i + 1</em></span> ) {
        <span class="emphasis"><em>log("In the loop")</em></span>
        // ...
  }  </pre><p>
	  Note that Orocos scripting does not (yet) support the postfix
	  or prefix increment/decrement operators like ++ and --.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581713728"></a>3.2.5. The while Statement</h4></div></div></div><p>
	  The while statement is another looping primitive in 
	  the Orocos script language. A <span class="symbol">do</span> statement is not
	  implemented</p><pre class="programlisting">
  var int i = 0;
  while <span class="emphasis"><em>i &lt; 10</em></span> 
      <span class="emphasis"><em>i = i +1</em></span>
  // or group:
  i = 0;
  while <span class="emphasis"><em>i &lt; 10</em></span> {
      <span class="emphasis"><em>log("In while")</em></span>
      <span class="emphasis"><em>i = i + 1</em></span>
      // ...
  }  </pre><p>
	  As with the if statement, you can optionally put
	  parentheses around the condition 'i &lt; 10'.
	  Note that Orocos scripting does not support the postfix
	  or prefix increment/decrement operators like ++ and --.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581719264"></a>3.2.6. The break Statement</h4></div></div></div><p>
	  To break out of a while or for loop, the 
	  break statement is available. It will break
	  out of the innermost loop, in case of nesting.
	</p><pre class="programlisting">
  var int i = 0
  while <span class="emphasis"><em>true</em></span>  {
      i = i + 1
      if i == 50 then
          <span class="emphasis"><em>break</em></span> 
      // ...
  }  </pre><p>
	  It can be used likewise in a for loop.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581722752"></a>3.2.7. Invoking Task Operations</h4></div></div></div><p>
	  Operations can be called like calling C functions. They take
	  arguments and return a value immediately. They can be
	  used in expressions or stand alone :</p><pre class="programlisting">
  // var int arg1 = 3, arg2 = 4
  // ignore the return value :
  peer.method( arg1, arg2 )
  
  // this will only work if the method returns a boolean :
  if ( peer.method( arg1, arg2 ) ) {
  	    // ...
  }
  
  // use another method in an expression :
  data = comp.getResult( arg1 ) * 20. / comp.value
	  </pre><p>
	  These operations are executed directly one after the other.
	</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/icons/warning.png" /></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>
	    A method throwing an exception, will cause a run-time
	    program error. If this is not wanted,
	    put 'try' in front of the method call statement, as shown
	    in the next section.
	  </p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581726752"></a>3.2.8. Try ... Catch statements</h4></div></div></div><p>
	  When a method throws a C++ exception,
	  the program goes into an error state and waits for user
	  intervention. This can be intercepted by using a 
	  <span class="emphasis"><em>try...catch</em></span> statement. It tries
	  to execute the method, and if it throws,
	  the optional catch clause is executed :</p><pre class="programlisting">  // just try ignores the exception of action :
  try comp.action( args )
  
  // When an exception is thrown, execute the catch clause :
  try comp.action( args ) catch { 
      // statements...
  } </pre><p>
	    If the method did not throw, the catch clause is not
	    executed. Note that you can not inspect the C++ exception,
	    so only rudimentary error handling is available.
	  </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581730480"></a>3.3. Setting Task Attributes and Properties</h3></div></div></div><p>
           Task attributes/Properties are set in the same way as ordinary script variables.
         </p><pre class="programlisting">  // Setting a property named MyProp of type double
  var double d = 5.0
  comp.MyProp = d </pre><p>
         </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581733168"></a>3.4. <span class="symbol">function</span></h3></div></div></div><p>
	  Statements can be grouped in functions. A function can only
	  call another function which is earlier defined. Thus recursive
	  function calling is not allowed in this language.
	</p><pre class="programlisting">  // A function only known in the current scripting service
  void func_name( int arg1, double arg2 ) {
    // an arbitrary number of statements
  }
  
  // A function put in the interface of the component
  export double func_name(bool arg) {
    // ...
    if ( arg ) then return +10.0; else return -10.0;
  }

  // A function put in the global service interface of the current process
  global double global_func_name(bool arg) {
    // ...
    if ( arg ) then return +10.0; else return -10.0;
  }</pre><p>
					A function can have any number of arguments, which are
					passed by value, and may return a value.
				</p><p> 
					By default, a function is only known in the scripting service of the current
					component.  You can make this explicit by writing the <span class="emphasis"><em>local</em></span>
					keyword in front of the return value. This function will be found as an operation in
					the 'scripting' Service of the current component. You should not rely on the
					presence or name of this Operation, since it is considered as 'internal' to the
					scripting Service. Future releases may relocate or rename this function.
				</p><p>
					You can add a function to the interface of the current component by using the
					<span class="emphasis"><em>export</em></span> keyword. This allows you to extend the interface of a
					component at run-time.
				</p><p>
					Finally, the <span class="emphasis"><em>global</em></span> keyword puts the defined function in the
					<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1GlobalService.html">GlobalService</a>, which makes it available for any
					component or script in the current process.
				</p><p>
					You may redefine a function with the same name, in which case a warning
					will be logged and the new function is installed. In case the same
					function name is in use locally, at the TaskContext interface or globally,
					the local function is used first, then the TaskContext function and 
					finally the global function.
				</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581741024"></a>3.5. Calling functions</h3></div></div></div><p>
	  A function can be called as a regular Operation :
	</p><pre class="programlisting">
  foo(arg)      // is a global, local or exported function of the current component
  </pre><p>
		
	</p><p>
	  If one of the statements of the called function
	  throws an exception, an exception is thrown in the current 
		program and the calling program goes into the error state.
	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The 'call' keyword has been deprecated since version 2.5 and should
		no longer be used.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581745056"></a>3.6. <span class="symbol">return</span></h3></div></div></div><p>
	  The return statement behaves like in traditional languages.
	  For programs and functions that do not return a value, the
	  return statement is written like:
	</p><pre class="programlisting">
  export void foo(int i) {
     // ...
     if ( i &lt; 0 )
        return
     // use i...
  }</pre><p>
	  When the return statement returns a value, it must be on the
	  same line as the return word:
	</p><pre class="programlisting">
  export int foo(int i) {
     // ...
     if ( i &lt; 0 )
        return -1  // returned value on same line.
     // use i...
     return i*10
  }</pre><p>
	  As the examples show, you can return from a function
	  from multiple places.
	</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581749264"></a>3.7. Waiting : The 'yield' statement</h3></div></div></div><p>
	  A special statement 'yield' is provided. It temporarily
	  suspends the execution of the current script and allows
	  the Execution Engine in which it runs to do something
	  else. You will need this in an endless while loop, for
	  example:
	  </p><pre class="programlisting">  while( true ) { 
    log("Waiting...")
    yield
  }</pre><p>
          If the yield statement is omitted, the script would never
	  return and consume all available processor time. Yield
	  suspends the execution of this script until the 
	  ExecutionEngine is triggered again, for example, when an
	  asynchronous operation is received or by the expiration
	  of the period in a periodically running component.
	</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525581751888"></a>4. Starting and Stopping Programs from scripts</h2></div></div></div><p>
	  Once a program is parsed and loaded into the Execution Engine,
	  it can be manipulated from another script. This can be
	  done through the programs subtask of the TaskContext
	  in which the program was loaded. Assume that you loaded
	  "progname" in task "ATask", you can write
	</p><pre class="programlisting">
  ATask.progname.start()
  ATask.progname.pause()
  ATask.progname.step()
  ATask.progname.step()
  ATask.progname.stop()</pre><p>The first line starts a program. The second line
	  pauses it. The next two lines executes one command each of the
	  program (like stepping in a debugger). The last line stops
	  the program fully (running or paused).</p><p>
	  Some basic properties of the program can be
	  inspected likewise :</p><pre class="programlisting">
  var bool res =  ATask.progname.isRunning()
  res = ATask.progname.inError()
  res = ATask.progname.isPaused()</pre><p>
	  which all return a boolean indicating true or false.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525581756608"></a>5. Orocos State Descriptions : The Real-Time State Machine</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581757312"></a>5.1. Introduction</h3></div></div></div><p>
	A <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1scripting_1_1StateMachine.html">StateMachine</a> is the state
	machine used in the <acronym class="acronym">Orocos</acronym> system.  It contains a collection
	of states, and each state defines a Program on entry of the
	state, when it is run and on exit.  It also defines all
	transitions to a next state. Like program scripts, a
	StateMachine must be loaded in a Task's Execution Engine.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581759840"></a>5.2. StateMachine Mechanism</h3></div></div></div><p>
	A StateMachine is composed of a set of states.  A running
	StateMachine is always in exactly one of its states.  One
	time per period, it checks whether it can transition from
	that state to another state, and if so makes that
	transition. By default, only one transition can be made
	in one Execution Engine step.
      </p><p>
	  Besides a list of the possible transitions, every state also
	  keeps record of programs to be executed at certain
	  occasions.  There can be up to four (all optional) programs
	  in every state: the <span class="symbol">entry</span> program ( which will be executed
	  each time the state is entered ), the <span class="symbol">run</span> program ( which
	  will be executed every time the state is the active state ),
	  the <span class="symbol">handle</span> program ( which will be executed right after <span class="symbol">run</span>, if no transition
	  succeeds ) and the <span class="symbol">exit</span> program ( which will be executed
	  when the state is left).
	</p><p>
	  There can be more than one StateMachine. They separately keep track
	  of their own current state, etc.
	</p><p>
	A StateMachine can have any number of states.  It needs to
	have exactly one "initial state", which is the state that will
	be entered when the StateMachine is first activated.
	There is also exactly one final state, which is
        <span class="emphasis"><em>automatically</em></span> entered when the StateMachine is stopped.
	<span class="emphasis"><em>This means that the transition from any state to the
	  final state must always be meaningful.</em></span>
      </p><p>
	A State Machine can run in two modes. They are the automatic
	mode and the reactive (also 'event' or 'request') mode. You can
	switch from one mode to another at run-time.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="state-request"></a>5.2.1. Reactive Mode: State Change Semantics</h4></div></div></div><p>
	  In order to enter the reactive mode, the State Machine
	  must be 'activated'. When active, two possible causes of
          state transitions can exist: because an <span class="emphasis"><em>event
          </em></span> occured or because a transition was
          <span class="emphasis"><em>requested</em></span>.
	</p><div class="figure"><a id="idp46525581769536"></a><p class="title"><strong>Figure 3.1. State Change Semantics in Reactive Mode</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="600"><tr><td align="center"><img src="images/ReactiveState.png" align="middle" width="600" alt="State Change Semantics in Reactive Mode" /></td></tr></table></div></div></div><br class="figure-break" /><p> 
          A state can list to which Orocos data flow events it reacts,
          and under which conditions it will make a transition to another
          state. A state only reacts to events when its entry program
          is fully executed (done) and an event may be processed when
          the run program is executed, thus interrupt the run program.
          The first event that triggers a transition will 'win' and
          the state reacts to no more events, executes the event's transition program,
	  then the state's exit program, and finally,
          the next state is entered and its entry program is executed.
          The next state now listens for events (if any) to make a 
          transition or just executes its run program.
        </p><p>
	  Another program can request a transition to a particular 
          state as well. When the request arrives, the current state
	  checks its transition conditions and evaluates if a transition to that state
	  is allowed. These conditions are separately listed from the event
          transitions above. If a transition condition is valid,
          the exit program of the current state
	  is called, the transition program and then the entry program of the requested state is
	  called and the requested state's run program is executed. 
          If a transition to the current state was requested,
	  only the run program of the current state is executed.
	</p><p>
	  In this mode, it is also possible to request a single
	  transition to the 'best' next state. All transition conditions
          are evaluated and the first one that succeeds makes a transition
          to the target state. This mechanism is
	  similar to automatic mode below, but only one transition is made
	  ( or if none, handle is executed ) and then, the state
	  machine waits again. The step() command triggers this behaviour.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="state-automatic"></a>5.2.2. Automatic Mode: State Change Semantics</h4></div></div></div><p>
	  In order to enter automatic mode, the State Machine must be
	  first reactive and then started with the start() command
	  (see later on).
	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	  This mechanism is in addition to 'reactive' mode. A
	  state machine in automatic mode still reacts to events.
	</p></td></tr></table></div><div class="figure"><a id="idp46525581780576"></a><p class="title"><strong>Figure 3.2. State Change Semantics in Automatic Mode</strong></p><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="300"><tr><td align="center"><img src="images/AutomaticState.png" align="middle" width="300" alt="State Change Semantics in Automatic Mode" /></td></tr></table><div class="caption"><p>The automatic mode additionally actively evaluates
	  guard conditions. Event reaction remains in effect, but is not shown
	  in this diagram.</p></div></div></div></div><br class="figure-break" /><p>
	  In automatic mode, after the run program of the current
	  state finishes, the transition table (to other states) of
	  the current state is evaluated.  If a transition succeeds,
	  the transition program is executed, then the exit program of
	  the current state is called and then the entry program of
	  the next state is called. If no transition evaluated to
	  true, the handle program (if any) of the current state is
	  called. This goes on until the automatic mode is left, using
	  the pause, stop or reactive command.
	</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581788176"></a>5.3. Parsing and Loading StateMachines</h3></div></div></div><p>
	Analogous to the Program section, we first show how 
	you can load a StateMachine in your Real-Time Task.
	Assume that you have a StateMachine "MachineInstanceName"
	in a file <code class="filename">state-machine.osd</code>.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581790256"></a>5.3.1. In the TaskBrowser</h4></div></div></div><p>
	This is the easiest procedure. You need to tell the
	taskbrowser that you want the scripting service and
	then use the scripting service to load the state
	machine
      </p><pre class="programlisting">  Component [R]&gt; .provide scripting
  Trying to locate service 'scripting'...
  Service 'scripting' loaded in Component
  Component [R]&gt; scripting.loadStateMachines("state-machine.osd")
    = true
  Component [R]&gt; MachineInstanceName.activate()
    = true
  Component [R]&gt; MachineInstanceName.start()
    = true
      </pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581792624"></a>5.3.2. In C++ code </h4></div></div></div><p>
	Parsing the StateMachine is very analogous
	to parsing Programs in C++:
      </p><pre class="programlisting">
  #include &lt;rtt/Activity.hpp&gt;
  #include &lt;rtt/TaskContext.hpp&gt;
  #include &lt;rtt/scripting/Scripting.hpp&gt;

  using namespace RTT;

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>   tc;
  tc.setActivity( new <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a>(5, 0.01) );

  tc.getProvider&lt;Scripting&gt;("scripting")-&gt;loadStateMachines( "state-machine.osd" );

  // activate a state machine :
  tc.getProvider&lt;<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Scripting.html">Scripting</a>&gt;("scripting")-&gt;activateStateMachine("MachineInstanceName");
  // start a state machine (automatic mode) :
  tc.getProvider&lt;Scripting&gt;("scripting")-&gt;startStateMachine("MachineInstanceName");</pre><p>
	The Scripting service loads all instantiated state machines in tc.
	StateMachines have a more complex lifetime than
	Programs. They need first to be activated, upon which they
	enter a fixed initial state. When they are started, 
	they enter automatic mode and state
	transitions to other states can take place. StateMachines
	can also be manipulated from within other scripts.
      </p><p>
        In case you wish to have a pointer to a state machine script object
	(<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1scripting_1_1StateMachine.html">StateMachine</a>),
	you can have so only from within the owner TaskContext by
	writing:
      </p><pre class="programlisting">
  // Services are always accessed using a shared_ptr
  // cast the "scripting" RTT::Service to an RTT::scripting::ScriptingService shared_ptr:
  RTT::scripting::ScriptingService::shared_ptr ss 
     = boost::dynamic_pointer_cast&lt;<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1scripting_1_1ScriptingService.html">ScriptingService</a>&gt;( this-&gt;provides()-&gt;getService("scripting") );

  StateMachinePtr sm = ss-&gt;getStateMachine("MachineInstanceName");

  // activate and start a StateMachine :
  sm-&gt;activate();
  sm-&gt;start();</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581799664"></a>5.4. Defining StateMachines</h3></div></div></div><p>
	  You can think of StateMachines somewhat like C++ classes.  You
	  first need to define a type of StateMachine, and you can then
	  instantiate it any number of times afterwards.  A StateMachine
	  ( the type ) can have parameters, so every instantiation can
	  work differently based on the parameters it got in its
	  instantiation.
	</p><p>
	  A StateMachine definition looks like this :
	</p><div class="example"><a id="idp46525581801584"></a><p class="title"><strong>Example 3.2. StateMachine Definition Format</strong></p><div class="example-contents"><pre class="programlisting">  StateMachine <span class="emphasis"><em>MyStateMachineDefinition</em></span>
  {
    initial state <span class="emphasis"><em>myInit</em></span>
    {
        // all these programs are optional and can be left out:
        entry {
	    // entry program
	}
	run {
	    // run program
	}
	handle {
	    // handle program
	}
	exit {
	    // exit program
	}
	// Ordered event based and conditional select statements
	transition ... { /* transition program */ } select ...
	transition ...

    }

    final state <span class="emphasis"><em>myExit</em></span> {
	entry {
	    // put everything in a safe state.
	}
	// leave out empty programs...

	transition ...
    }

    state <span class="emphasis"><em>Waiting</em></span> {
        // ...
    }

    // ... repeat
  }  

  // See <a class="xref" href="#instantiating" title="5.5. Instantiating Machines: SubMachines and RootMachines">Section 5.5, “Instantiating Machines: SubMachines and RootMachines”</a> :
  RootMachine MyStateMachineDefinition MachineInstanceName</pre><p>
	    A StateMachine definition: a StateMachine can have any
	    number of states.  It needs to have exactly one "initial
	    state" ( which is the state that will be entered when the
	    StateMachine is first started ).  Within a state, any
	    method is optional, and a state can even be defined empty.
	  </p></div></div><br class="example-break" /><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581806896"></a>5.4.1. The <code class="function">state</code> Statement</h4></div></div></div><p>
	    A state machine can have an unlimited number of states.  A
	    state contains optionally 4 programs : entry, run, handle,
	    exit.  Any one of them is optional, and a
	    state can even conceivably be defined empty.
	  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581809168"></a>5.4.2. The <code class="function">entry</code> and
	    <code class="function">exit</code> Statements</h4></div></div></div><p>
	    When a state is entered for the first time, the entry
	    program is executed. When it is left, the exit program is
	    called. The execution semantics are identical to the
            program scripts above.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581812144"></a>5.4.3. The <code class="function">run</code> Statement</h4></div></div></div><p>
            The run program serves to define which activity is done
            within the state. After the entry program finishes, the
            run program is immediately started. It may be interrupted
            by the events that state reacts to. In event mode, the
            run program is executed once (although it may use an
            infinite loop to repeatedly execute statements). In
            automatic mode, when the run program completes, and no
            transitions to another state can be made (see below)
            it is started again (in the next execution step).
          </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581814800"></a>5.4.4. The <code class="function">handle</code> and
	    <code class="function">transition</code> Statement</h4></div></div></div><p>
            When the run program finishes in automatic mode, the
            state evaluates its transitions to other states.
	    The handle program is called only when no transition can be found to another state.
	    The transitions section defines one or more <code class="function">select</code>
            <span class="emphasis"><em>state</em></span> statements. These can be guarded by if...then clauses
            (the transition conditions):
	    </p><pre class="programlisting">  // In state XYZ :
  // conditionally select the START state
  transition if HMI.startPushed then {
        // (optional)
        // transition program: HMI.startPushed was true
        // when finished, go to START state
  } select START

  // next transition condition, with a transition failure program:
  transition if HMI.waiting then
      select WAIT else {
        // (optional)
        // transition failure program: HMI.startPushed was false
  }

  handle {
     // only executed if no transition above could be made
     // if startPushed and waiting were false:
     // ... 
  } </pre><p>
	    The transitions are checked in the same order as listed.
	    A transition is allowed to select the current state, but
	    the exit and entry functions will not be called in that
	    case. Even more, a transition to the current state is always
	    considered valid and this can not be overridden.
	  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581820672"></a>5.4.5. State Preconditions</h4></div></div></div><p>
	    Often it's useful to specify some preconditions that need
	    to hold before entering a state. <acronym class="acronym">Orocos</acronym> states
	    explicitly allow for this.  A state's preconditions will
	    be checked before the state is entered.
	  </p><p>
	    Preconditions are specified as follows:
	    </p><pre class="programlisting">  state X {
    // make sure the robot is not moving axis 1 when entering this state
    // and a program is loaded.
    precondition  robot.movingAxis( 1 ) == false
    precondition  programLoaded == true
    // ...
  }</pre><p>
            They are checked in addition to transitions to that state
            and can make such a transition fail, hence block the
            transition, as if the transition condition in the first place
            did not succeed.
	  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581824208"></a>5.4.6. Data Flow Event Transitions</h4></div></div></div><p>
	    An important property of state machines is that they can
	    react to external (asynchronous) events. Orocos
	    components can define reactions to data arriving on
	    <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1InputPort.html">InputPort</a>s. When new data arrives on this port, we speak
	    of an 'event'.
	  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>A StateMachine can only react to InputPorts
	  which have been added with 'addEventPort' to the TaskContext.
	  </p></td></tr></table></div><p>
	    Event transitions are an extension to the transitions
	    above and cite an InputPort name between the transition and the
	    if statement. They are specified as:
	  </p><pre class="programlisting">  state X {
    var double d
    transition x_in_port(d) if ( d &gt;1.3 ) then {
       // transition succeeds, transition program:
       // ...
    } select ONE_STATE else {
       // transition fails, failure program:
       // ...
    } select OTHER_STATE

    // other events likewise...
  }</pre><p>
            Both the transition programs and the the select statements
            are optional, but at least a program or select statement
            must be given. The </p><pre class="programlisting">  transition x_in_port(d) if (d &gt;1.3) then {
	    </pre><p> short notation statement is equivalent to writing (NOTE: the added .read(d) part) :
	    </p><pre class="programlisting">  transition if ( x_in_port.read(d) == NewData &amp;&amp; d &gt;1.3) then {...
	    </pre><p>
	  </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>
	      This short notation differs however from the long form
	      as such: if multiple transitions are waiting on the same
	      port, but with a different guard, the short notation
	      will give all transitions a chance to see the NewData return
	      value. If a user would use the long form, only the first
	      transition statement would see NewData, all the others
	      would see OldData as return value. In this case, the short
	      notation is prefered.
	    </p></td></tr></table></div><p>
	    When the input port <code class="function">x_in_port</code>
	    receives NewData, our state machine reacts to it and the
	    data is stored in d. The <code class="function">if ... then</code>
	    statement may check this variable and any other state
	    variables and methods to evaluate the transition. If it
	    succeeds, an optional transition program may be given and
	    a target state <code class="function">select</code>ed (ONE_STATE).
	    if the transition fails, an optional failure program may
	    be given and an optional <code class="function">select</code>
	    (OTHER_STATE) statement may be given.  The number of
	    arguments must match the number of arguments of the used
	    event.  The event is processed as an asynchronous
	    callback, thus in the thread or task of the StateMachine's
	    processor.
	  </p><p>
	    Event transitions are enabled after the entry program and
	    before the exit program (also in automatic mode).  All events
	    are processed in a state until the first event that leads
	    to a valid state transition. In the mean time, the run 
	    or handle program may continue, but will be interrupted
			in a yield statement if an event leads to a transition. 
			Run or handle programs without yield will be allowed to 
			finish normally, before the transition is taken.
	  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581836800"></a>5.4.7. Reacting to level events on Ports</h4></div></div></div><p>
			Another pattern of using ports to handle events, is to
			implement level events instead of edge events as seen above.
			The syntax for level events shows that the port must be read
			out in the if statement, as a normal port read:
	  </p><pre class="programlisting">  transition if (robotState.read(robot_state) != NoData &amp;&amp; Robot.STATE_SAFE == robot_state) select SAFE;
		</pre><p>
			The example above shows reading a robotState port and storing the
			result in the robot_state variable. The transition then checks if
			the robot_state variable is equal to the defined STATE_SAFE constant
			in the Robot peer component.
	  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581839872"></a>5.4.8. Operation Event Transitions</h4></div></div></div><p>
			A second source of transitions are the invocation of Operations
			of the TaskContext the state machine runs in. In order to
			respond in a state machine to such an event, the operation needs
			to be added with the addEventOperation function:
	  </p><pre class="programlisting">  // member variable of 'MyComp':
  Operation&lt;void(int)&gt; requestSafe; // don't forget to initialize with a "name" in the constructor.

  // ...

     // for example: in the TaskContext constructor:
     this-&gt;provides()-&gt;addEventOperation(requestSafe).doc("This operation does nothing except for requesting the SAFE state");
		</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>A StateMachine can only react to Operations
	  which have been added with 'addEventOperation' to the TaskContext.
	  </p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>A StateMachine can only react to Operations
		of the component it runs in.
	  </p></td></tr></table></div><p>
			Reacting to an Operation call is similar to responding to port
			events above:
	  </p><pre class="programlisting">  state X {
    var int reason;

    transition requestSafe(reason) if ( reason == 3 ) then {
       // transition succeeds, transition program:
       // ...
    } select SAFE else {
       // transition fails, failure program:
       // ...
    } select OTHER_STATE

    // other events likewise...
  }</pre><p>
			As with Event ports, both the transition programs and the the select statements
			are optional, but at least a program or select statement
			must be given.
	  </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="instantiating"></a>5.5. Instantiating Machines: SubMachines and RootMachines</h3></div></div></div><p>
	  As mentioned before: you can look at a SubMachine
	  definition as the definition of a C++ class.  It is merely
	  the template for its instantiations, and you have to
	  instantiate it to actually be able to do anything with it.
	  There is also a mechanism for passing parameter values to
	  the StateMachines on instantiation.
	</p><p>
	  Note that you always need to write the instantiation after
	  the definition of the StateMachine you're instantiating.
	</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581848224"></a>5.5.1. Root Machines</h4></div></div></div><p>
	    A Root Machine is a normal instantiation of a
	    StateMachine, one that does not depend on a parent
	    StateMachine ( see below ).  They are defined as follows:
	    </p><pre class="programlisting">  StateMachine SomeStateMachine
  {
      initial state initState
      {
        // ...
      }
      final state finalState
      {
        // ...
      }
  }

  RootMachine SomeStateMachine someSMinstance </pre><p>
	    This makes an instantiation of the StateMachine type
	    SomeStateMachine by the name of 'someSMinstance', which can then
	    be accessed from other scripts (by that name).
	  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581850816"></a>5.5.2. Parameters and public variables</h4></div></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idp46525581851568"></a>StateMachine public variables</h5></div></div></div><p>
	      You can define variables at the StateMachine level.
	      These variables are then accessible to the StateMachine
	      methods (entry, handle, exit), the preconditions, the
	      transitions and ( in the case of a SubMachine, see below
	      ) the parent Machine.
	    </p><p>
	      You can define a StateMachine public variable as follows:
	      </p><pre class="programlisting">  StateMachine SomeStateMachine
  {
    // a public constant
    const double pi = 3.1415926535897
    var int counter = 0

    initial state initState
    {
	handle
	{
            // change the value of counter...
            counter = counter + 1
        }
        // ...
    }
    final state finalState
    {
	entry
        {
            someTask.doSomethingWithThisCounter( counter )
        }
        // ...
    }
  }

  Rootmachine SomeStateMachine mymachine </pre><p>
	    This example creates some handy public variables in the
	    StateMachine SomeStateMachine, and uses them throughout
	    the state machine. They can also be read and modified from 
	    other tasks or programs :
	    </p><pre class="programlisting">  var int readcounter = 0
  readcounter = taskname.mymachine.counter

  taskname.mymachine.counter = taskname.mymachine.counter *  2</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idp46525581855824"></a>StateMachine parameters</h5></div></div></div><p>
	      A StateMachine can have parameters that need to be set
	      on its instantiation.  Here's an example:</p><pre class="programlisting">
  StateMachine AxisController
  {
      // a parameter specifying which axis this Controller controls
      param int axisNumber
      initial state init
      {
          entry
          {
              var double power = someTask.getPowerForAxis( axisNumber )
  	    // do something with it...
          }
      }
  }
  
  RootMachine AxisController axiscontroller1( axisNumber = 1 )
  RootMachine AxisController axiscontroller2( axisNumber = 2 )
  RootMachine AxisController axiscontroller3( axisNumber = 3 )
  RootMachine AxisController axiscontroller4( axisNumber = 4 )
  RootMachine AxisController axiscontroller5( axisNumber = 5 )
  RootMachine AxisController axiscontroller6( axisNumber = 6 )</pre><p>
	      This example creates an AxisController StateMachine with
	      one integer parameter called axisNumber.  When the
	      StateMachine is instantiated, values for all of the
	      parameters need to be given in the form "oneParamName=
	      'some value', anotherParamName = 0,
	      yetAnotherParamName=some_other_expression + 5".  Values
	      need to be provided for all the parameters of the
	      StateMachine. As you see, a StateMachine can of course
	      be instantiated multiple times with different parameter
	      values.
	    </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525581859824"></a>5.5.3. Building Hierarchies : SubMachines</h4></div></div></div><p>
	    A SubMachine is a StateMachine that is instantiated within
	    another StateMachine ( which we'll call the parent
	    StateMachine ).  The parent StateMachine is owner of its
	    child, and can decide when it needs to be started and
	    stopped, by invoking the respective methods on its child.
	  </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idp46525581861312"></a>Instantiating SubMachines</h5></div></div></div><p>
	      An instantiation of a SubMachine is written as follows:
	      </p><pre class="programlisting">
  StateMachine ChildStateMachine
  {
      initial state initState
      {
          // ...
      }
      final state finalState
      {
          // ...
      }
  }
  
  StateMachine ParentStateMachine
  {
      SubMachine ChildStateMachine child1
      SubMachine ChildStateMachine child2
      initial state initState
      {
  	entry
          {
	      // enter initial state :
  	    child1.activate()
  	    child2.activate()
          }
          exit
          {
	      // enter final state :
              child2.stop()
          }
      }
  
      final state finalState
      {
          entry
          {
	      // enter final state :
              child1.stop()
          }
      }
  } </pre><p>
	      Here you see a ParentStateMachine which has two
	      ChildStateMachines.  One of them is started in the
	      initial state's entry method and stopped in its exit
	      method.  The other one is started in the initial state's
	      entry method and stopped in the final state's entry
	      method.
	    </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idp46525581864432"></a>SubMachine manipulating</h5></div></div></div><p>
	      In addition to starting and stopping a SubMachine, a
	      parent StateMachine can also inspect its public
	      variables, change its parameters, and check what state
	      it is in...
	    </p><p>
	      Inspecting StateMachine public variables is simply done
	      using the syntax "someSubMachineInstName.someValue",
	      just as you would do if someSubMachineInstName were an
	      <acronym class="acronym">Orocos</acronym> task.  Like this, you can inspect
	      all of a subcontext's public variables.
	    </p><p>
	      Setting a StateMachine parameter must be done at its
	      instantiation.  However, you can still change the values
	      of the parameters afterwards.  The syntax is: "set
	      someSubMachine.someParam = someExpression".  Here's an
	      elaborate example:</p><pre class="programlisting">  StateMachine ChildStateMachine
  {
      param int someValue
      const double pi = 3.1415926535897
      initial state initState
      {
          // ...
      }
      final state finalState
      {
          // ...
      }
  }

  StateMachine ParentStateMachine
  {
      SubMachine ChildStateMachine child1( someValue = 0 )
      SubMachine ChildStateMachine child2( someValue = 0 )
  
      var int counter = 0
      initial state initState
      {
  	  entry
          {
  	      child1.start()
  	      child2.start()
              // set the subcontext's parameter
              child1.someValue = 2
          }
          run
          {
              counter = counter + 1
              // set the subcontext's parameters
              child2.someValue = counter
              // use the subcontext's public variables
              someTask.doSomethingCool( child1.someValue )
          }
          exit
          {
              child2.stop()
          }
      }
  
      final state finalState
      {
          entry
          {
              child1.stop()
          }
      }
  }</pre><p>
	    You can also query if a child State Machine is in a
	    certain state.  The syntax looks like:
	    </p><pre class="programlisting">someSubMachine.inState( "someStateName" )
	    </pre><p>
	  </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525581871056"></a>5.6. Starting and Stopping StateMachines from scripts</h3></div></div></div><p>
	Once a state machine is parsed and loaded into the State Machine Processor,
	it can be manipulated from another script. This can be
	done through the "states" subtask of the TaskContext
	in which the state machine was loaded. Assume that you loaded
	"machine" with subcontexts "axisx" and "axisy"
	in task "ATask", you can write
      </p><pre class="programlisting">  ATask.machine.activate()
  ATask.machine.axisx.activate()
  // now in reactive mode...

  ATask.machine.axisx.start()
  ATask.machine.start()
  // now in automatic mode...

  ATask.machine.stop()
  // again in reactive mode, in final state

  ATask.machine.reset()
  ATask.machine.deactivate()
  // deactivated.
  // etc. </pre><p>
	The first line activates a root StateMachine, thus it
	enters the initial state and is put in reactive mode , the next line
	actives its child, the next starts its child, then we
	start the parent, which bring both in automatic mode.
	Then the parent is stopped again, reset
	back to its initial state and finally deactivated.
      </p><p>
	Thus both RootMachines and SubMachines can be controlled.
	Some basic properties of the states can be
	inspected likewise :</p><pre class="programlisting">  var bool res =  ATask.machine.isActive()      // Active ?
  res = ATask.machine.axisy.isRunning()     // Running ?
  res =  ATask.machine.isReactive()          // Waiting for requests or events? 
  var string current = ATask.machine.getState() // Get current state
  res = ATask.machine.inState( current )    // inState ?</pre><p>
	which makes it possible to monitor state machines from other
	scripts or an operator console.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="request-commands"></a>5.6.1. On Reactive Mode Commands</h4></div></div></div><p>
	  Consider the following StateMachine :
	</p><pre class="programlisting">  StateMachine X {
     // ...
     initial state y {
        entry {
	   // ...
        }
       // guard this transition.
       transition if checkSomeCondition() then
              select z
       transition if checkOtherCondition() then
              select exit
     }
     state z {
       // ...
       // always good to go to state :
       transition select ok_1
	  select ok_1
     }
     state ok_1 {
       // ...
     }
     final state exit {
       // ...
     }
  }

  RootMachine X x</pre><p>
	  A program interacting with this StateMachine can look like
	  this :
	</p><pre class="programlisting">
   program interact {
       // First activate x :
       x.activate()  // activate and wait.

       // Request a state transition :
       try x.requestState("z") catch {
           // failed !
       }

       // ok we are in "z" now, try to make a valid transition :
       x.step()

       // enter pause mode :
       x.pause()
       // Different ! Executes a single program statement :
       x.step()

       // unpause, by re-entering reactive Mode :
       x.reactive()

       // we are in ok_1 now, again waiting...
       x.stop()      // go to the final state

       // we are in "exit" now
       reset()

       // back in state "y", handle current state :
       this.x.requestState( this.x.getState() )
       // etc.
    } </pre><p>
	   The requestState command will fail if the transition is not 
	   possible ( for example, the state machine is not in
	   state y, or checkSomeCondition() was not true ),
	   otherwise, the state machine will make the transition
	   and the command succeeds and completes when the z state
	   is fully entered (it's init program completed).
	 </p><p>
	   The next command, step(), lets the state machine decide which
	   state to enter, and since a transition to state "ok_1" is unconditionally,
	   the "ok_1" state is entered. The stop() command brings
	   the State Machine to the final state ("exit"), while the
	   reset command sends it to the initial state ("y"). These
	   transitions do not need to be specified explicitly, they
	   are always available.
	 </p><p>
	   The last command, is a bit cumbersome request to execute
	   the handle program of the current state.
	 </p><p>
	   At any time, the State Machine can be paused using
	   pause(). The step() command changes to execute a single
	   program statement or transition evaluation, instead of
	   a full state transition.
	 </p><p>
	   All these methods can of course also be called from parent
	   to child State Machine, or across tasks.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="automatic-commands"></a>5.6.2. Automatic Mode Commands</h4></div></div></div><p>
	  Consider the following StateMachine, as in the previous
	  section :
	</p><pre class="programlisting">  StateMachine X {
     // ...
     initial state y {
        entry {
	   // ...
        }
        // guard this transition.
        transition if checkSomeCondition() then
              select z
        transition if checkOtherCondition() then
              select exit
     }
     state z {
       // ...
       // always good to go to state :
       transition select ok_1
     }
     state ok_1 {
       // ...
     }
     final state exit {
       // ...
     }
  }

  RootMachine X x</pre><p>
	  A program interacting with this StateMachine can look like
	  this :
	</p><pre class="programlisting">
   program interact {
       // First activate x :
       x.activate()  // activate and wait.

       // Enter automatic mode :
       x.start()

       // pause program execution :
       x.pause()

       // execute a single statement :
       x.step()

       // resume automatic mode again :
       x.start()

       // stop, enter final state, in request mode again.
       x.stop()

       // etc...
    } </pre><p>
	   After the State Machine is activated, it is started,
	   which lets the State Machine enter automatic mode. If
	   checkSomeCondition() evaluates to true, the State 
	   Machine will make the transition to state "z" without
	   user intervention, if checkOtherCondition() evaluates
	   to true, the "exit" state will be entered.
	 </p><p>
	   When running, the State Machine can be paused at any time
	   using pause(), and a single program statement ( a single
	   line ) or single transition evaluation can be executed with
	   calling step().  Automatic mode can be resumed by calling
	   start() again.
	 </p><p>
	   To enter the reactive mode when the State Machine is in
	   automatic mode, one can call the reactive() command,
	   which will finish the program or transition the State
	   Machine is making and will complete if the State Machine
	   is ready for requests.
	 </p><p>
	   All these methods can of course also be called from parent
	   to child State Machine, or across tasks.
	</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525581891728"></a>6. Program and State Example</h2></div></div></div><p>
      This sections shows the listings of an Orocos State
      Description and an Orocos Program Script. They are
      fictitious examples (but with valid syntax) which may
      differ from actual available tasks. The example
      tries to exploit most common functions.
    </p><div class="example"><a id="idp46525581893200"></a><p class="title"><strong>Example 3.3. StateMachine Example (state.osd)</strong></p><div class="example-contents"><p>The Example below shows a state machine for controlling 6 axes.</p></div></div><br class="example-break" /><pre class="programlisting">
    StateMachine Simple_nAxes_Test
    {

      var bool calibrate_offsets     = true
      var bool move_to               = true
      var bool stop                  = true
    
      const double pi = 3.14159265358979
      var array pos = array(6,0.0)
    
    
      initial state StartRobotState {
        entry {
          Robot.prepareForUse()
        }
        exit {
          Robot.unlockAllAxes()
          Robot.startAllAxes()
        }
        transitions {
          select CalibrateOffsetsState
        }
      }
    
    
      state CalibrateOffsetsState {
        preconditions {
          if (calibrate_offsets == false) then
            select MoveToState
        }
        entry {
          nAxesGeneratorPos.start()
          nAxesControllerPos.start()
          //Reporter.start()
          CalibrateOffsetsProg.start()
        }
        exit {
          nAxesGeneratorPos.stop()
          nAxesControllerPos.stop()
        }
        transitions {
           if !CalibrateOffsetsProg.isRunning then
           select MoveToState
        }
      }      
    
    
      state MoveToState {
        preconditions {
          if (move_to == false) then
            select StopRobotState
        }
        entry {
          nAxesGeneratorPos.start()
          nAxesControllerPosVel.start() 
          pos = array(6,0.0)
          nAxesGeneratorPos.moveTo(pos,0.0)
          pos[0]=-pi/2.0
          pos[1]=-pi/2.0
          pos[2]=pi/2.0
          pos[4]=-pi/2.0
          nAxesGeneratorPos.moveTo(pos,0.0)
        }
        exit {
           nAxesControllerPosVel.stop()
           nAxesGeneratorPos.stop()
           //Reporter.stop()
        }
        transitions {
          if(stop == true) then    
          select StopRobotState
        }
      }
    
    
      final state StopRobotState {
        entry {
          Robot.stopAllAxes()
          Robot.lockAllAxes()
        }
        exit {
          Robot.prepareForShutdown()
        }
      }
    }
    RootMachine Simple_nAxes_Test SimpleMoveTo</pre><div class="example"><a id="idp46525581895296"></a><p class="title"><strong>Example 3.4. Program example (program.ops)</strong></p><div class="example-contents"><p>
	Below is a program script example.
      </p></div></div><br class="example-break" /><pre class="programlisting">
  /**
   * This program is executed in the exec_state.
   */
  
  /**
   * Request the HMI to load the user selected
   * trajectory into the kernel.
   */
  export function HMILoadTrajectory() {
  	// request a 'push' of the next
  	// trajectory :
  	HMI.requestTrajectory()
  	// when the HMI is done :
  	Generator.loadTrajectory()
  }
  
  /**
   * a Homing (reset) of the axes.
   * This could also be done using a Homing state,
   * without a program.
   */
  export function ResetAxes() {
  	HomingGenerator.start()
  	HomingGenerator.homeAll()
  }
  
  export function ResetAxis(int nr) {
  	HomingGenerator.start()
  	HomingGenerator.homeAxis( nr )
  }
  
  /**
   * Request the Generator to use the current
   * trajectory.
   */
  function runTrajectory() {
  	Generator.startTrajectory()
  	// this function returns when the
  	// trajectory is done.
  }
  
  program DemoRun {
  	HMI.display("Program Started\n")
  	var int cycle = 0
  
  	// We actually wait here until a 
  	// Trajectory is present in the HMI.
  	while ( !HMI.trajectoryPresent() )
	   yield;
  
  	while HMI.cycle() {
  	    HMI.display("Cycle nr: %d.\n", cycle )
  	    ResetAxes()
  	    HMIRequestTrajectory()
  	    runTrajectory()
  
  	    Timer.sleep( 5.0 ) // wait 5s
  	}
  
  	HMI.display("Program Ended\n")
  }  </pre></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="orocos-corba"></a>Chapter 4. Distributing Orocos Components with CORBA</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#idp46525586666576">1. The CORBA Transport</a></span></dt><dt><span class="section"><a href="#idp46525587249424">2. Setup CORBA Naming (Required!)</a></span></dt><dt><span class="section"><a href="#idp46525585909808">3. Connecting CORBA components</a></span></dt><dt><span class="section"><a href="#idp46525584767392">4. In-depth information</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525584768704">4.1. Status</a></span></dt><dt><span class="section"><a href="#idp46525584774160">4.2. Limitations</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525584778208">5. Code Examples</a></span></dt><dt><span class="section"><a href="#idp46525586944400">6. Timing and time-outs</a></span></dt><dt><span class="section"><a href="#idp46525586947552">7. Orocos Corba Interfaces</a></span></dt><dt><span class="section"><a href="#idp46525586956784">8. The Naming Service</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525586961856">8.1. Example</a></span></dt></dl></dd></dl></div><div class="abstract"><p class="title"><strong>Abstract</strong></p><p>
	This document explains the principles of the
	<span class="emphasis"><em>Corba Transport</em></span> of <acronym class="acronym">Orocos</acronym>, the <span class="emphasis"><em>Open
	RObot COntrol Software</em></span> project. It enables transparant
	deployment accross networked nodes of plain Orocos C++ components.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525586666576"></a>1. The CORBA Transport</h2></div></div></div><p>
      This transport allows Orocos components to live in separate processes,
      distributed over a network and still communicate with each other.
      The underlying middleware is CORBA, but no CORBA knowledge is
      required to distribute Orocos components.
    </p><p>
      The Corba transport provides:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Connection and communication of Orocos components over a network or between two processes on the same computer.</p></li><li class="listitem"><p>Clients (like visualisation) making a connection to any running Orocos component using the IDL interface.</p></li><li class="listitem"><p>Transparant use: no recompilation of existing components required.
	The library acts as a run-time plugin.</p></li></ul></div><p> 
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525587249424"></a>2. Setup CORBA Naming (Required!)</h2></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>Follow these instructions carefully or your setup will not work !</p></td></tr></table></div><p>
	In order to distribute Orocos components over a network, your
	computers must be setup correctly for using Corba.
	Start a Corba Naming Service once with
	multicasting on. Using the TAO Naming Service, this would be:
	</p><pre class="screen">
  $ Naming_Service -m 1 &amp;</pre><p>
	And your application as:
	</p><pre class="screen">
  $ deployer-corba-gnulinux</pre><p>
	<span class="emphasis"><em>OR:</em></span> if that fails, start the
	Naming Service with the following options set:
	</p><pre class="screen">
  $ Naming_Service -m 0 -ORBListenEndpoints iiop://<span class="emphasis"><em>&lt;the-ns-ip-address&gt;</em></span>:2809 -ORBDaemon</pre><p>
	The <span class="emphasis"><em>&lt;the-ns-ip-address&gt;</em></span> must
	be replaced with the ip address of a network interface of the
	computer where you start the Naming Service. And each computer
	where your start the application:
	</p><pre class="screen">
  $ export NameServiceIOR=corbaloc:iiop:&lt;the-ns-ip-address&gt;:2809/NameService
  $ deployer-corba-gnlinux</pre><p>
	With <span class="emphasis"><em>&lt;the-ns-ip-address&gt;</em></span> the same as above.
			</p><p>
				For more detailed information or if your deployer does not find the
				Naming Service, take a look at this page: 
				<a class="ulink" href="http://www.orocos.org/wiki/rtt/frequently-asked-questions-faq/using-corba" target="_top">Using CORBA</a>
			</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525585909808"></a>3. Connecting CORBA components</h2></div></div></div><p>
			Normally, the Orocos deployer will create connections for you between
			CORBA components. Be sure to read the <a class="ulink" href="http://www.orocos.org/stable/documentation/ocl/v2.x/doc-xml/orocos-deployment.html" target="_top">OCL DeploymentComponent Manual</a>
			for detailed instructions on how you can setup components such
			that the can be used from another process.
		</p><p>
			This is an example deployment script '<code class="filename">server-script.ops</code>' for creating
			your first process and making one component available in the network:
			</p><pre class="programlisting">
  import("ocl")                               // make sure ocl is loaded

  loadComponent("MyComponent","TaskContext")  // Create a new default TaskContext
  server("MyComponent",true)                  // make MyComponent a CORBA server, and
                                              // register it with the Naming Service ('true')
			</pre><p>
			You can start this application with:
			</p><pre class="screen">$ deployer-corba-gnulinux -s server-script.ops</pre><p>
		</p><p>
			In another console, start a client program '<code class="filename">client-script.ops</code>' that
			wishes to use this component:
			</p><pre class="programlisting">
  import("ocl")                               // make sure ocl is loaded

  loadComponent("MyComponent","CORBA")        // make 'MyComponent' available in this program
	MyComponent.start()                         // Use the component as usual...connect ports etc.
			</pre><p>
			You can start this application with:
			</p><pre class="screen">$ deployer-corba-gnulinux -s client-script.ops</pre><p>
		</p><p>
			More CORBA deployment options are described in the
			<a class="ulink" href="http://www.orocos.org/stable/documentation/ocl/v2.x/doc-xml/orocos-deployment.html" target="_top">OCL DeploymentComponent Manual</a>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525584767392"></a>4. In-depth information</h2></div></div></div><p>
			You don't need this information unless you want to talk to the
			CORBA layer directly, for example, from a non-Orocos GUI application.
		</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525584768704"></a>4.1. Status</h3></div></div></div><p>
	The Corba transport aims to make the whole
	Orocos Component interface available over the network. Consult the
	<span class="emphasis"><em>Component Builder's Manual</em></span> for an overview of a Component's
	interface.
      </p><p>These Component interfaces are available:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>TaskContext interface: fully (TaskContext.idl)</p></li><li class="listitem"><p>Properties/Attributes interface: fully (ConfigurationInterface.idl)</p></li><li class="listitem"><p>OperationCaller/Operation interface: fully (OperationInterface.idl)</p></li><li class="listitem"><p>Service interface: fully (Service.idl, ServiceRequester.idl)</p></li><li class="listitem"><p>Data Flow interface: fully (DataFlow.idl)</p></li></ul></div><p> 
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525584774160"></a>4.2. Limitations</h3></div></div></div><p>
	The following limitations apply:
	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>You need the <span class="command"><strong>typegen</strong></span> command from the 'orogen'
		package in order to communicate custom structs/data types between components.
	  </p></li><li class="listitem"><p>Interacting with a remote component using the CORBA transport
	      will never be real-time. The only exception to this rule is when using the data flow
	      transport: reading and writing data ports is always real-time, the transport
	      of the data itself is not a real-time process.
	  </p></li></ul></div><p>
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525584778208"></a>5. Code Examples</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>You only need this example code if you don't use the deployer application!</p></td></tr></table></div><p>
      This example assumes that you have taken a look at the 'Component Builder's
      Manual'. It creates a simple 'Hello World' component and makes it available
      to the network. Another program connects to that component and starts the
      component interface browser in order to control the 'Hello World' component.
      Both programs may be run on the same or on different computers, given that
      a network connection exists.
    </p><p>
      In order to setup your component to be available to other components
      <span class="emphasis"><em>transparantly</em></span>, proceed as:
      </p><pre class="programlisting">  // server.cpp
  #include &lt;rtt/transports/corba/TaskContextServer.hpp&gt;

  #include &lt;rtt/Activity.hpp&gt;
  #include &lt;rtt/TaskContext.hpp&gt;
  #include &lt;rtt/os/main.h&gt;

  using namespace RTT;
  using namespace RTT::corba;

  int ORO_main(int argc, char** argv)
  {
     // Setup a component
     <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a> mycomponent("HelloWorld");
     // Execute a component
     mycomponent.setActivity( new <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a>(1, 0.01 );
     mycomponent.start();

     // Setup Corba and Export:
     <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1corba_1_1TaskContextServer.html">TaskContextServer</a>::InitOrb(argc, argv);
     TaskContextServer::Create( &amp;mycomponent );

     // Wait for requests:
     TaskContextServer::RunOrb();
      
     // Cleanup Corba:
     TaskContextServer::DestroyOrb();
     return 0;
  } </pre><p>
    </p><p>
      Next, in order to connect to your component, you need to create
      a 'proxy' in another file:
      </p><pre class="programlisting">  // client.cpp
  #include &lt;rtt/transports/corba/TaskContextServer.hpp&gt;
  #include &lt;rtt/transports/corba/TaskContextProxy.hpp&gt;

  #include &lt;ocl/TaskBrowser.hpp&gt;
  #include &lt;rtt/os/main.h&gt;

  using namespace RTT::corba;
  using namespace RTT;

  int ORO_main(int argc, char** argv)
  {
     // Setup Corba:
     <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1corba_1_1TaskContextServer.html">TaskContextServer</a>::InitOrb(argc, argv);

     // Setup a thread to handle call-backs to our components.
     <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1corba_1_1TaskContextServer.html">TaskContextServer</a>::ThreadOrb();

     // Get a pointer to the component above
     <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1TaskContext.html">TaskContext</a>* component = TaskContextProxy::Create( "HelloWorld" );

     // Interface it:
     <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../../../ocl/v2.x/api/html/classOCL_1_1TaskBrowser.html">TaskBrowser</a> browse( component );
     browse.loop();

     // Stop ORB thread:
     <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1corba_1_1TaskContextServer.html">TaskContextServer</a>::ShutdownOrb();
     // Cleanup Corba:
     TaskContextServer::DestroyOrb();
     return 0;
  } </pre><p>
    </p><p>
      Both examples can be found in the <code class="filename">corba-example</code>
      package on Orocos.org. You may use 'connectPeers' and the related methods
      to form component networks. Any Orocos component can be 'transformed' in
      this way.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525586944400"></a>6. Timing and time-outs</h2></div></div></div><p>
      By default, a remote method invocation waits until the remote
      end completes and returns the call, or an exception is
      thrown. In case the caller only wishes to spend a limited amount
      of time for waiting, the TAO Messaging service can be
      used. OmniORB to date does not support this service. TAO allows timeouts
      to be specified on ORB level, object (POA) level and method level. Orocos
      currently only supports ORB level, but if necessary, you can apply
      the configuration yourself to methods or objects by accessing the 'server()'
      method and casting to the correct CORBA object type.
    </p><p>
      In order to provide the ORB-wide timeout value in seconds, use:
      </p><pre class="programlisting">
	// Wait no more than 0.1 seconds for a response.
	ApplicationSetup::InitORB(argc, argv, 0.1);</pre><p>
      TaskContextProxy and TaskContextServer inherit from ApplicationSetup,
      so you might as well use these classes to scope InitORB.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525586947552"></a>7. Orocos Corba Interfaces</h2></div></div></div><p>
      Orocos does not require IDL or CORBA knowledge of the user when two
      Orocos components communicate. However, if you want to access an
      Orocos component from a non-Orocos program (like a MSWindows GUI), 
      you need to use the IDL files of Orocos.
    </p><p>
      The relevant files are:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">TaskContext.idl</code>: The main Component Interface file, providing CORBA access to a TaskContext.</p></li><li class="listitem"><p><code class="filename">Service.idl</code>: The interface of services by a component</p></li><li class="listitem"><p><code class="filename">ServiceRequester.idl</code>: The interface of required services by a component</p></li><li class="listitem"><p><code class="filename">OperationInterface.idl</code>: The interface for calling or sending operations.</p></li><li class="listitem"><p><code class="filename">ConfigurationInterface.idl</code>: The interface for attributes and properties.</p></li><li class="listitem"><p><code class="filename">DataFlow.idl</code>: The interface for communicating buffered or unbufferd data.</p></li></ul></div><p> 
      All data is communicated with CORBA::Any types. The way of using
      these interfaces is very similar to using Orocos in C++, but using
      CORBA syntax.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525586956784"></a>8. The Naming Service</h2></div></div></div><p>
      Orocos uses the CORBA Naming Service such that components can
      find each other on the same or different networked stations.
			See also <a class="ulink" href="http://www.orocos.org/wiki/rtt/frequently-asked-questions-faq/using-corba" target="_top">Using CORBA</a>
			for a detailed overview on using this program in various network
			environments or for troubleshooting.
    </p><p>
      The components are registered under the naming context path
      "TaskContexts/<span class="emphasis"><em>ComponentName</em></span>"
      (<span class="emphasis"><em>id</em></span> fields). The <span class="emphasis"><em>kind</em></span>
      fields are left empty. Only the components which were explicitly
      exported in your code, using
      <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1corba_1_1TaskContextServer.html">TaskContextServer</a>, are added
      to the Naming Service. Others write their address as an IOR to
      a file "<span class="emphasis"><em>ComponentName</em></span>.ior", but you can 'browse'
      to other components using the exported name and then using 'getPeer()'
      to access its peer components.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525586961856"></a>8.1. Example</h3></div></div></div><p>
      Since the multicast service of the CORBA Naming_Server behaves very
      unpredictable (see <a class="ulink" href="http://www.theaceorb.com/faq/index.html#115" target="_top">this link</a>), you
      shouldn't use it.  Instead, it is better started via some extra lines in
      <code class="filename">/etc/rc.local</code>:
      </p><pre class="programlisting">
  ################################################################################
  #  Start CORBA Naming Service
  echo Starting CORBA Naming Service
  pidof Naming_Service || Naming_Service -m 0 -ORBListenEndpoints iiop://192.168.246.151:2809 -ORBDaemon
  ################################################################################ </pre><p>
      Where 192.168.246.151 should of course be replaced by your ip adres
      (using a hostname may yield trouble due to the new 127.0.1.1
      entries in /etc/hosts, we think).
    </p><p>
      All clients (i.e. both your application and the ktaskbrowser)
      wishing to connect to the Naming_Service should use the environment
      variable NameServiceIOR
      </p><pre class="screen">
  [user@host ~]$ echo $NameServiceIOR
  corbaloc:iiop:192.168.246.151:2809/NameService </pre><p>
      You can set it f.i. in your .bashrc file or on the command line via
      </p><pre class="programlisting">
  export NameServiceIOR=corbaloc:iiop:192.168.246.151:2809/NameService</pre><p>
    </p><p>
      See the orocos website for more information on compiling/running the
      ktaskbrowser.
    </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="orocos-mqueue"></a>Chapter 5. Real-time Inter-Process Data Flow using MQueue</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#idp46525594756512">1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525593489440">1.1. Status</a></span></dt><dt><span class="section"><a href="#idp46525593580272">1.2. Requirements and Setup</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525593672656">2. Transporting user types.</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525594056896">2.1. Transporting 'simple' data types</a></span></dt><dt><span class="section"><a href="#idp46525591232128">2.2. Transporting 'complex' data types</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525587038176">3. Connecting ports using the MQueue transport</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525587040592">3.1. Bare C++ connection</a></span></dt><dt><span class="section"><a href="#idp46525587045552">3.2. CORBA managed connections</a></span></dt></dl></dd></dl></div><div class="abstract"><p class="title"><strong>Abstract</strong></p><p>
	This document explains the principles of the
	<span class="emphasis"><em>MQueue Library</em></span> of <acronym class="acronym">Orocos</acronym>, the <span class="emphasis"><em>Open
	RObot COntrol Software</em></span> project. It enables real-time
	communication between processes on the same node.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525594756512"></a>1. Overview</h2></div></div></div><p>
      This transport allows to do inter-process communication between Orocos processes
      on the same node. It uses the POSIX messages queues where available. This includes
      GNU/Linux systems and Xenomai.
    </p><p>
      The MQueue transport provides:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Connection and Communication of Orocos data flow streams between processes</p></li><li class="listitem"><p>The ability to set these up using C++ syntax.</p></li><li class="listitem"><p>The ability to set these up using the Corba transport by creating the MQueue as an 'Out-Of-Band' transport.</p></li></ul></div><p> 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525593489440"></a>1.1. Status</h3></div></div></div><p>
	As of this writing, MQueues only transport data flow as streams.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525593580272"></a>1.2. Requirements and Setup</h3></div></div></div><p>
	You must enable the <code class="option">ENABLE_MQUEUE</code> flag in 
	CMake. This will, depending on your target, try to detect
	your mqueue.h header file and library. MQueue also requires the boost::serialization
	library.
      </p><p>
	Only Gnu/Linux and Xenomai installations which provide this header can be used.
      </p><p>
	The transport must get to know your data type. There are two options. If your
	data type is only Plain Old Data (POD), meaning, it does not contain any pointers
	or dynamically sized objects, the transport can byte-copy your data. 
	If your data type is more complex, it must use the boost::serialization
	library to transport your type and your type must be known to this framework.
      </p><p>
	See below on how to do this.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525593672656"></a>2. Transporting user types.</h2></div></div></div><p>
      Be sure to read the 'Writing Plugins' manual such that your data type is already
      known to the RTT framework. This section extends that work to make the known data type
      transportable over MQueues.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525594056896"></a>2.1. Transporting 'simple' data types</h3></div></div></div><p>
	Simple data types without pointers or dynamically sized objects,
	can be transported quite easily. They are added as such:
      </p><pre class="programlisting">  // myapp.cpp
  #include &lt;rtt/types/TemplateTypeInfo.hpp&gt;
  #include &lt;rtt/transports/mqueue/MQTemplateProtocol.hpp&gt;

  using namespace RTT;
  using namespace RTT::mqueue;
  using namespace RTT::types;

  struct MyData {
    double x,y,x;
    int stamp;
  };

  int ORO_main(int argc, char** argv)
  {

     // Add your type to the Orocos type system (see: Writing plugins)
     Types()-&gt;addType( new <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1types_1_1TemplateTypeInfo.html">TemplateTypeInfo</a>&lt;MyData, false&gt;("MyData") );

     // New: Install the template protocol for your data type.
     Types()-&gt;getType("MyData")-&gt;addTransport(ORO_MQUEUE_PROTOCOL_ID, new <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1mqueue_1_1MQTemplateProtocol.html">MQTemplateProtocol</a>&lt;MyData&gt;() );

     // rest of your program can now transport MyData between processes.

  } </pre><p>
      As the code shows, only one line of code is necessary to register simple types to this transport.
      </p><p>
	In practice, you'll want to write a plugin which contains this code such that your data type is loaded in every
	Orocos application that you start.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525591232128"></a>2.2. Transporting 'complex' data types</h3></div></div></div><p>
	Data types like std::vector or similar can't just be byte-copied.
	They need special treatment for reading and writing their contents.
	Orocos uses the boost::serialization library for this. This library
	already understands the standard containers (vector,list,...) and is
	easily extendable to learn your types. Adding complex data goes as such:
      </p><pre class="programlisting">  // myapp.cpp
  #include &lt;rtt/types/TemplateTypeInfo.hpp&gt;
  #include &lt;rtt/transports/mqueue/MQSerializationProtocol.hpp&gt;

  using namespace RTT;
  using namespace RTT::mqueue;
  using namespace RTT::types;

  struct MyComplexData {
    double x,y,x;
    std::vector&lt;int&gt; stamps;
    MyComplexData() { stamps.resize(10, -1); }
  };

  // New: define the marshalling using boost::serialization syntax:
  namespace boost {
  namespace serialization {

  template&lt;class Archive&gt;
  void serialize(Archive &amp; ar, MyComplexData &amp; d, const unsigned int version)
  {
    ar &amp; d.x;
    ar &amp; d.y;
    ar &amp; d.z;
    ar &amp; d.samps; // boost knows std::vector !
  }
  }
  }

  int ORO_main(int argc, char** argv)
  {

     // Add your type to the Orocos type system (see: Writing plugins). Same as simple case.
     Types()-&gt;addType( new <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1types_1_1TemplateTypeInfo.html">TemplateTypeInfo</a>&lt;MyComplexData, false&gt;("MyComplexData") );

     // New: Install the Serialization template protocol for your data type.
     Types()-&gt;getType("MyComplexData")-&gt;addTransport(ORO_MQUEUE_PROTOCOL_ID, new <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1mqueue_1_1MQSerializationProtocol.html">MQSerializationProtocol</a>&lt;MyComplexData&gt;() );

     // rest of your program can now transport MyComplexData between processes.

  } </pre><p>
      When comparing this to the previous section, only two things changed: We defined
      a serialize() function, and used the MQSerializationProtocol instead of the MQTemplateProtocol
      to register our data transport. You can find a tutorial on writing your own serialization
      function on: <a class="ulink" href="http://www.boost.org/doc/libs/1_40_0/libs/serialization/doc/index.html" target="_top">The Boost Serialization Website</a>.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525587038176"></a>3. Connecting ports using the MQueue transport</h2></div></div></div><p>
      Orocos will not try to use this transport by default when connecting
      data flow ports. You must tell it explicitly to do so. This is 
      done using the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1ConnPolicy.html">ConnPolicy</a> object, which
      describes how connections should be made. 
    </p><p>
      In addition to filling in this object, you need to setup an outgoing
      data stream on the output port, and an incomming data stream at the
      input port which you wish to connect. This can be done in C++ with
      or without the help from the CORBA transport.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525587040592"></a>3.1. Bare C++ connection</h3></div></div></div><p>
	If you don't want to use CORBA for setting up a connection,
	you need to use the createStream function to setup a data flow
	stream in each process. This requires you to choose a name
	of the connection and use this name in both processes:
      </p><pre class="programlisting">// process1.cpp:
 
  // Your port is probably created in a component:
  OutputPort&lt;MyData&gt; p_out("name");

  // Create a ConnPolicy object:
  ConnPolicy policy = buffer(10); // buffered connection with 10 elements.
  policy.transport = ORO_MQUEUE_PROTOCOL_ID; // the MQueue protocol id
  policy.name_id   = "mydata_conn";          // the connection id

  p_out.createStream( policy );
  // done in proces1.cpp

// process2.cpp:

  // Your port is probably created in a component:
  InputPort&lt;MyData&gt; p_in("indata");

  // Create a ConnPolicy object:
  ConnPolicy policy = ConnPolicy::buffer(10); // buffered connection with 10 elements.
  policy.transport = ORO_MQUEUE_PROTOCOL_ID; // the MQueue protocol id
  policy.name_id   = "mydata_conn";          // the connection id

  p_in.createStream( policy );
  // done in proces2.cpp . We can now transmit data from process1 to
  // process2 .
</pre><p>
       Both ends must specify the same connection policy. Also, the
       RTT assumes that the createStream is first done on the output
       side, and then on the input side. This is because it is an
       error to connect an input side without an output side producing
       data.  When an output side opens a connection, it will send in
       a test data sample, which will notify the input side that
       someone is sending, and that the connection is probably
       correctly set up.
      </p><p>
	If either output or input would disapear after the connection
	has been setup (because their process crashed or did not clean
	up), the other side will not notice this.  You can re-start
	your component, and the ports will find each other again.
      </p><p>
	If you want proper connection management, you need to use
	the CORBA approach below, which keeps track of appearing and
	disappearing connections.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525587045552"></a>3.2. CORBA managed connections</h3></div></div></div><p>
      The CORBA transport supports 'Out-Of-Band' (OOB) connections for data flow.
      This means that CORBA itself is used to setup the connection between
      both ports, but the actual data transfer is done using OOB protocol.
      In our case, CORBA will be used to setup or destroy MQueue streams.
    </p><p>
      This has several advantages: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> 
	  Dead streams are cleaned up. CORBA can detect connection loss.
	</p></li><li class="listitem"><p>
	  You don't need to figure out a common connection name, the transport
	  will find one for you and CORBA will sync both sides.
	</p></li><li class="listitem"><p>
	  Creating out-of-band connections using the CORBA transport
	  has the same syntax as creating normal connections.
	</p></li><li class="listitem"><p> 
	  The CORBA transport will make sure that first your output
	  stream is created and then your input stream, and will cleanup
	  the output stream if the input stream could not be created.
	</p></li></ul></div><p> 
      So it's more robust, but it requires the CORBA transport.
    </p><p>
      An Out-Of-Band connection is always setup like this:
      </p><pre class="programlisting">  TaskContext *task_a, *task_b;
  // init task_a, task_b...

  ConnPolicy policy = ConnPolicy::buffer(10);

  // override default transport policy to trigger out-of-band:
  policy.transport = ORO_MQUEUE_PROTOCOL_ID;

  // this is the standard way for connecting ports:
  task_a-&gt;ports()-&gt;getPort("name")-&gt;connectTo( task_b-&gt;ports()-&gt;getPort("outdata"), policy );
      </pre><p>
      The important part here is that a policy.transport is set, while using the connectTo
      function of <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1PortInterface.html">PortInterface</a>. Normally, setting the
      transport is not necessary, because the RTT will figure out itself what the best
      means of transport is. For example, if both ports are in the same process, a direct
      connection is made, if one or both components are proxies, the transport will use
      the transport of the proxies, in our case CORBA. However, the transport flag overrides
      this, and the connection logic will pick this up and use the specified transport.
    </p><p>
      Overriding the transport parameter even works when you want to test over-CORBA
      or over-MQueue transport with using two process-local ports. The only thing to
      do is to set the transport parameter to the protocol ID.
    </p><p>
      Finally, if you want to use the CORBA IDL interface to connect two ports over
      the mqueue transport, the workflow is fairly identical. The code below is
      for C++, but the equivalent can be done in any CORBA enabled language:
    </p><p>
      </p><pre class="programlisting">  #include &lt;rtt/transports/corba/CorbaConnPolicy.hpp&gt;
  // ...
  using namespace RTT::corba;

  CControlTask_var task_a, task_b;
  // init task_a, task_b...

  CConnPolicy cpolicy = toCORBA( RTT::ConnPolicy::buffer(10) );

  // override default transport policy to trigger out-of-band:
  cpolicy.transport = ORO_MQUEUE_PROTOCOL_ID;

  // this is the standard way for connecting ports in CORBA:
  CDataFlowInterface_var dataflow_a = task_a-&gt;ports();
  CDataFlowInterface_var dataflow_b = task_b-&gt;ports();

  dataflow_a-&gt;createConnection("name", dataflow_b, "outdata", cpolicy );
      </pre><p>
      Similar as connectTo above, the createConnection function creates a fully
      managed connection between two data flow ports. We used the toCORBA function
      from CorbaConnPolicy.hpp to convert RTT policy objects to CORBA policy objects.
      Both RTT::ConnPolicy and RTT::corba::CConnPolicy structs are exactly the same,
      but RTT functions require the former and CORBA functions the latter.
    </p><p>
      Alternatively, you can use the create streams functions directly from
      the CORBA interface, in order to create unmanaged streams. In that case,
      the code becomes:
      </p><pre class="programlisting">  #include &lt;rtt/transports/corba/CorbaConnPolicy.hpp&gt;
  // ...
  using namespace RTT::corba;

  CControlTask_var task_a, task_b;
  // init task_a, task_b...

  CConnPolicy cpolicy = toCORBA( RTT::ConnPolicy::buffer(10) );

  // override default transport policy and provide a name:
  cpolicy.transport = ORO_MQUEUE_PROTOCOL_ID;
  cpolicy.name_id = "stream_name";

  // this is the standard way for connecting ports in CORBA:
  CDataFlowInterface_var dataflow_a = task_a-&gt;ports();
  CDataFlowInterface_var dataflow_b = task_b-&gt;ports();

  dataflow_b-&gt;createStream("outdata", cpolicy );
  dataflow_a-&gt;createStream("name", cpolicy );
      </pre><p>
      Note that creating message queues like this leaves out all management
      code and will not detect broken connections. It has the same constraints
      as if the streams were setup in C++, as shown in the previous section.
    </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="orocos-corelib"></a>Chapter 6. Core Primitives Reference</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#idp46525597607536">1. Introduction</a></span></dt><dt><span class="section"><a href="#corelib-activities">2. Activities</a></span></dt><dd><dl><dt><span class="section"><a href="#corelib-periodic-activity">2.1. Executing a Function Periodically</a></span></dt><dt><span class="section"><a href="#corelib-non-periodic-activity">2.2. Non Periodic Activity Semantics</a></span></dt><dt><span class="section"><a href="#idp46525586985760">2.3. Selecting the Scheduler</a></span></dt><dt><span class="section"><a href="#corelib-slave-activity">2.4. Custom or Slave Activities</a></span></dt><dt><span class="section"><a href="#corelib-threads">2.5. Configuring the Threads from Activities</a></span></dt></dl></dd><dt><span class="section"><a href="#corelib-events">3. Signals</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597213648">3.1. Signal Basics</a></span></dt><dt><span class="section"><a href="#idp46525597233856">3.2. <code class="function">setup()</code> and the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Handle.html">Handle</a> object</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525597241840">4. Time Measurement and Conversion</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597242592">4.1. The TimeService</a></span></dt><dt><span class="section"><a href="#idp46525597245824">4.2. Usage Example</a></span></dt></dl></dd><dt><span class="section"><a href="#corelib-attributes">5. Attributes</a></span></dt><dt><span class="section"><a href="#corelib-properties">6. Properties</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597255808">6.1. Introduction</a></span></dt><dt><span class="section"><a href="#idp46525597263120">6.2. Grouping Properties in a PropertyBag</a></span></dt><dt><span class="section"><a href="#idp46525597273728">6.3. Marshalling and Demarshalling Properties (Serialization)</a></span></dt></dl></dd><dt><span class="section"><a href="#corelib-extras">7. Extra Stuff</a></span></dt><dd><dl><dt><span class="section"><a href="#corelib-buffers-data">7.1. Buffers and DataObjects</a></span></dt></dl></dd><dt><span class="section"><a href="#corelib-logging">8. Logging</a></span></dt></dl></div><div class="abstract"><p class="title"><strong>Abstract</strong></p><p>
	This document explains the principles of the
	<span class="emphasis"><em>Core Library</em></span> of <acronym class="acronym">Orocos</acronym>, the <span class="emphasis"><em>Open
	RObot COntrol Software</em></span> project. The CoreLib provides
	infrastructural support for the functional and application components
	of the <acronym class="acronym">Orocos</acronym> framework.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525597607536"></a>1. Introduction</h2></div></div></div><p>
      This Chapter describes the semantics of the services
      available as the <acronym class="acronym">Orocos</acronym> Core Primitives
    </p><p>
      The Core Primitives are:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Thread-safe C++ implementations for periodic, non periodic and event driven activities</p></li><li class="listitem"><p>Synchronous/Asynchronous OperationCaller invocations</p></li><li class="listitem"><p>Synchronous callback handling</p></li><li class="listitem"><p>Property trees</p></li><li class="listitem"><p>Time measurement</p></li><li class="listitem"><p>Application logging framework</p></li><li class="listitem"><p>Lock-free data exchange primitives such as FIFO buffers or shared data.</p></li></ul></div><p> 
    </p><div class="blockquote"><blockquote class="blockquote"><p>
	<span class="emphasis"><em> The goal of the infrastructure is to keep
	applications deterministic and avoiding the classical pitfalls
	of letting application programmers freely use threads and
	mutexes as bare tools.</em></span>
      </p></blockquote></div><p>
      The following sections will first introduce the reader to creating
      Activities, which execute functions in a thread, in the system. 
      Signals allow synchronous callback functions to be executed when other
      primitives are used. Operations are used to expose services.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="corelib-activities"></a>2. Activities</h2></div></div></div><p>
      An Activity executes a function when a 'trigger' occurs. Although, 
      ultimately, an activity is executed by a thread, it does not map
      one-to-one on a thread. A thread may execute ('serialise') multiple
      activities. This section gives an introduction to defining periodic activities,
      which are triggered periodically, non periodic activities, which are triggered
      by the user, and slave activities, which are run when another activity executes.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="corelib-periodic-activity"></a>2.1. Executing a Function Periodically</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	When you use a TaskContext, the ExecutionEngine is the function
	to be executed periodically and you don't need to write the classes
	below.
      </p></td></tr></table></div><p>
	There are two ways to run a function in a periodically. By :
	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
	      Implementing the
	      <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1RunnableInterface.html">RunnableInterface</a> in
	      another class ( functions initialize(), step() or
	      loop()/breakLoop() and finalize() ). The
	      RunnableInterface object (i.e. run_impl) can be assigned
	      to a activity using </p><pre class="synopsis"> activity.run(
	      &amp;run_impl )</pre><p> or at construction time of an
	      Activity : </p><pre class="synopsis"> Activity activity(priority,
	      period, &amp;run_impl );</pre><p>.
	    </p><p>
	      </p><pre class="programlisting">  #include &lt;rtt/RunnableInterface.hpp&gt;
  #include &lt;rtt/Activity.hpp&gt;

  class MyPeriodicFunction
	: public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1RunnableInterface.html">RunnableInterface</a>
  {
  public:
    // ...
    bool initialize() {
       // your init stuff
       myperiod = this-&gt;getActivity()-&gt;getPeriod();
       isperiodic = this-&gt;getActivity()-&gt;isPeriodic();
       
       // ...
       return true; // if all went well
    }

    // executed when isPeriodic() == true
    void step() {
       // periodic actions
    }

    // executed when isPeriodic() == false
    void loop() {
       // 'blocking' version of step(). Implement also breakLoop()
    }

    void finalize() {
       // cleanup
    }
  };

  // ...
  MyPeriodicFunction run_impl_1;
  MyPeriodicFunction run_impl_2;

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a> activity( 15, 0.01 ); // priority=15, period=100Hz
  activity.run( &amp;run_impl_1 );
  activity.start(); // calls 'step()'

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a> npactivity(12); // priority=12, no period.
  npactivity.run( &amp;run_impl_2);
  activity.start(); // calls 'loop()'

  // etc...  </pre><p>
	    </p></li><li class="listitem"><p>
	      Inheriting from an Activity class and overriding the initialize(), step()
	      and finalize() methods.
	      </p><pre class="programlisting">
  class MyOtherPeriodicFunction
      : public <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a>
  {
  public :
    MyOtherPeriodicFunction()
      : <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a>( 15, 0.01 ) // priority=15, period=100Hz
    {
    }

    bool initialize() {
       // your init stuff
       double myperiod = this-&gt;getPeriod();
       // ...
       return true; // if all went well
    }

    void step() {
       // periodic actions
    }

    void finalize() {
       // cleanup
    }
	// ...
  };

  // When started, will call your step
  MyOtherPeriodicFunction activity;
  activity.start();  </pre><p>
	    </p></li></ul></div><p>
	The Activity will detect if it must run an external RunnableInterface. If none
	was given, it will call its own virtual methods.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="corelib-non-periodic-activity"></a>2.2. Non Periodic Activity Semantics</h3></div></div></div><p>
	If you want to create an activity which reads file-IO, or displays
	information or does any other possibly blocking operation, the
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a> implementation can be
	used with a period of zero (0). When it is <code class="function">start()</code>'ed, its loop()
	method will be called exactly once and then it will wait,
	after which it can be start()'ed again.  Analogous to a periodic
	Activity, the user can implement
	<code class="function">initialize()</code>, <code class="function">loop()</code>
	and <code class="function">finalize()</code> functions in a
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1RunnableInterface.html">RunnableInterface</a> which will be used by
	the activity for executing the user's functions. Alternatively,
	you can reimplement said functions in a derived class of
	Activity.
      </p><pre class="programlisting">  int priority = 5;
  
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1RunnableInterface.html">RunnableInterface</a>* blocking_activity = ...
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a> activity( priority, blocking_activity );
  activity.start(); // calls blocking_activity-&gt;initialize()

  // now blocking_activity-&gt;loop() is called in a thread with priority 5.  
  // assume loop() finished...

  activity.start();  // executes again blocking_activity-&gt;loop()

  // calls blocking_activity-&gt;breakLoop() if loop() is still executing,
  // when loop() returned, calls blocking_activity-&gt;finalize() :
  activity.stop(); </pre><p>
	The Activity behaves differently when being non periodic
	in the way start() and stop()
	work. Only the first invocation of start() will invoke initialize() and
	then loop() once.
	Any subsequent call to start() will cause loop() to be executed again
	(if it finished in the first place).
      </p><p>	
	Since the user's loop() is allowed to block the user must reimplement the
	<code class="function">RunnableInterface::breakLoop()</code>
	function. This function must do whatever necessary to let the
	user's loop() function return (mostly set a flag).  It must return true on
	success, false if it was unable to let the loop() function
	return (the latter is the default implementation's return
	value).  <code class="function">stop()</code> then waits until loop()
	returns or aborts if <code class="function">breakLoop()</code> returns
	false. When successful, stop() executes the finalize() function.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525586985760"></a>2.3. Selecting the Scheduler</h3></div></div></div><p>
	There are at least two scheduler types in RTT: The real-time
	scheduler, ORO_SCHED_RT, and the not real-time scheduler, ORO_SCHED_OTHER.
	In some systems, both may map to the same scheduler. 
      </p><p>
	When a <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a>, it
	runs in the default 'ORO_SCHED_OTHER' scheduler with the lowest priority. You
	can specify another priority and scheduler type, by providing an extra argument
	during construction. When a priority is specified, the Activity selects the
	the ORO_SCHED_RT scheduler.
      </p><pre class="programlisting">  // Equivalent to Activity my_act(OS::HighestPriority, 0.001) :
  Activity my_act(ORO_SCHED_RT, OS::HighestPriority, 0.001);

  // Run in the default scheduler (not real-time):
  Activity other_act ( 0.01 );
      </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="corelib-slave-activity"></a>2.4. Custom or Slave Activities</h3></div></div></div><p>
	If none of the above activity schemes fit you, you can always fall back on
	the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1extras_1_1SlaveActivity.html">SlaveActivity</a>, which lets the user
	control when the activity is executed. A special function <code class="function">bool execute()</code>
	is implemented which will execute <code class="function">RunnableInterface::step()</code>
	or <code class="function">RunnableInterface::loop()</code> when called by the user.
	Three versions of the <code class="classname">SlaveActivity</code> can be constructed:
	</p><pre class="programlisting">  #include &lt;rtt/SlaveActivity.hpp&gt;

  // <span class="emphasis"><em>With master</em></span>
  // a 'master', any ActivityInterface (even SlaveActivity):
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a> master_one(9, 0.001 );
  // a 'slave', takes over properties (period,...) of 'master_one':
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1extras_1_1SlaveActivity.html">SlaveActivity</a> slave_one( &amp;master_one );

  slave_one.start();   // fail: master not running.
  slave_one.execute(); // fail: slave not running.

  master_one.start();  // start the master.
  slave_one.start();   // ok: master is running.
  slave_one.execute(); // ok: calls step(), repeat...
  
  // <span class="emphasis"><em>Without master</em></span>
  // a 'slave' without explicit master, with period of 1KHz.
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1extras_1_1SlaveActivity.html">SlaveActivity</a> slave_two( 0.001 );
  // a 'slave' without explicit master, not periodic.
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1extras_1_1SlaveActivity.html">SlaveActivity</a> slave_three;

  slave_two.start();   // ok: start periodic without master
  slave_two.execute(); // ok, calls 'step()', repeat...
  slave_two.stop();

  slave_three.start();   // start not periodic.
  slave_three.execute(); // ok, calls 'loop()', may block !
  // <span class="emphasis"><em>if loop() blocks, execute() blocks as well.</em></span>
	</pre><p>
      </p><p>
	Note that although there may be a master, it is still the
	user's responsibility to get a pointer to the slave and
	call <code class="function">execute()</code>.
      </p><p>
	There is also a <code class="function">trigger()</code> function for
	slaves with a non periodic
	master. <code class="function">trigger()</code> will in that case call
	trigger() upon the master thread, which will cause it to
	execute. The master thread is then still responsible to call
	execute() on the slave. In constrast, calling
	<code class="function">trigger()</code> upon periodic slaves or periodic
	activities will always fail. Periodic activities are triggered
	internally by the elapse of time.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="corelib-threads"></a>2.5. Configuring the Threads from Activities</h3></div></div></div><p>
	Each Orocos Activity (periodic, non periodic and event driven)
	type has a <code class="function">thread()</code> method in its
	interface which gives a non-zero pointer to a
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1ThreadInterface.html">ThreadInterface</a> object which provides
	general thread information such as the priority and periodicity and allows to
	control the real-timeness of the thread which runs this activity. A
	non periodic activity's thread will return a period of zero.
      </p><p>
	A <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1RunnableInterface.html">RunnableInterface</a> can get the same information
	through the <code class="function">this-&gt;getActivity()-&gt;thread()</code> method calls.
      </p><p>
	</p><div class="example"><a id="idp46525597207152"></a><p class="title"><strong>Example 6.1. Example Periodic Thread Interaction</strong></p><div class="example-contents"><p>
	    This example shows how to manipulate a thread.
	</p><pre class="programlisting">#include "rtt/ActivityInterface.hpp"

using namespace RTT;

ORO_main( int argc, char** argv)
{
  // ... create any kind of Activity like above.

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1ActivityInterface.html">ActivityInterface</a>* act = ...

  // stop the thread and all its activities:
  act-&gt;thread()-&gt;stop();
  // change the period:
  act-&gt;thread()-&gt;setPeriod( 0.01 );

  // ORO_SCHED_RT: real-time  ORO_SCHED_OTHER: not real-time.
  act-&gt;thread()-&gt;setScheduler(ORO_SCHED_RT);

  act-&gt;thread()-&gt;start();

  // act is running...

  return 0;
}</pre></div></div><p><br class="example-break" />
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="corelib-events"></a>3. Signals</h2></div></div></div><p>
      An <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1Signal.html">Signal</a> is an object to
      which one can connect callback functions. When the Signal is
      raised, the connected functions are called one after the
      other. An Signal can carry data and deliver it to the function's
      arguments.
    </p><p>
      Any kind of function can be connected to the signal as long as it has the
      same signature as the Signal. 'Raising', 'firing' or 'emitting' an Orocos Signal is
      done by using <code class="methodname">operator()</code>.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597213648"></a>3.1. Signal Basics</h3></div></div></div><div class="example"><a id="core-event-example"></a><p class="title"><strong>Example 6.2. Using Signals</strong></p><div class="example-contents"><p>
	This example shows how a handler is connected to an Signal.
      </p></div></div><br class="example-break" /><p>
      </p><pre class="programlisting"> #include &lt;rtt/internal/Signal.hpp&gt;

 using boost::bind;

 class SafetyStopRobot {
 public:
    void handle_now() {
        std::cout &lt;&lt; " Putting the robot in a safe state fast !" &lt;&lt; std::endl;
    }
 };

 SafetyStopRobot safety;
 </pre><p>
      </p><p>
      Now we will connect the handler function to a signal. Each event-handler connection
      is stored in a Handle object, for later reference and connection management.
      </p><pre class="programlisting"> // The &lt;..&gt; means the callback functions must be of type "void foo(void)"
 <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1Signal.html">Signal</a>&lt;void(void)&gt; emergencyStop;
 // Use ready() to see if the event is initialised.
 assert( emergencyStop.ready() );
 <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Handle.html">Handle</a> emergencyHandle;
 <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Handle.html">Handle</a> notifyHandle;

 // boost::bind is a way to connect the method of an object instance to
 // an event.
 std::cout &lt;&lt; "Register appropriate handlers to the Emergency Stop Signal\n";
 emergencyHandle = 
   emergencyStop.connect( bind( &amp;SafetyStopRobot::handle_now, &amp;safety));
 assert( emergencyHandle.connected() );</pre><p>
      </p><p>
      Finally, we emit the event and see how the handler functions are called:
      </p><pre class="programlisting"> std::cout &lt;&lt; "Emit/Call the event\n";
 emergencyStop();</pre><p>
	The program will output these messages:
      </p><pre class="screen">
     Register appropriate handlers to the Emergency Stop Signal
     Emit the event
      Putting the robot in a safe state fast !
      </pre><p>
      </p><p>
	If you want to find out how boost::bind works, see the Boost
	<a class="ulink" href="http://www.boost.org/libs/bind/bind.html" target="_top">bind manual</a>.
	You must use bind if you want to call C++ class member functions to 
	'bind' the member function to an object :
	</p><pre class="programlisting">  ClassName object;
  boost::bind( &amp;ClassName::FunctionName, &amp;object)	</pre><p>
	Where ClassName::FunctionName must have the same signature as the Signal.
	When the Signal is called,
	</p><pre class="programlisting">
  object-&gt;FunctionName( args )</pre><p>
	is executed by the Signal.
      </p><p>When you want to call free ( C ) functions, you do not need bind :
	</p><pre class="programlisting">  Signal&lt;void(void)&gt; event;
  void foo() { ... }
  event.connect( &amp;foo );</pre><p>
      </p><p>
      You must choose the type of <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1Signal.html">Signal</a> upon
      construction. This can no longer be changed once the
      <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1Signal.html">Signal</a> is created. If the type changes,
      the event() method must given other arguments. For example :
      </p><div class="example"><a id="idp46525597228224"></a><p class="title"><strong>Example 6.3. Signal Types</strong></p><div class="example-contents"><pre class="programlisting">  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1Signal.html">Signal</a>&lt;void(void)&gt; e_1;
  e_1();

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1Signal.html">Signal</a>&lt;void(int)&gt;  e_2;
  e_2( 3 );

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1Signal.html">Signal</a>&lt;void(double,double,double)&gt;  positionSignal;
  positionSignal( x, y, z);</pre></div></div><p><br class="example-break" />
    </p><p>
      Furthermore, you need to setup the connect call differently if the Signal
      carries one or more arguments :
      </p><pre class="programlisting">  SomeClass someclass;

  Signal&lt;void(int, float)&gt; event;

  // notice that for each Signal argument, you need to supply _1, _2, _3, etc...
  event.connect( boost::bind( &amp;SomeClass::foo, someclass, _1, _2 ) );

  event( 1, 2.0 );</pre><p>
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>
      The return type of callbacks is ignored and can not be recovered.
    </p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597233856"></a>3.2. <code class="function">setup()</code> and the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Handle.html">Handle</a> object</h3></div></div></div><p>
	Signal connections can be managed by using a Handle which both <code class="function">connect()</code>
	and <code class="function">setup()</code> return :
	</p><pre class="programlisting">  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1Signal.html">Signal</a>&lt;void(int, float)&gt; event;
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Handle.html">Handle</a> eh;

  // store the connection in 'eh'
  eh = event.connect( ... );
  assert( eh.connected() );

  // disconnect the function(s) :
  eh.disconnect();
  assert( !eh.connected() );

  // reconnect the function(s) :
  eh.connect();
  // connected again !
	</pre><p>
	Handle objects can be copied and will all show the same status.
	To have a connection setup, but not connected, one can write :
	</p><pre class="programlisting">  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1Signal.html">Signal</a>&lt;void(int, float)&gt; event;
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Handle.html">Handle</a> eh;

  // setup : store the connection in 'eh'
  eh = event.setup( ... );
  assert( !eh.connected() );

  // now connect the function(s) :
  eh.connect();
  assert( eh.connected() );  // connected !
	</pre><p>
	If you do not store the connection of setup(), the connection will never
	be established and no memory is leaked. If you do not use 'eh' to connect
	and destroy this object, the connection is also cleaned up. If you use
	'eh' to connect and then destroy 'eh', you can never terminate the connection,
	except by destroying the Signal itself.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525597241840"></a>4. Time Measurement and Conversion</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597242592"></a>4.1. The TimeService</h3></div></div></div><p>
	The <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1TimeService.html">TimeService</a> is implemented using the
	Singleton design pattern.
	You can query it for the current (virtual) time in clock ticks or in seconds.
	The idea here is that it is responsible for synchronising with other (distributed)
	cores, for doing, for example compliant motion with two robots. This functionality
	is not yet implemented though.
      </p><p>
	When the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1extras_1_1SimulationThread.html">SimulationThread</a> is used and started, it will change the TimeService's
	clock with each period ( to simulate time progress).
	Also other threads (!) In the system will notice this change, but
	time is guaranteed to increase monotonously.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597245824"></a>4.2. Usage Example</h3></div></div></div><p>
	Also take a look at the interface documentation.
	</p><pre class="programlisting">  #include &lt;rtt/os/TimeService.hpp&gt;
  #include &lt;rtt/Time.hpp&gt;

  TimeService::ticks timestamp = <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1TimeService.html">TimeService</a>::Instance()-&gt;getTicks();
  //...

  Seconds elapsed = TimeService::Instance()-&gt;secondsSince( timestamp );	</pre><p>
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="corelib-attributes"></a>5. Attributes</h2></div></div></div><p>
      Attributes are class members which contain a (constant) value. Orocos
      can manipulate a classes attribute when it is wrapped in an
      <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Attribute.html">Attribute</a> class. This storage allows
      it to be read by the scripting engine, to be displayed on screen or manipulated
      over a network connection.
    </p><p>
      The advantages of this class come clear when building Orocos Components,
      since it allows a component to make internal data to its scripts.
    </p><p>
      </p><div class="example"><a id="idp46525597251552"></a><p class="title"><strong>Example 6.4. Creating attributes</strong></p><div class="example-contents"><pre class="programlisting">
  // an attribute, representing a double of value 1.0:
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Attribute.html">Attribute</a>&lt;double&gt; myAttr(1.0);
  myAttr.set( 10.9 );
  double a = myAttr.get(); 

  // read-only attribute:
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Constant.html">Constant</a>&lt;double&gt; pi(3.14);
  double p = pi.get();
</pre></div></div><p><br class="example-break" />
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="corelib-properties"></a>6. Properties</h2></div></div></div><p>
      Properties are more powerful than attributes (above) since they can be
      stored to an XML format, be hierarchically structured and allow complex
      configuration. 
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597255808"></a>6.1. Introduction</h3></div></div></div><p>
	Orocos provides configuration by properties through the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Property.html">Property</a>
	class.
	They are used to store primitive data (float, strings,...) in
	a hierarchies (using <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1PropertyBag.html">PropertyBag</a>). A Property can be changed by the user and has immediate
	effect on the behaviour of the program. Changing parameters of an
	algorithm is a good example where properties can be used. Each parameter
	has a value, a name and a description. The user can ask any PropertyBag
	for its contents and change the values as they see fit. Java for
	example presents a Property API. 
	The Doxygen Property API should
	provide enough information for successfully using them in your Software Component.
	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	    Reading and writing a properties value can be done in
	    real-time. Every other transaction, like marshaling
	    (writing to disk), demarshaling (reading from disk) or
	    building the property is not a real-time operation.
	  </p><p>
	    </p><div class="example"><a id="idp46525597259584"></a><p class="title"><strong>Example 6.5. Using properties</strong></p><div class="example-contents"><pre class="programlisting">
  // a property, representing a double of value 1.0:

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Property.html">Property</a>&lt;double&gt; myProp("Parameter A","A demo parameter", 1.0); // not real-time !
  myProp = 10.9; // real-time
  double a = myProp.get(); // real-time  </pre></div></div><p><br class="example-break" />
	  </p></td></tr></table></div><p>
      </p><p>
	Properties are mainly used for two purposes. First, they allow an external
	entity to browse their contents, as they can form hierarchies using
	PropertyBags. Second, they can be written to screen, disk,
	or any kind of stream and their contents can be restored later on, for example
	after a system restart. The next sections give a short introduction to these
	two usages.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597263120"></a>6.2. Grouping Properties in a PropertyBag</h3></div></div></div><p>
	First of all, a <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1PropertyBag.html">PropertyBag</a> is not the owner of the properties it owns,
	it merely keeps track of them, it defines a logical group of properties
	belonging together. Thus when you delete a bag, the properties in it are
	not deleted, when you clone() a bag, the properties are not cloned
	themselves. PropertyBag is thus a container of pointers to Property objects.
      </p><p>
	If you want to duplicate the contents of a PropertyBag or perform recursive
	operations on a bag, you can use the helper functions we created and which
	are defined in <code class="filename">PropertyBag.hpp</code> (see Doxygen documentation).
	These operations are however, most likely not real-time.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When you want to put a PropertyBag into another PropertyBag, you need
      to make a Property&lt;PropertyBag&gt; and insert that property into the 
      first bag.</p></td></tr></table></div><p> Use <code class="methodname">add</code> to add Properties to a bag and 
       <code class="methodname">getProperty(name)</code> to
       mirror a <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Property.html">Property</a>&lt;T&gt;. Mirroring allows
       you to change and read a property which is stored in a PropertyBag: the
       property object's value acts like the original. The name and description
       are not mirrored, only copied upon initialisation:
	</p><pre class="programlisting">  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1PropertyBag.html">PropertyBag</a> bag;
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Property.html">Property</a>&lt;double&gt; w("Weight", "in kilograms", 70.5 );
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Property.html">Property</a>&lt;int&gt; pc("PostalCode", "", 3462 );

  struct BirthDate {
     BirthDate(int d, month m, int y) : day(d), month(m), year(y) {}
     int day;
     enum { jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec} month;
     int year;
  };

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Property.html">Property</a>&lt;BirthDate&gt; bd("BirthDate", " in 'BirthDate' format", BirthDate(1, apr, 1977));

  bag.add( &amp;w );
  bag.add( &amp;pc );
  bag.add( &amp;bd );

  // setup mirrors:	
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Property.html">Property</a>&lt;double&gt; weight = bag.getProperty("Weight");
  assert( weight.ready() );

  // values are mirrored:
  assert( weight.get() == w.get() );
  weight.set( 90.3 );
  assert( weight.get() == w.get() );

  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Property.html">Property</a>&lt;BirthDate&gt; bd_bis;
  assert( ! bd_bis.ready() );
  
  bd_bis = bag.getProperty("BirthDate");
  assert( bd_bis.ready() );

  // descriptions and names are not mirrored:
  assert( bd_bis.getName() == bd.getName() );
  bd_bis.setName("Date2");
  assert( bd_bis.getName() != bd.getName() );</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597273728"></a>6.3. Marshalling and Demarshalling Properties (Serialization)</h3></div></div></div><p>
	Marshalling is converting a property C++ object to a format
	suitable for transportation or storage, like XML. Demarshalling
	reconstructs the property again from the stored format. In
	Orocos, the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1marsh_1_1Marshaller.html">Marshaller</a>
	interface defines how properties can be marshalled.  The
	available marshallers (property to file) in Orocos are the
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1marsh_1_1TinyMarshaller.html">TinyMarshaller</a>,
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1marsh_1_1XMLMarshaller.html">XMLMarshaller</a>,
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1marsh_1_1XMLRPCMarshaller.html">XMLRPCMarshaller</a>,
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1marsh_1_1INIMarshaller.html">INIMarshaller</a> and the
	RTT::marsh::CPFMarshaller (only if Xerces is available).  
      </p><p>
	The inverse operation (file to property) is currently
	supported by two demarshallers:
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1marsh_1_1TinyDemarshaller.html">TinyDemarshaller</a> and the
	RTT::marsh::CPFDemarshaller (only if Xerces is available).  They
	implement the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1marsh_1_1Demarshaller.html">Demarshaller</a>
	interface.
      </p><p>
	The (de-)marshallers know how to convert native C++ types, but if you want
	to store your own classes in a Property ( like <code class="classname">BirthDate</code>
	in the example above ), the class must be added to the Orocos
	type system.
      </p><p>
	In order to read/write portably (XML) files, use the
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1marsh_1_1PropertyMarshaller.html">PropertyMarshaller</a> and
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1marsh_1_1PropertyDemarshaller.html">PropertyDemarshaller</a> classes which
	use the default marshaller behind the scenes.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="corelib-extras"></a>7. Extra Stuff</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="corelib-buffers-data"></a>7.1. Buffers and DataObjects</h3></div></div></div><p>
      The difference between Buffers and DataObjects is that DataObjects
      always contain a single value, while buffers may be empty, full or contain
      a number of values.
      Thus a <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1internal_1_1DataObject.html">DataObject</a> always returns the last value written (and a
      write always succeeds), while a buffer
      may implement a FIFO queue to store all written values (and thus can get full).
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="corelib-buffers"></a>7.1.1. Buffers</h4></div></div></div><p>
	The <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1BufferInterface.html">BufferInterface</a>&lt;T&gt; provides
	the interface for Orocos buffers. Currently the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1BufferLockFree.html">BufferLockFree</a>&lt;T&gt;
	is a typed buffer of type <span class="emphasis"><em>T</em></span> and works as
	a FIFO queue for storing elements of type T.
	It is lock-free, non blocking and read and writes
	happen in bounded time. It is not subject to priority inversions.
      </p><div class="example"><a id="idp46525597288112"></a><p class="title"><strong>Example 6.6. Accessing a Buffer</strong></p><div class="example-contents"><pre class="programlisting">  #include &lt;rtt/BufferLockFree.hpp&gt;

  // A Buffer may also contain a class, instead of the simple
  // double in this example
  // A buffer with size 10:
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1BufferLockFree.html">BufferLockFree</a>&lt;double&gt; my_Buf( 10 ); 
  if ( my_Buf.Push( 3.14 ) ) {
     // ok. not full.
  }
  double  contents; 
  if ( my_Buf.Pop( contents ) ) {
     // ok. not empty.
     // contents == 3.14
  }</pre></div></div><br class="example-break" /><p>
	 Both <code class="function">Push()</code> and <code class="function">Pop()</code>
	 return a boolean to indicate failure or success.
       </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="corelib-data-objects"></a>7.1.2. DataObjects</h4></div></div></div><p>
	The data inside the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1DataObject.html">DataObject</a>s can be any valid C++ type,
	so mostly people use classes or structs, because these carry
	more semantics than just (vectors of) doubles. The default
	constructor of the data is called when the DataObject is
	constructed.  Here is an example of creating and using a
	DataObject :
	</p><div class="example"><a id="idp46525597294496"></a><p class="title"><strong>Example 6.7. Accessing a DataObject</strong></p><div class="example-contents"><pre class="programlisting">  #include &lt;rtt/DataObjectInterfaces.hpp&gt;

  // A DataObject may also contain a class, instead of the simple
  // double in this example
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1DataObjectLockFree.html">DataObjectLockFree</a>&lt;double&gt; my_Do("MyData"); 
  my_Do.Set( 3.14 ); 
  double  contents; 
  my_Do.Get( contents );   // contents == 3.14
  contents  = my_Do.Get(); // equivalent  </pre></div></div><p><br class="example-break" />
      </p><p>
	The virtual <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1base_1_1DataObjectInterface.html">DataObjectInterface</a> interface
	provides the <code class="function">Get()</code> and
	<code class="function">Set()</code> methods that each DataObject must
	have. Semantically, <code class="function">Set()</code> and
	<code class="function">Get()</code> copy all contents of the
	DataObject.
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="corelib-logging"></a>8. Logging</h2></div></div></div><p>
      Orocos applications can have pretty complex start-up and
      initialisation code.  A logging framework, using
      <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Logger.html">Logger</a> helps to track what
      your program is doing.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Logging can
      only be done in the non-real-time parts of your application, thus not in
	the Real-time Periodic Activities !</p></td></tr></table></div><p>
      There are currently 8 log levels :
      </p><div class="table"><a id="idp46525597304112"></a><p class="title"><strong>Table 6.1. Logger Log Levels</strong></p><div class="table-contents"><table summary="Logger Log Levels" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>ORO_LOGLEVEL</th><th>Logger::enum</th><th>Description</th></tr></thead><tbody><tr><td>-1</td><td>na</td><td>Completely disable logging</td></tr><tr><td>0</td><td>Logger::Never</td><td>Never log anything (to console)</td></tr><tr><td>1</td><td>Logger::Fatal</td><td>Only log Fatal errors. System will abort immediately.</td></tr><tr><td>2</td><td>Logger::Critical</td><td>Only log Critical or worse errors. System may abort shortly after.</td></tr><tr><td>3</td><td>Logger::Error</td><td>Only log Errors or worse errors. System will come to a safe stop.</td></tr><tr><td>4</td><td>Logger::Warning</td><td>[Default] Only log Warnings or worse errors. System will try to resume anyway.</td></tr><tr><td>5</td><td>Logger::Info</td><td>Only log Info or worse errors. Informative messages.</td></tr><tr><td>6</td><td>Logger::Debug</td><td>Only log Debug or worse errors. Debug messages.</td></tr><tr><td>7</td><td>Logger::RealTime</td><td>Log also messages from possibly Real-Time contexts. Needs to be confirmed
	      by a function call to Logger::allowRealTime().</td></tr></tbody></table></div></div><p><br class="table-break" />
    </p><p>
      You can change the amount of log info printed on your console by setting the environment variable
      <code class="envar">ORO_LOGLEVEL</code> to one of the above numbers :
      </p><pre class="screen">
  export ORO_LOGLEVEL=5</pre><p>
      The default is level 4, thus only warnings and errors are printed.
    </p><p>
      The <span class="emphasis"><em>minimum</em></span> log level for the <code class="filename">orocos.log</code>
      file is <em class="parameter"><code>Logger::Info</code></em>. It will get more verbose if
      you increase <code class="envar">ORO_LOGLEVEL</code>, but will not go below Info. 
      This file is always created if the logging infrastructure is used. You can inspect this file
      if you want to know the most useful information of what is happening inside Orocos.
    </p><p>If you want to disable logging completely, use </p><pre class="screen">export ORO_LOGLEVEL=-1</pre><p>
      before you start your program.</p><p>
      For using the <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Logger.html">Logger</a> class in your own application, consult
      the API documentation.
    </p><div class="example"><a id="idp46525597331504"></a><p class="title"><strong>Example 6.8. Using the Logger class</strong></p><div class="example-contents"><pre class="programlisting">  #include &lt;rtt/Logger.hpp&gt;

  Logger::In in("MyModule");
  log( Error ) &lt;&lt; "An error Occured : " &lt;&lt; 333 &lt;&lt; "." &lt;&lt; endlog();
  log( Debug ) &lt;&lt; debugstring &lt;&lt; data &lt;&lt; endlog();
  log() &lt;&lt; " more debug info." &lt;&lt; data &lt;&lt; endlog();
  log() &lt;&lt; "A warning." &lt;&lt; endlog( Warning );</pre><p>As you can see, the Logger can be used like the standard C++ input streams.
	You may change the Log message's level using the LogLevel
	enums in front (using log() ) or at the end (using endlog()) of the log message.
	When no log level is specified, the previously set level is used.
	The above message could result in :
      </p><pre class="screen">
  0.123 [ ERROR  ][MyModule] An error Occured : 333
  0.124 [ Debug  ][MyModule] &lt;contents of debugstring and data &gt;
  0.125 [ Debug  ][MyModule]  more debug info. &lt;...data...&gt;
  0.125 [ WARNING][MyModule] A warning.</pre></div></div><br class="example-break" /></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="orocos-os"></a>Chapter 7. OS Abstraction Reference</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#idp46525605535504">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525604422496">1.1. Real-time OS Abstraction</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525602496528">2. The Operating System Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525603076768">2.1. Basics</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525604264336">3. OS directory Structure</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525600638512">3.1. The RTAI/LXRT OS target</a></span></dt><dt><span class="section"><a href="#idp46525600642064">3.2. Porting Orocos to other Architectures / OSes</a></span></dt><dt><span class="section"><a href="#idp46525600646416">3.3. OS Header Files</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525597359280">4. Using Threads and Real-time Execution of Your Program</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597359984">4.1. Writing the Program main()</a></span></dt><dt><span class="section"><a href="#idp46525597386112">4.2. The Orocos Thread</a></span></dt><dt><span class="section"><a href="#idp46525597417264">4.3. Synchronisation Primitives</a></span></dt></dl></dd></dl></div><div class="abstract"><p class="title"><strong>Abstract</strong></p><p>
	This document gives a short overview of the 
	philosophy and available classes for Operating
	System ( threads, mutexes, etc ) interaction within <acronym class="acronym">Orocos</acronym>
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525605535504"></a>1. Introduction</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525604422496"></a>1.1. Real-time OS Abstraction</h3></div></div></div><p>
	The OS layer makes an abstraction of the operating system on
	which it runs. It provides C++ interfaces to only the
	<span class="emphasis"><em>minimal set</em></span> of operating system
	primitives that it needs: time reading, mutexes, semaphores, condition variables and
	threads. The abstraction
	also allows <acronym class="acronym">Orocos</acronym> users to build their software on all
	supported systems with only a recompilation step. The OS
	Abstraction layer is not directly being used by the
	application writer.
      </p><p>
	The abstractions cause (almost) no execution overhead, because
	the wrappers can be called in-line. See the <code class="option">OROBLD_OS_AGNOSTIC</code>
	option in CMake build tool to control in-lining.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525602496528"></a>2. The Operating System Interface</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525603076768"></a>2.1. Basics</h3></div></div></div><p>
	Keeping the <acronym class="acronym">Orocos</acronym> core portable requires an extra
	abstraction of some operating system (OS) functionalities. For
	example, a thread can be created, started, paused, scheduled,
	etc., but each OS uses other function calls to do this.
	<acronym class="acronym">Orocos</acronym> prefers C++ interfaces, which led to the
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1ThreadInterface.html">ThreadInterface</a> which allows
	control and provides information about a thread in <acronym class="acronym">Orocos</acronym>.
      </p><p>
	Two thread classes are available in <acronym class="acronym">Orocos</acronym>:
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1Thread.html">Thread</a> houses our thread implementation.
	The <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1MainThread.html">MainThread</a> is a special case as
	only one such object exists and represents the thread that
	executes the main() function.
      </p><p>
	This drawing situates the Operating System abstraction with
	respect to device driver interfacing (DI) and the rest of
	<acronym class="acronym">Orocos</acronym> </p><div class="figure"><a id="idp46525604915040"></a><p class="title"><strong>Figure 7.1. OS Interface overview</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/FDIvsFOSI.png" alt="OS Interface overview" /></div></div></div><p><br class="figure-break" />
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525604264336"></a>3. OS directory Structure</h2></div></div></div><p>
      The OS directory contains C++ classes to access Operating System
      functionality, like creating threads or signaling
      semaphores. Two kinds of subdirectories are used: the CPU <span class="emphasis"><em>architecture</em></span>
      (i386, powerpc, x86_64) and the Operating System (gnulinux, xenomai, lxrt),
      or <span class="emphasis"><em>target</em></span>.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525600638512"></a>3.1. The RTAI/LXRT OS target</h3></div></div></div><p>
	RTAI/LXRT is an
	environment that allows user programs to run with real-time
	determinism next to the normal programs. The advantage is
	that the real-time application can use normal system libraries
	for its functioning, like showing a graphical user interface.
      </p><p>
	An introduction to RTAI/LXRT can be found in the <a class="ulink" href="http://people.mech.kuleuven.be/~psoetens/lxrt/portingtolxrt.html" target="_top"> 
	  Porting to LXRT HOWTO</a>, which is a must-read if you
	don't know what LXRT is.
      </p><p>
	The common rule when using LXRT is that any user space (GNU/Linux)
	library can be used and any header included as long as their non-real-time
	functions are not called from within a hard real-time thread.
	Specifically, this means that all the RTAI (and Orocos) OS functions,
	but not the native Linux ones, may be called from within
	a hard real-time thread. Fortunately these system calls
	can be done from a not hard real-time thread within the
	same program.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525600642064"></a>3.2. Porting Orocos to other Architectures / OSes</h3></div></div></div><p>
	The OS directory is the only part of the Real-Time Toolkit
	that needs to be ported to other Operating Systems or
	processor architectures in case the target supports Standard
	C++. The os directory contains code common to all OSes. The
	<span class="emphasis"><em>oro_arch</em></span> directories contain the
	architecture dependent headers (for example atomic counters
	and compare-and-swap ).
      </p><p>
	In order to start your port, look at the <code class="filename">fosi_interface.h</code>
	and <code class="filename">fosi_internal_interface.hpp</code> files in
	the os directory. These two files list the C/C++ function
	signatures of all to be ported functions in order to support
	a new Operating System. The main categories are: time reading, mutexes,
	semaphores and threads.
	The easiest way to port Orocos to another operating system, 
	is to copy the gnulinux directory into a new directory and start
	modifying the functions to match those in your OS.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525600646416"></a>3.3. OS Header Files</h3></div></div></div><p>
	The following table gives a short overview of the available
	headers in the os directory.
      </p><div class="table"><a id="idp46525600647680"></a><p class="title"><strong>Table 7.1. Header Files</strong></p><div class="table-contents"><table summary="Header Files" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Library</th><th>Which file to include</th><th>Remarks</th></tr></thead><tbody><tr><td align="center" valign="middle">OS
		functionality</td><td align="center" valign="middle">rtt/os/fosi.h</td><td align="left" valign="middle">Include this file if
		you want to make system calls to the underlying
		operating system ( LXRT, GNU/Linux ) .</td></tr><tr><td align="center" valign="middle">OS Abstraction
		classes</td><td align="center" valign="middle">
		Mutex.hpp, MutexLock.hpp, Semaphore.hpp, PeriodicThread.hpp, SingleThread.hpp,
		main.h
	      </td><td align="left" valign="middle">
		The available C++ OS primitives. main.h
		is required to be included in your ORO_main() program file.
	      </td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525597359280"></a>4. Using Threads and Real-time Execution of Your Program</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597359984"></a>4.1. Writing the Program main()</h3></div></div></div><p>
	All tasks in the real-time system have to be performed by some
	thread.  The OS abstraction expects an <code class="function">int
	  ORO_main(int argc, char** argv)</code> function (which
	the user has written) and will call that after all system
	initialisation has been done. Inside ORO_main() the user
	may expect that the system is properly set up and can be used.
	The resulting orocos-rtt library will contain the real main()
	function which will call the ORO_main() function.
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/icons/important.png" /></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>
	  Do not forget to include
	  <code class="filename">&lt;rtt/os/main.h&gt;</code> in the main program
	  file, or the linker will not find the ORO_main function.
	</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	  Using global objects ( or <span class="emphasis"><em>static</em></span> class
	  members ) which use the OS functions before ORO_main() is
	  entered (because they are constructed before main() ), can
	  come into conflict with an uninitialised system. It is
	  therefor advised not to use static global objects which use
	  the OS primitives. <code class="classname">Event</code>s in the
	  CoreLib are an example of objects which should not be
	  constructed as global static. You can use dynamically
	  created (i.e. created with <span class="emphasis"><em>new</em></span> ) global
	  events instead.
	</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597386112"></a>4.2. The Orocos Thread</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525597386848"></a>4.2.1. Threads</h4></div></div></div><p>
	  An <acronym class="acronym">Orocos</acronym> thread by the
	  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1Thread.html">Thread</a> class. The most
	  common operations are <code class="methodname">start()</code>,
	  <code class="methodname">stop()</code> and setting the periodicity.
	  What is executed is defined in an user object which
	  implements the
	  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1RunnableInterface.html">RunnableInterface</a>. It
	  contains three methods :
	  <code class="methodname">initialize()</code>,
	  <code class="methodname">step()</code> and
	  <code class="methodname">finalize()</code>. You can inherit from
	  this interface to implement your own functionality. In
	  initialize(), you put the code that has to be executed once
	  when the component is start()'ed. In step(), you put the
	  instructions that must be executed periodically. In
	  finalize(), you put the instructions that must be executed
	  right after the last step() when the component is stop()'ed.
	</p><p>
	  However, you are encouraged <span class="emphasis"><em>NOT</em></span> to use
	  the OS classes! The Core Primitives use these classes as a basis to provide a more
	  fundamental activity-based (as opposite to thread based)
	  execution mechanism which will insert your periodic activities in
	  a periodic thread.
	</p><p>
	  Common uses of periodic threads are :
	  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Running periodic control tasks.</p></li><li class="listitem"><p>Fetching periodic progress reports.</p></li><li class="listitem"><p>Running the CoreLib periodic tasks.</p></li></ul></div><p>
	</p><p>
	  A special function is forseen when the Thread executes
	  non periodically (ie getPeriod() == 0): loop(), which is 
	  executed instead of step and in which it is allowed to
	  not return (for a long time).
	</p><p>
	  The user himself is responsible for providing a mechanism to
	  return from the loop() function. The Thread expects
	  this mechanism to be implemented in the
	  breakLoop() function, which must return
	  true if the loop() function could be signaled to
	  return. Thread will call breakLoop() in its stop()
	  method if loop() is still being executed and, if successful,
	  will wait until loop() returns.  The
	  <code class="function">Thread::isRunning()</code> function can
	  be used to check if loop() is being executed or not.
	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1Activity.html">Activity</a> 
	  provides a better integrated implementation for
	  SingleThread and should be favourably used.</p></td></tr></table></div><p>
	  Common uses of non periodic threads are :
	  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Listening for data on a network socket.</p></li><li class="listitem"><p>Reading a file or files from hard-disk.</p></li><li class="listitem"><p>Waiting for user input.</p></li><li class="listitem"><p>Execute a lengthy calculation.</p></li><li class="listitem"><p>React to asynchronous events.</p></li></ul></div><p>
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525597405984"></a>4.2.2. Setting the Scheduler and Priorities.</h4></div></div></div><p>
	  The Orocos thread priorities are set during thread
	  construction time and can be changed later on with
	  <code class="function">setPriority</code>. Priorities are integer
	  numbers which are passed directly to the underlying OS. One
	  can use priorities portably by using the
	  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1LowestPriority.html">LowestPriority</a>,
	  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1HighestPriority.html">HighestPriority</a> and
	  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1IncreasePriority.html">IncreasePriority</a> variables
	  which are defined for each OS.
	</p><p>
	  OSes that support multiple schedulers can use the
	  <code class="function">setScheduler</code> function to influence
	  the scheduling policy of a given thread. Orocos guarantees
	  that the <code class="classname">ORO_SCHED_RT</code> and
	  <code class="classname">ORO_SCHED_OTHER</code> variables are 
	  defined and can be used portably. The former `hints'
	  a real-time scheduling policy, while the latter `hints'
	  a not real-time scheduling policy. Each OS may define
	  additional variables which map more appropriately to
	  its scheduler policies. When only one scheduling policy
	  is available, both variables map to the same scheduler.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525597412080"></a>4.2.3. ThreadScope: Oscilloscope Monitoring of Orocos Threads</h4></div></div></div><p>
	  You can configure the OS layer at compilation time using CMake to
	  report thread execution as block-waves on the parallel port
	  or any other digital output device.  Monitoring through the
	  parallel port requires that a parallel port Device Driver is
	  installed, and for Linux based OSes, that you execute the
	  Orocos program as root.
	</p><p>
	  If the Logger is active, it will log the mapping of
	  Threads to the device's output pins to the <code class="filename">orocos.log</code>
	  file. Just before step() is entered, the pin will be set
	  high, and when step() is left, the pin is set low again.
	  From within any RTT activity function, you may then additionally use the
	  ThreadScope driver as such :
	</p><pre class="programlisting">  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1DigitalOutInterface.html">DigitalOutInterface</a>* pp = DigitalOutInterface::nameserver.getObject("ThreadScope");
if ( pp )
    pp-&gt;setBit( this-&gt;getTask()-&gt;thread()-&gt;threadNumber(), value );
  	</pre><p>
	  which sets the corresponding bit to a boolean value. The
	  main thread claims pin zero, the other pins are assigned
	  incrementally as each new Orocos thread is created.
	</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597417264"></a>4.3. Synchronisation Primitives</h3></div></div></div><p>
	Orocos OS only provides a few synchronisation primitives,
	mainly for guarding critical sections.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525597418560"></a>4.3.1. Mutexes</h4></div></div></div><p>
	  There are two kinds of Mutexes : <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1Mutex.html">Mutex</a>
	  and <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1MutexRecursive.html">MutexRecursive</a>. To lock a mutex, it
	  has a method <code class="methodname">lock()</code>, to unlock, the method is <code class="methodname">unlock()</code> and to
	  try to lock, it is <code class="methodname">trylock()</code>.
	  A lock() and trylock() on a recursive mutex from the same
	  thread will always succeed, otherwise, it blocks.
	</p><p>
	  For ease of use, there is a <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1MutexLock.html">MutexLock</a> which
	  gets a Mutex as argument in the constructor. As long as the
	  MutexLock object exists, the given Mutex is locked. This is
	  called a scoped lock.
	</p><div class="example"><a id="idp46525603197232"></a><p class="title"><strong>Example 7.1. Locking a Mutex</strong></p><div class="example-contents"><p>The first listing shows a complete lock over a function :</p><pre class="programlisting">  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1Mutex.html">Mutex</a> m;
  void foo() {
     int i;
     <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1MutexLock.html">MutexLock</a> lock(m);
     // m is locked.
     // ...
  } // when leaving foo(), m is unlocked.  </pre><p>
	    Any scope is valid, so if the critical section is smaller than
	    the size of the function, you can :
	  </p><pre class="programlisting">  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1Mutex.html">Mutex</a> m;
  void bar() {
     int i;
     // non critical section
     {
        <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1MutexLock.html">MutexLock</a> lock(m);
        // m is locked.
        // critical section
     } //  m is unlocked.
     // non critical section
     //...
  }  </pre></div></div><br class="example-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525603202544"></a>4.3.2. Signals and Semaphores</h4></div></div></div><p>
	  Orocos provides a C++ semaphore abstraction class
	  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1Semaphore.html">Semaphore</a>. It is used mainly for 
	  non periodic, blocking tasks or threads. The higher level
	  Event implementation in CoreLib can be used for thread safe
	  signalling and data exchange in periodic tasks.
	</p><pre class="programlisting">  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1os_1_1Semaphore.html">Semaphore</a> sem(0); // initial value is zero.
  void foo() {
     // Wait on sem, decrement value (blocking ):
     sem.wait()
     // awake : another thread did signal().

     // Signal sem, increment value (non blocking):
     sem.signal();

     // try wait on sem (non blocking):
     bool result = sem.trywait();
     if (result == false ) {
         // sem.value() was zero
     } else {
         // sem.value() was non-zero and is now decremented.
     }
  }  </pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp46525603206112"></a>4.3.3. Compare And Swap ( CAS )</h4></div></div></div><p>
	  CAS is a fundamental building block of the CoreLib classes
	  for inter-thread communication and must be implemented for
	  each OS target. See the Lock-Free sections of the CoreLib manual
	  for Orocos classes which use this primitive.
	</p></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="orocos-fdi"></a>Chapter 8. Hardware Device Interfaces</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#idp46525607949296">1. The Orocos Device Interface (<acronym class="acronym">DI</acronym>)</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525597335888">1.1. Structure</a></span></dt><dt><span class="section"><a href="#idp46525609135440">1.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525603291104">2. The Device Interface Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#idp46525603292896">2.1. Physical IO</a></span></dt><dt><span class="section"><a href="#idp46525603229616">2.2. Logical Device Interfaces</a></span></dt></dl></dd><dt><span class="section"><a href="#idp46525603232800">3. Porting Device Drivers to Device Interfaces</a></span></dt><dt><span class="section"><a href="#idp46525603234336">4. Interface Name Serving</a></span></dt></dl></div><div class="abstract"><p class="title"><strong>Abstract</strong></p><p>
	This document provides a short introduction to the
	<acronym class="acronym">Orocos</acronym> Hardware Device Interface definitions. These
	are a collection of classes making abstraction of
	interacting with hardware components.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525607949296"></a>1. The Orocos Device Interface (<acronym class="acronym">DI</acronym>)</h2></div></div></div><p>
	Designing portable software which should interact with
	hardware is very hard. Some efforts, like <a class="ulink" href="http://www.comedi.org" target="_top"> Comedi</a>
	propose a generic interface to communicate with a certain kind
	of hardware (mainly analog/digital IO). This allows us to
	change hardware and still use the same code to communicate
	with it.  Therefore, we aim at supporting every Comedi
	supported card.  We invite you to help us writing a C++
	wrapper for this API and port comedilib (which adds more
	functionality) to the real-time kernels.
      </p><p>
	We do not want to force people into using Comedi, and most of
	us have home written device drivers.  To allow total
	implementation independence, we are writing C++ device
	interfaces 
	which just defines which functionalities a generic device
	driver should implement. It is up to the developers to wrap
	their C device driver into a class which implements this
	interface. You can find an example of this in the devices
	package.  This package only contains the interface header files.
	Other packages should always point to these interface files
	and never to the real drivers actually used.  It is up to the
	application writer to decide which driver will actually be
	used.
      </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525597335888"></a>1.1. Structure</h3></div></div></div><p>
	The Device Interface can be structured
	in two major parts : <span class="emphasis"><em>physical</em></span> device
	interfaces and <span class="emphasis"><em>logical</em></span> device interfaces.
	Physical device interfaces can be subdivided in four basic
	interfaces: <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1AnalogInput.html">AnalogInput</a>, <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1AnalogOutput.html">AnalogOutput</a>, 
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1DigitalInput.html">DigitalInput</a>,
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1DigitalOutput.html">DigitalOutput</a>. Analog devices
	are addressed with a channel as parameter and write a ranged
	value, while digital devices are addressed with a bit number
	as parameter and a true/false value.
      </p><p>Logical device interfaces
	represent the entities humans like to work with: a drive, a
	sensor, an encoder, etc. They put <span class="emphasis"><em>semantics</em></span> on top
	of the physical interfaces they use underneath. You just want to know the
	position of a positional encoder in radians for example.
	Often, the physical layer is device dependent (and thus
	non-portable) while the logical layer is device independent.
      </p><p> 
	</p><div class="figure"><a id="idp46525607199952"></a><p class="title"><strong>Figure 8.1. Device Interface Overview</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fdi.png" alt="Device Interface Overview" /></div></div></div><p><br class="figure-break" />
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525609135440"></a>1.2. Example</h3></div></div></div><p>An example of the
	interactions between the logical and the physical layer is the
	logical encoder with its physical counting card. An encoder is
	a physical device keeping track of the position of an axis of
	a robot or machine. The programmer wishes to use the encoder
	as a sensor and just asks for the current position. Thus a
	logical encoder might choose to implement the
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1SensorInterface.html">SensorInterface</a> which provides
	a <code class="methodname">read(DataType &amp; )</code> function.
	Upon construction of the logical sensor, we supply the real
	device driver as a parameter. This device driver implements
	for example <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1AnalogInInterface.html">AnalogInInterface</a>
	which provides <code class="methodname">read(DataType &amp; data, unsigned
	  int chan)</code> and allows to read the position of a
	certain encoder of that particular card.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525603291104"></a>2. The Device Interface Classes</h2></div></div></div><p>
	The most common used interfaces for machine control
	are already implemented and tested on multiple setups.
	All the Device Interface classes reside in the
	<code class="classname">RTT</code> namespace.
      </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525603292896"></a>2.1. Physical IO</h3></div></div></div><p>
	  There are several classes for representing
	  different kinds of IO. Currently there are:
	</p><div class="table"><a id="idp46525603294160"></a><p class="title"><strong>Table 8.1. Physical IO Classes</strong></p><div class="table-contents"><table summary="Physical IO Classes" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Interface</th><th>Description</th></tr></thead><tbody><tr><td><a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1AnalogInInterface.html">AnalogInInterface</a></td><td>Reading analog input channels</td></tr><tr><td><a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1AnalogOutInterface.html">AnalogOutInterface</a></td><td>Writing analog output channels</td></tr><tr><td><a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1DigitalInInterface.html">DigitalInInterface</a></td><td>Reading digital bits</td></tr><tr><td><a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1DigitalOutInterface.html">DigitalOutInterface</a></td><td>Writing digital bits</td></tr><tr><td>CounterInterface</td><td>Not implemented yet</td></tr><tr><td><a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1EncoderInterface.html">EncoderInterface</a></td><td>A position/turn encoder</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp46525603229616"></a>2.2. Logical Device Interfaces</h3></div></div></div><p>
	  From a logical point of view, the generic
	  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1SensorInterface.html">SensorInterface</a>&lt;T&gt; is an
	  easy to use abstraction for reading any kind 
	  of data of type T.
	</p><p>
	  You need to look in the Orocos Component Library
	  for implementations of the Device Interface.
	  Examples are <code class="classname">Axis</code> and
	  <code class="classname">AnalogDrive</code>.
	</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525603232800"></a>3. Porting Device Drivers to Device Interfaces</h2></div></div></div><p>
	The methods in each interface are well documented
	and porting existing drivers (which mostly have a C API)
	to these should be quite straight forward. It is the
	intention that the developer writes a class that
	inherits from one or more interfaces and implements
	the corresponding methods. Logical Devices can then
	use these implementations to provide higher level
	functionalities.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp46525603234336"></a>4. Interface Name Serving</h2></div></div></div><p>
	Name Serving is introduced in the Orocos CoreLib documentation.
      </p><p>
	The Device Interface provides name serving on interface level. This means
	that one can ask a certain interface by which objects it is
	implemented and retrieve the desired instance. No type-casting
	whatsoever is needed for this operation. For now, only the
	physical device layer can be queried for entities, since
	logical device drivers are typically instantiated where
	needed, given an earlier loaded physical device driver.
      </p><p>
	<a class="xref" href="#example_name_service" title="Example 8.1. Using the name service">Example 8.1, “Using the name service”</a> shows how one could query the 
	<a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1DigitalOutInterface.html">DigitalOutInterface</a>.
	  
	</p><div class="example"><a id="example_name_service"></a><p class="title"><strong>Example 8.1. Using the name service</strong></p><div class="example-contents"><pre class="programlisting">  FancyCard* fc = new FancyCard("CardName"); // FancyCard implements DigitalOutInterface

  // Elsewhere in your program:
  bool value = true;
  <a xmlns="http://www.w3.org/TR/xhtml1/transitional" href="../api/html/classRTT_1_1DigitalOutInterface.html">DigitalOutInterface</a>* card = DigitalOutInterface::nameserver.getObject("CardName");
  if (card)
      card-&gt;setBit(0, value);    // Set output bit to 'true'. </pre></div></div><p><br class="example-break" />
      </p></div></div></div></body></html>