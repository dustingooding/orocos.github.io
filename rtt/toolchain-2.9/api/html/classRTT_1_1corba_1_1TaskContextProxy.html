<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Orocos Real-Time Toolkit: RTT::corba::TaskContextProxy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a></li><li class="navelem"><a class="el" href="namespaceRTT_1_1corba.html">corba</a></li><li class="navelem"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html">TaskContextProxy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classRTT_1_1corba_1_1TaskContextProxy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RTT::corba::TaskContextProxy Class Reference<div class="ingroups"><a class="el" href="group__CompIDL.html">Component IDL and Corba Setup</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class manages the access of remote <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> Corba Servers and a Corba Object Request Broker (Orb) which connects to these servers.  
 <a href="classRTT_1_1corba_1_1TaskContextProxy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TaskContextProxy_8hpp_source.html">rtt/transports/corba/TaskContextProxy.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTT::corba::TaskContextProxy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRTT_1_1corba_1_1TaskContextProxy.png" usemap="#RTT::corba::TaskContextProxy_map" alt=""/>
  <map id="RTT::corba::TaskContextProxy_map" name="RTT::corba::TaskContextProxy_map">
<area href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. " alt="RTT::TaskContext" shape="rect" coords="0,56,181,80"/>
<area href="structRTT_1_1corba_1_1ApplicationServer.html" title="A class which an provides ORB to the application process. " alt="RTT::corba::ApplicationServer" shape="rect" coords="191,56,372,80"/>
<area href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task. " alt="RTT::base::TaskCore" shape="rect" coords="0,0,181,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab7c900f8e0cd86dbc1383d17462b20b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7c900f8e0cd86dbc1383d17462b20b9"></a>
typedef std::map<br class="typebreak"/>
&lt; <a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html">TaskContextProxy</a> <br class="typebreak"/>
*, corba::CTaskContext_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PMap</b></td></tr>
<tr class="separator:ab7c900f8e0cd86dbc1383d17462b20b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ebba86c109e257343eb1f432e97079"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1ebba86c109e257343eb1f432e97079"></a>
typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#ac1ebba86c109e257343eb1f432e97079">PeerList</a></td></tr>
<tr class="memdesc:ac1ebba86c109e257343eb1f432e97079"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of Peer <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> names. <br/></td></tr>
<tr class="separator:ac1ebba86c109e257343eb1f432e97079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec42df6b1b306b7a7102fa3bf8e2a296"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296">TaskState</a> { <br/>
&#160;&#160;<a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296ad0f498835f4c0d0d028f17c3dded1808">Init</a>, 
<a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296a18beb1736430c2815bb79cc43d55a5a4">PreOperational</a>, 
<a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296aede93da035b525de95b4682f8a986dd4">FatalError</a>, 
<a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296aaf7a566a0f56822986b292ae5e90a286">Exception</a>, 
<br/>
&#160;&#160;<a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296a56134dbafdb46e41026cf4c7b1bbb6f8">Stopped</a>, 
<a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296ae9b19cff8d2fde7929812f4108ce80f4">Running</a>, 
<a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296a176c10977c372f2762335620a6382bb4">RunTimeError</a>
<br/>
 }</td></tr>
<tr class="memdesc:aec42df6b1b306b7a7102fa3bf8e2a296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the different states a component can have.  <a href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296">More...</a><br/></td></tr>
<tr class="separator:aec42df6b1b306b7a7102fa3bf8e2a296"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d7a5238ce5bea0359ba5c2bf766584a"><td class="memItemLeft" align="right" valign="top">corba::CTaskContext_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a6d7a5238ce5bea0359ba5c2bf766584a">server</a> () const </td></tr>
<tr class="memdesc:a6d7a5238ce5bea0359ba5c2bf766584a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Corba Object of the <a class="el" href="interfaceRTT_1_1corba_1_1CTaskContext.html" title="A CTaskContext is the main entry point of a distributed component and maps to a RTT::TaskContext. ">CTaskContext</a>.  <a href="#a6d7a5238ce5bea0359ba5c2bf766584a">More...</a><br/></td></tr>
<tr class="separator:a6d7a5238ce5bea0359ba5c2bf766584a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702052a95f039f56c9de1519e10c0b8c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a702052a95f039f56c9de1519e10c0b8c">activate</a> ()</td></tr>
<tr class="memdesc:a702052a95f039f56c9de1519e10c0b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method starts the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> of this component in case it was not running.  <a href="#a702052a95f039f56c9de1519e10c0b8c">More...</a><br/></td></tr>
<tr class="separator:a702052a95f039f56c9de1519e10c0b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bd244082ee0352d45f448e1b5e841a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#aa9bd244082ee0352d45f448e1b5e841a">start</a> ()</td></tr>
<tr class="memdesc:aa9bd244082ee0352d45f448e1b5e841a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method starts the execution of the <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a></em> with each trigger or period.  <a href="#aa9bd244082ee0352d45f448e1b5e841a">More...</a><br/></td></tr>
<tr class="separator:aa9bd244082ee0352d45f448e1b5e841a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea56b9ed500fbf9bec7a769cd2ccae7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a9ea56b9ed500fbf9bec7a769cd2ccae7">stop</a> ()</td></tr>
<tr class="memdesc:a9ea56b9ed500fbf9bec7a769cd2ccae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method stops the execution of <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a> of this component.  <a href="#a9ea56b9ed500fbf9bec7a769cd2ccae7">More...</a><br/></td></tr>
<tr class="separator:a9ea56b9ed500fbf9bec7a769cd2ccae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5ecacf2bf68d3eabee711747a12dd7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a3e5ecacf2bf68d3eabee711747a12dd7">isRunning</a> () const </td></tr>
<tr class="memdesc:a3e5ecacf2bf68d3eabee711747a12dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect if the component is in the Running or RunTimeError state.  <a href="#a3e5ecacf2bf68d3eabee711747a12dd7">More...</a><br/></td></tr>
<tr class="separator:a3e5ecacf2bf68d3eabee711747a12dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302f6a3d529d29c7c1ccc60afb840441"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a302f6a3d529d29c7c1ccc60afb840441">configure</a> ()</td></tr>
<tr class="memdesc:a302f6a3d529d29c7c1ccc60afb840441"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method instructs the component to (re-)read configuration data and try to enter the <em>Stopped</em> state.  <a href="#a302f6a3d529d29c7c1ccc60afb840441">More...</a><br/></td></tr>
<tr class="separator:a302f6a3d529d29c7c1ccc60afb840441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f4379b062e7286e37c225996c0b709"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a93f4379b062e7286e37c225996c0b709">cleanup</a> ()</td></tr>
<tr class="memdesc:a93f4379b062e7286e37c225996c0b709"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method instructs a stopped component to enter the pre-operational state again.  <a href="#a93f4379b062e7286e37c225996c0b709">More...</a><br/></td></tr>
<tr class="separator:a93f4379b062e7286e37c225996c0b709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00904940f4bfcd7e23261a6e8325b06f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a00904940f4bfcd7e23261a6e8325b06f">isActive</a> () const </td></tr>
<tr class="memdesc:a00904940f4bfcd7e23261a6e8325b06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect if the component's <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> is processing requests.  <a href="#a00904940f4bfcd7e23261a6e8325b06f">More...</a><br/></td></tr>
<tr class="separator:a00904940f4bfcd7e23261a6e8325b06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da68cc7d2a8de66bcda32096b754735"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a1da68cc7d2a8de66bcda32096b754735">isConfigured</a> () const </td></tr>
<tr class="memdesc:a1da68cc7d2a8de66bcda32096b754735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect if the component is configured, i.e.  <a href="#a1da68cc7d2a8de66bcda32096b754735">More...</a><br/></td></tr>
<tr class="separator:a1da68cc7d2a8de66bcda32096b754735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58e8059f29506a1c4df9bd60eb24542"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#aa58e8059f29506a1c4df9bd60eb24542">inFatalError</a> () const </td></tr>
<tr class="memdesc:aa58e8059f29506a1c4df9bd60eb24542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect if the component is in the FatalError state.  <a href="#aa58e8059f29506a1c4df9bd60eb24542">More...</a><br/></td></tr>
<tr class="separator:aa58e8059f29506a1c4df9bd60eb24542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94d2e03dda53dcad5e4a2b4aea0032e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae94d2e03dda53dcad5e4a2b4aea0032e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#ae94d2e03dda53dcad5e4a2b4aea0032e">inRunTimeError</a> () const </td></tr>
<tr class="memdesc:ae94d2e03dda53dcad5e4a2b4aea0032e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect if the component is in the RunTimeError state. <br/></td></tr>
<tr class="separator:ae94d2e03dda53dcad5e4a2b4aea0032e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fd594949ef8654daa21998e313a7c9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296">TaskState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a03fd594949ef8654daa21998e313a7c9">getTaskState</a> () const </td></tr>
<tr class="memdesc:a03fd594949ef8654daa21998e313a7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of the TaskCore.  <a href="#a03fd594949ef8654daa21998e313a7c9">More...</a><br/></td></tr>
<tr class="separator:a03fd594949ef8654daa21998e313a7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb55c7496b3e9b2ec7c7e224c337fe4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fb55c7496b3e9b2ec7c7e224c337fe4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setName</b> (const std::string &amp;n)</td></tr>
<tr class="separator:a3fb55c7496b3e9b2ec7c7e224c337fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ffef8be36a2ba8a74222f277b990bd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a10ffef8be36a2ba8a74222f277b990bd">addPeer</a> (<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *peer, std::string alias=&quot;&quot;)</td></tr>
<tr class="memdesc:a10ffef8be36a2ba8a74222f277b990bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a one-way connection from this task to a peer task.  <a href="#a10ffef8be36a2ba8a74222f277b990bd">More...</a><br/></td></tr>
<tr class="separator:a10ffef8be36a2ba8a74222f277b990bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92b284f9a6ea5a548d7043fdc005eba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae92b284f9a6ea5a548d7043fdc005eba"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#ae92b284f9a6ea5a548d7043fdc005eba">removePeer</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ae92b284f9a6ea5a548d7043fdc005eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a one-way connection from this task to a peer task. <br/></td></tr>
<tr class="separator:ae92b284f9a6ea5a548d7043fdc005eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051c31efd643ab61800e3dce2b9ad08f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a051c31efd643ab61800e3dce2b9ad08f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a051c31efd643ab61800e3dce2b9ad08f">removePeer</a> (<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *peer)</td></tr>
<tr class="memdesc:a051c31efd643ab61800e3dce2b9ad08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a one-way connection from this task to a peer task. <br/></td></tr>
<tr class="separator:a051c31efd643ab61800e3dce2b9ad08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bac21e6c43395f9c3a8b3fc1db17ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38bac21e6c43395f9c3a8b3fc1db17ca"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a38bac21e6c43395f9c3a8b3fc1db17ca">connectPeers</a> (<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *peer)</td></tr>
<tr class="memdesc:a38bac21e6c43395f9c3a8b3fc1db17ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a two-way connection from this task to a peer task. <br/></td></tr>
<tr class="separator:a38bac21e6c43395f9c3a8b3fc1db17ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859604ef48fae11211537048f305150b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859604ef48fae11211537048f305150b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a859604ef48fae11211537048f305150b">disconnectPeers</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a859604ef48fae11211537048f305150b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a two-way connection from this task to a peer task. <br/></td></tr>
<tr class="separator:a859604ef48fae11211537048f305150b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38955bca9a2ff2af401cb7f1a5824df2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38955bca9a2ff2af401cb7f1a5824df2"></a>
virtual <a class="el" href="classRTT_1_1TaskContext.html#ac1ebba86c109e257343eb1f432e97079">PeerList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a38955bca9a2ff2af401cb7f1a5824df2">getPeerList</a> () const </td></tr>
<tr class="memdesc:a38955bca9a2ff2af401cb7f1a5824df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a standard container which contains all the Peer names of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. <br/></td></tr>
<tr class="separator:a38955bca9a2ff2af401cb7f1a5824df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5afb105eb7dc8add32be6bfc67d4423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5afb105eb7dc8add32be6bfc67d4423"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#af5afb105eb7dc8add32be6bfc67d4423">hasPeer</a> (const std::string &amp;peer_name) const </td></tr>
<tr class="memdesc:af5afb105eb7dc8add32be6bfc67d4423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it knows a peer by that name. <br/></td></tr>
<tr class="separator:af5afb105eb7dc8add32be6bfc67d4423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8422f6c124522214dd159f19b8067e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#aa8422f6c124522214dd159f19b8067e7">getPeer</a> (const std::string &amp;peer_name) const </td></tr>
<tr class="memdesc:aa8422f6c124522214dd159f19b8067e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a peer of this task.  <a href="#aa8422f6c124522214dd159f19b8067e7">More...</a><br/></td></tr>
<tr class="separator:aa8422f6c124522214dd159f19b8067e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac842b590f49e2356afb68f06ee62ab4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac842b590f49e2356afb68f06ee62ab4c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#ac842b590f49e2356afb68f06ee62ab4c">connectPorts</a> (<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *peer)</td></tr>
<tr class="memdesc:ac842b590f49e2356afb68f06ee62ab4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a data flow connection from this task's ports to a peer's ports. <br/></td></tr>
<tr class="separator:ac842b590f49e2356afb68f06ee62ab4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d5035a98b5c38a4a1476aa50bcb0d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8d5035a98b5c38a4a1476aa50bcb0d4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#af8d5035a98b5c38a4a1476aa50bcb0d4">connectServices</a> (<a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *peer)</td></tr>
<tr class="memdesc:af8d5035a98b5c38a4a1476aa50bcb0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects all requires/provides services of this component to these of a peer. <br/></td></tr>
<tr class="separator:af8d5035a98b5c38a4a1476aa50bcb0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ca163585e0ea9480424cd59531a0aa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#ae9ca163585e0ea9480424cd59531a0aa">ready</a> ()</td></tr>
<tr class="memdesc:ae9ca163585e0ea9480424cd59531a0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the validity of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>.  <a href="#ae9ca163585e0ea9480424cd59531a0aa">More...</a><br/></td></tr>
<tr class="separator:ae9ca163585e0ea9480424cd59531a0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa7e91bf90f0793142432f74bb830a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa7e91bf90f0793142432f74bb830a1"></a>
virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a7aa7e91bf90f0793142432f74bb830a1">getName</a> () const </td></tr>
<tr class="memdesc:a7aa7e91bf90f0793142432f74bb830a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. <br/></td></tr>
<tr class="separator:a7aa7e91bf90f0793142432f74bb830a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fa89828cdf260496f27643e4ab9344"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a65fa89828cdf260496f27643e4ab9344">setActivity</a> (<a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">base::ActivityInterface</a> *new_act)</td></tr>
<tr class="memdesc:a65fa89828cdf260496f27643e4ab9344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the activity of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>.  <a href="#a65fa89828cdf260496f27643e4ab9344">More...</a><br/></td></tr>
<tr class="separator:a65fa89828cdf260496f27643e4ab9344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb066129eb925e0a245509bb2c2cca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">base::ActivityInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a6bb066129eb925e0a245509bb2c2cca1">getActivity</a> ()</td></tr>
<tr class="memdesc:a6bb066129eb925e0a245509bb2c2cca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the activity running this component.  <a href="#a6bb066129eb925e0a245509bb2c2cca1">More...</a><br/></td></tr>
<tr class="separator:a6bb066129eb925e0a245509bb2c2cca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4cefc2a489ea98d3d08137d8f9e97e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f4cefc2a489ea98d3d08137d8f9e97e"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a5f4cefc2a489ea98d3d08137d8f9e97e">getActivity</a> ()</td></tr>
<tr class="memdesc:a5f4cefc2a489ea98d3d08137d8f9e97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the activity running this component.  <a href="#a5f4cefc2a489ea98d3d08137d8f9e97e">More...</a><br/></td></tr>
<tr class="separator:a5f4cefc2a489ea98d3d08137d8f9e97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb5d5ee16d21907b5121b65ce7b1717"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a4eb5d5ee16d21907b5121b65ce7b1717">clear</a> ()</td></tr>
<tr class="memdesc:a4eb5d5ee16d21907b5121b65ce7b1717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the complete interface of this Component.  <a href="#a4eb5d5ee16d21907b5121b65ce7b1717">More...</a><br/></td></tr>
<tr class="separator:a4eb5d5ee16d21907b5121b65ce7b1717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7eb9108377ea236a034970ce1882e5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296">TaskState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a6c7eb9108377ea236a034970ce1882e5">getTargetState</a> () const </td></tr>
<tr class="memdesc:a6c7eb9108377ea236a034970ce1882e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state this <a class="el" href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task. ">TaskCore</a> is going to, or in case no transition is taking place, returns <a class="el" href="classRTT_1_1base_1_1TaskCore.html#aeebedaf344a1eae84f34b51ba052f299" title="Returns the current state of the TaskCore. ">getTaskState()</a>.  <a href="#a6c7eb9108377ea236a034970ce1882e5">More...</a><br/></td></tr>
<tr class="separator:a6c7eb9108377ea236a034970ce1882e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2522496caacc3e88065b5cb09dc2b7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2522496caacc3e88065b5cb09dc2b7a"></a>
const <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#ad2522496caacc3e88065b5cb09dc2b7a">engine</a> () const </td></tr>
<tr class="memdesc:ad2522496caacc3e88065b5cb09dc2b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> of this Task. <br/></td></tr>
<tr class="separator:ad2522496caacc3e88065b5cb09dc2b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18ebf7b987f142c8dad4413be2bbd30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac18ebf7b987f142c8dad4413be2bbd30"></a>
<a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#ac18ebf7b987f142c8dad4413be2bbd30">engine</a> ()</td></tr>
<tr class="memdesc:ac18ebf7b987f142c8dad4413be2bbd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> of this Task. <br/></td></tr>
<tr class="separator:ac18ebf7b987f142c8dad4413be2bbd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6ce3034250e9673cc6c80e7d03cc92"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a7d6ce3034250e9673cc6c80e7d03cc92">getCycleCounter</a> () const </td></tr>
<tr class="memdesc:a7d6ce3034250e9673cc6c80e7d03cc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each update cycle, this counter increments by one.  <a href="#a7d6ce3034250e9673cc6c80e7d03cc92">More...</a><br/></td></tr>
<tr class="separator:a7d6ce3034250e9673cc6c80e7d03cc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a17dbefbbbd3f7f6964ea23dd068a0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a17dbefbbbd3f7f6964ea23dd068a0e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a3a17dbefbbbd3f7f6964ea23dd068a0e">getTriggerCounter</a> () const </td></tr>
<tr class="memdesc:a3a17dbefbbbd3f7f6964ea23dd068a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cycles that were caused by Trigger triggers. <br/></td></tr>
<tr class="separator:a3a17dbefbbbd3f7f6964ea23dd068a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cfaa40033a59073b353bc752260dde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3cfaa40033a59073b353bc752260dde"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#ab3cfaa40033a59073b353bc752260dde">getIOCounter</a> () const </td></tr>
<tr class="memdesc:ab3cfaa40033a59073b353bc752260dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cycles that were caused by IOReady triggers. <br/></td></tr>
<tr class="separator:ab3cfaa40033a59073b353bc752260dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a81ca9d42e54566d5c4ac28315bcd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1a81ca9d42e54566d5c4ac28315bcd6"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#af1a81ca9d42e54566d5c4ac28315bcd6">getTimeOutCounter</a> () const </td></tr>
<tr class="memdesc:af1a81ca9d42e54566d5c4ac28315bcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cycles that were caused by TimeOut triggers. <br/></td></tr>
<tr class="separator:af1a81ca9d42e54566d5c4ac28315bcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Peer-to-Peer functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are used to setup and manage peer-to-peer networks of <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> objects. </p>
</div></td></tr>
<tr class="memitem:aa03a9ce88c728b6c996bf19f4ab3693d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#aa03a9ce88c728b6c996bf19f4ab3693d">disconnect</a> ()</td></tr>
<tr class="memdesc:aa03a9ce88c728b6c996bf19f4ab3693d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> from it's peers and ports.  <a href="#aa03a9ce88c728b6c996bf19f4ab3693d">More...</a><br/></td></tr>
<tr class="separator:aa03a9ce88c728b6c996bf19f4ab3693d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Services</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are used to create and manage services.</p>
<p>Use <a class="el" href="classRTT_1_1TaskContext.html#af11b11de5bb15692305f1d1df3840540" title="Returns this Service. ">provides()</a> or <a class="el" href="classRTT_1_1TaskContext.html#a29517582b6df25769e5ee0c3b9af165a" title="Returns the object that manages which methods this Task requires to be implemented by another task...">requires()</a> to access the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> or <a class="el" href="classRTT_1_1ServiceRequester.html" title="An object that expresses you wish to use a service. ">ServiceRequester</a> objects that contain all service related functions. </p>
</div></td></tr>
<tr class="memitem:af11b11de5bb15692305f1d1df3840540"><td class="memItemLeft" align="right" valign="top">Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#af11b11de5bb15692305f1d1df3840540">provides</a> ()</td></tr>
<tr class="memdesc:af11b11de5bb15692305f1d1df3840540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>.  <a href="#af11b11de5bb15692305f1d1df3840540">More...</a><br/></td></tr>
<tr class="separator:af11b11de5bb15692305f1d1df3840540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f9aabe8979225a1bf4e2825920ff66"><td class="memItemLeft" align="right" valign="top">Service::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a25f9aabe8979225a1bf4e2825920ff66">provides</a> (const std::string &amp;service_name)</td></tr>
<tr class="memdesc:a25f9aabe8979225a1bf4e2825920ff66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-Service which resorts under this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>.  <a href="#a25f9aabe8979225a1bf4e2825920ff66">More...</a><br/></td></tr>
<tr class="separator:a25f9aabe8979225a1bf4e2825920ff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29517582b6df25769e5ee0c3b9af165a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29517582b6df25769e5ee0c3b9af165a"></a>
ServiceRequester::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a29517582b6df25769e5ee0c3b9af165a">requires</a> ()</td></tr>
<tr class="memdesc:a29517582b6df25769e5ee0c3b9af165a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that manages which methods this Task requires to be implemented by another task. <br/></td></tr>
<tr class="separator:a29517582b6df25769e5ee0c3b9af165a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eaef4efa1eea9ced363516523742d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30eaef4efa1eea9ced363516523742d7"></a>
ServiceRequester::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a30eaef4efa1eea9ced363516523742d7">requires</a> (const std::string &amp;service_name)</td></tr>
<tr class="memdesc:a30eaef4efa1eea9ced363516523742d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that manages which methods this Task requires to be implemented by another service. <br/></td></tr>
<tr class="separator:a30eaef4efa1eea9ced363516523742d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a29ef110689fbd9a49181921136cf4f"><td class="memTemplParams" colspan="2">template&lt;class ServiceType &gt; </td></tr>
<tr class="memitem:a0a29ef110689fbd9a49181921136cf4f"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; ServiceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a0a29ef110689fbd9a49181921136cf4f">getProvider</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a0a29ef110689fbd9a49181921136cf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method to be able to make <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> calls to services provided by this component.  <a href="#a0a29ef110689fbd9a49181921136cf4f">More...</a><br/></td></tr>
<tr class="separator:a0a29ef110689fbd9a49181921136cf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4faaafad020f0b5816f9ef6ae5bc87b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#ad4faaafad020f0b5816f9ef6ae5bc87b">loadService</a> (const std::string &amp;service_name)</td></tr>
<tr class="memdesc:ad4faaafad020f0b5816f9ef6ae5bc87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method to load a service known to <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute. ">RTT</a> into this component.  <a href="#ad4faaafad020f0b5816f9ef6ae5bc87b">More...</a><br/></td></tr>
<tr class="separator:ad4faaafad020f0b5816f9ef6ae5bc87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Adding and getting operations from the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> interface.</p>
<p>These functions all forward to the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> representing this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. Use <a class="el" href="classRTT_1_1TaskContext.html#af11b11de5bb15692305f1d1df3840540" title="Returns this Service. ">provides()</a> to access the complete <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> interface of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </p>
</div></td></tr>
<tr class="memitem:a4b21856b3e67a002937194e1ed20e24c"><td class="memTemplParams" colspan="2">template&lt;class Signature &gt; </td></tr>
<tr class="memitem:a4b21856b3e67a002937194e1ed20e24c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a4b21856b3e67a002937194e1ed20e24c">addOperation</a> (<a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;op)</td></tr>
<tr class="memdesc:a4b21856b3e67a002937194e1ed20e24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation object to the interface.  <a href="#a4b21856b3e67a002937194e1ed20e24c">More...</a><br/></td></tr>
<tr class="separator:a4b21856b3e67a002937194e1ed20e24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7f65a4a63331de40b94d712eb49119"><td class="memTemplParams" colspan="2">template&lt;class Func , class Service &gt; </td></tr>
<tr class="memitem:a0b7f65a4a63331de40b94d712eb49119"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt; Func &gt;<br class="typebreak"/>
::Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a0b7f65a4a63331de40b94d712eb49119">addOperation</a> (const std::string name, Func func, <a class="el" href="classRTT_1_1Service.html">Service</a> *serv, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr class="memdesc:a0b7f65a4a63331de40b94d712eb49119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a C++ function as an operation.  <a href="#a0b7f65a4a63331de40b94d712eb49119">More...</a><br/></td></tr>
<tr class="separator:a0b7f65a4a63331de40b94d712eb49119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20c2fe74dd0691f7c07e72948738c8f"><td class="memTemplParams" colspan="2">template&lt;class Signature &gt; </td></tr>
<tr class="memitem:ab20c2fe74dd0691f7c07e72948738c8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#ab20c2fe74dd0691f7c07e72948738c8f">addOperation</a> (const std::string name, Signature *func, <a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a> et=ClientThread)</td></tr>
<tr class="memdesc:ab20c2fe74dd0691f7c07e72948738c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a C function as an operation.  <a href="#ab20c2fe74dd0691f7c07e72948738c8f">More...</a><br/></td></tr>
<tr class="separator:ab20c2fe74dd0691f7c07e72948738c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3261db01744046dfe1ad016bf4781c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#ad3261db01744046dfe1ad016bf4781c5">getOperation</a> (std::string name)</td></tr>
<tr class="memdesc:ad3261db01744046dfe1ad016bf4781c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a previously added operation for use in a C++ <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> object.  <a href="#ad3261db01744046dfe1ad016bf4781c5">More...</a><br/></td></tr>
<tr class="separator:ad3261db01744046dfe1ad016bf4781c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaac15f93904c1653c7d67ae7cb13c3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaac15f93904c1653c7d67ae7cb13c3f"></a>
<a class="el" href="classRTT_1_1OperationInterface.html">OperationInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#acaac15f93904c1653c7d67ae7cb13c3f">operations</a> ()</td></tr>
<tr class="memdesc:acaac15f93904c1653c7d67ae7cb13c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operations of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> as an <a class="el" href="classRTT_1_1OperationInterface.html" title="Holds all exported operations of a component and is able to produce callers for these operations...">OperationInterface</a>. <br/></td></tr>
<tr class="separator:acaac15f93904c1653c7d67ae7cb13c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attributes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Adding and getting attributes from the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> interface.</p>
<p>These functions all forward to the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> representing this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. Use <a class="el" href="classRTT_1_1TaskContext.html#a44d240a9e534409e31cd6d41385a6651" title="Returns the attributes of this TaskContext as an ConfigurationInterface. ">attributes()</a> to access the complete <a class="el" href="classRTT_1_1ConfigurationInterface.html" title="A class for keeping track of Attribute, Constant and Property objects of a TaskContext. ">ConfigurationInterface</a> interface of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </p>
</div></td></tr>
<tr class="memitem:a228ea19b9974d1ff329a2b4fe6ea3ae8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a228ea19b9974d1ff329a2b4fe6ea3ae8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a228ea19b9974d1ff329a2b4fe6ea3ae8">addAttribute</a> (const std::string &amp;name, T &amp;attr)</td></tr>
<tr class="memdesc:a228ea19b9974d1ff329a2b4fe6ea3ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as read/write attribute to the attribute interface.  <a href="#a228ea19b9974d1ff329a2b4fe6ea3ae8">More...</a><br/></td></tr>
<tr class="separator:a228ea19b9974d1ff329a2b4fe6ea3ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9af8547a01dc1ce03a5b509e11c7638"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#ad9af8547a01dc1ce03a5b509e11c7638">addAttribute</a> (<a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;a)</td></tr>
<tr class="memdesc:ad9af8547a01dc1ce03a5b509e11c7638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data. ">base::AttributeBase</a> which remains owned by the user.  <a href="#ad9af8547a01dc1ce03a5b509e11c7638">More...</a><br/></td></tr>
<tr class="separator:ad9af8547a01dc1ce03a5b509e11c7638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad610f7822f53345bf7318998c06ca31b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad610f7822f53345bf7318998c06ca31b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#ad610f7822f53345bf7318998c06ca31b">addConstant</a> (const std::string &amp;name, const T &amp;attr)</td></tr>
<tr class="memdesc:ad610f7822f53345bf7318998c06ca31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as read-only attribute to the attribute interface.  <a href="#ad610f7822f53345bf7318998c06ca31b">More...</a><br/></td></tr>
<tr class="separator:ad610f7822f53345bf7318998c06ca31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3406693cbcf04d5128f71286056cc06f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a3406693cbcf04d5128f71286056cc06f">getAttribute</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a3406693cbcf04d5128f71286056cc06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as read/write attribute to the attribute interface.  <a href="#a3406693cbcf04d5128f71286056cc06f">More...</a><br/></td></tr>
<tr class="separator:a3406693cbcf04d5128f71286056cc06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d240a9e534409e31cd6d41385a6651"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44d240a9e534409e31cd6d41385a6651"></a>
<a class="el" href="classRTT_1_1ConfigurationInterface.html">ConfigurationInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a44d240a9e534409e31cd6d41385a6651">attributes</a> ()</td></tr>
<tr class="memdesc:a44d240a9e534409e31cd6d41385a6651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attributes of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> as an <a class="el" href="classRTT_1_1ConfigurationInterface.html" title="A class for keeping track of Attribute, Constant and Property objects of a TaskContext. ">ConfigurationInterface</a>. <br/></td></tr>
<tr class="separator:a44d240a9e534409e31cd6d41385a6651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Properties</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Adding and getting properties from the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> interface.</p>
<p>These functions all forward to the <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> representing this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. Use <a class="el" href="classRTT_1_1TaskContext.html#a1442b82a6d52954b8644b0f89d3a1080" title="Returns the properties of this TaskContext as a PropertyBag. ">properties()</a> to access the complete <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties. ">PropertyBag</a> interface of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </p>
</div></td></tr>
<tr class="memitem:af87c90fd9f75a3fe2e19408b1fc8df2b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af87c90fd9f75a3fe2e19408b1fc8df2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#af87c90fd9f75a3fe2e19408b1fc8df2b">addProperty</a> (const std::string &amp;name, T &amp;attr)</td></tr>
<tr class="memdesc:af87c90fd9f75a3fe2e19408b1fc8df2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a variable of any type as a property to the attribute interface.  <a href="#af87c90fd9f75a3fe2e19408b1fc8df2b">More...</a><br/></td></tr>
<tr class="separator:af87c90fd9f75a3fe2e19408b1fc8df2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83976b20bfec26e9609e3ac38136a0b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a83976b20bfec26e9609e3ac38136a0b1">addProperty</a> (<a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;pb)</td></tr>
<tr class="memdesc:a83976b20bfec26e9609e3ac38136a0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="classRTT_1_1base_1_1PropertyBase.html" title="Base class for all properties. ">base::PropertyBase</a> as a property.  <a href="#a83976b20bfec26e9609e3ac38136a0b1">More...</a><br/></td></tr>
<tr class="separator:a83976b20bfec26e9609e3ac38136a0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee485a4df00e9582430174a6505f538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a9ee485a4df00e9582430174a6505f538">getProperty</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a9ee485a4df00e9582430174a6505f538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> with name <em>name</em>.  <a href="#a9ee485a4df00e9582430174a6505f538">More...</a><br/></td></tr>
<tr class="separator:a9ee485a4df00e9582430174a6505f538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1442b82a6d52954b8644b0f89d3a1080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1442b82a6d52954b8644b0f89d3a1080"></a>
<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a1442b82a6d52954b8644b0f89d3a1080">properties</a> ()</td></tr>
<tr class="memdesc:a1442b82a6d52954b8644b0f89d3a1080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the properties of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> as a <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties. ">PropertyBag</a>. <br/></td></tr>
<tr class="separator:a1442b82a6d52954b8644b0f89d3a1080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These TaskCore functions are exported in a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> as script methods and are for configuration, starting and stopping its <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>. </p>
</div></td></tr>
<tr class="memitem:ab3f9dfd33aac3116805a8d1801c8edfe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRTT.html#ab93965f88bfbe72fbc2ece16c047c902">Seconds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#ab3f9dfd33aac3116805a8d1801c8edfe">getPeriod</a> () const </td></tr>
<tr class="memdesc:ab3f9dfd33aac3116805a8d1801c8edfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured execution period of this component.  <a href="#ab3f9dfd33aac3116805a8d1801c8edfe">More...</a><br/></td></tr>
<tr class="separator:ab3f9dfd33aac3116805a8d1801c8edfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3ad5b4301ec54a2357d2f8bc60e2b8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a7d3ad5b4301ec54a2357d2f8bc60e2b8">setPeriod</a> (<a class="el" href="namespaceRTT.html#ab93965f88bfbe72fbc2ece16c047c902">Seconds</a> s)</td></tr>
<tr class="memdesc:a7d3ad5b4301ec54a2357d2f8bc60e2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the period of this component.  <a href="#a7d3ad5b4301ec54a2357d2f8bc60e2b8">More...</a><br/></td></tr>
<tr class="separator:a7d3ad5b4301ec54a2357d2f8bc60e2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf99cd58b81ce05216baae47e5b04364"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#aaf99cd58b81ce05216baae47e5b04364">getCpuAffinity</a> () const </td></tr>
<tr class="memdesc:aaf99cd58b81ce05216baae47e5b04364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured cpu affinity of this component.  <a href="#aaf99cd58b81ce05216baae47e5b04364">More...</a><br/></td></tr>
<tr class="separator:aaf99cd58b81ce05216baae47e5b04364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed3cee9867d1367b6c482a0584f5045"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4ed3cee9867d1367b6c482a0584f5045">setCpuAffinity</a> (unsigned cpu)</td></tr>
<tr class="memdesc:a4ed3cee9867d1367b6c482a0584f5045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the cpu affinity of this component.  <a href="#a4ed3cee9867d1367b6c482a0584f5045">More...</a><br/></td></tr>
<tr class="separator:a4ed3cee9867d1367b6c482a0584f5045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f58ee59ba08f3c4cf7ab92bd7ff13e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3f58ee59ba08f3c4cf7ab92bd7ff13e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#ad3f58ee59ba08f3c4cf7ab92bd7ff13e">inException</a> () const </td></tr>
<tr class="memdesc:ad3f58ee59ba08f3c4cf7ab92bd7ff13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect if the component is in the Exception state. <br/></td></tr>
<tr class="separator:ad3f58ee59ba08f3c4cf7ab92bd7ff13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940714024a53ffb17de749f3f909527d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a940714024a53ffb17de749f3f909527d">update</a> ()</td></tr>
<tr class="memdesc:a940714024a53ffb17de749f3f909527d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke this method to <em>execute</em> the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> and the <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a940714024a53ffb17de749f3f909527d" title="Invoke this method to execute the ExecutionEngine and the update() method. ">update()</a> method.  <a href="#a940714024a53ffb17de749f3f909527d">More...</a><br/></td></tr>
<tr class="separator:a940714024a53ffb17de749f3f909527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2cda802da9670204fc3be88e9e4ccf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a9b2cda802da9670204fc3be88e9e4ccf">trigger</a> ()</td></tr>
<tr class="memdesc:a9b2cda802da9670204fc3be88e9e4ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke this method to <em>trigger</em> the thread of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> to execute its <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> and the <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a940714024a53ffb17de749f3f909527d" title="Invoke this method to execute the ExecutionEngine and the update() method. ">update()</a> method.  <a href="#a9b2cda802da9670204fc3be88e9e4ccf">More...</a><br/></td></tr>
<tr class="separator:a9b2cda802da9670204fc3be88e9e4ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3b01dff9aa92578d1657bdc3c0fb47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a3c3b01dff9aa92578d1657bdc3c0fb47">error</a> ()</td></tr>
<tr class="memdesc:a3c3b01dff9aa92578d1657bdc3c0fb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method in a Running state to indicate a run-time error condition.  <a href="#a3c3b01dff9aa92578d1657bdc3c0fb47">More...</a><br/></td></tr>
<tr class="separator:a3c3b01dff9aa92578d1657bdc3c0fb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28420e3f52d819fddbe0962cdef98707"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a28420e3f52d819fddbe0962cdef98707">recover</a> ()</td></tr>
<tr class="memdesc:a28420e3f52d819fddbe0962cdef98707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method in a RunTimeError or Exception state to indicate that the run-time error conditions are gone and nominal operation is resumed.  <a href="#a28420e3f52d819fddbe0962cdef98707">More...</a><br/></td></tr>
<tr class="separator:a28420e3f52d819fddbe0962cdef98707"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6cdbb26dfc54b67c284135e826b62960"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cdbb26dfc54b67c284135e826b62960"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a6cdbb26dfc54b67c284135e826b62960">DestroyOrb</a> ()</td></tr>
<tr class="memdesc:a6cdbb26dfc54b67c284135e826b62960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke this method once to cleanup the orb. <br/></td></tr>
<tr class="separator:a6cdbb26dfc54b67c284135e826b62960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5221c6007b7ceb6d397b9b8bf02b5943"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html">TaskContextProxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a5221c6007b7ceb6d397b9b8bf02b5943">Create</a> (std::string name, bool is_ior=false)</td></tr>
<tr class="memdesc:a5221c6007b7ceb6d397b9b8bf02b5943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method: create a CORBA Proxy for an existing <a class="el" href="classRTT_1_1corba_1_1TaskContextServer.html" title="This class manages the creation of TaskContext Corba Servers and a Corba Object Request Broker (Orb) ...">TaskContextServer</a>.  <a href="#a5221c6007b7ceb6d397b9b8bf02b5943">More...</a><br/></td></tr>
<tr class="separator:a5221c6007b7ceb6d397b9b8bf02b5943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20c64c88305e2a64a8a1a778e8ebf2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html">TaskContextProxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#af20c64c88305e2a64a8a1a778e8ebf2e">CreateFromFile</a> (std::string filename)</td></tr>
<tr class="memdesc:af20c64c88305e2a64a8a1a778e8ebf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method: create a CORBA Proxy for an existing <a class="el" href="classRTT_1_1corba_1_1TaskContextServer.html" title="This class manages the creation of TaskContext Corba Servers and a Corba Object Request Broker (Orb) ...">TaskContextServer</a>.  <a href="#af20c64c88305e2a64a8a1a778e8ebf2e">More...</a><br/></td></tr>
<tr class="separator:af20c64c88305e2a64a8a1a778e8ebf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a66a077c9d9add68b0057b6aa71feef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a5a66a077c9d9add68b0057b6aa71feef">Create</a> (::RTT::corba::CTaskContext_ptr task, bool force_remote=false)</td></tr>
<tr class="memdesc:a5a66a077c9d9add68b0057b6aa71feef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method: create a CORBA Proxy for an existing <a class="el" href="classRTT_1_1corba_1_1TaskContextServer.html" title="This class manages the creation of TaskContext Corba Servers and a Corba Object Request Broker (Orb) ...">TaskContextServer</a>.  <a href="#a5a66a077c9d9add68b0057b6aa71feef">More...</a><br/></td></tr>
<tr class="separator:a5a66a077c9d9add68b0057b6aa71feef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664bef894603be46e6998955246d2d61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a664bef894603be46e6998955246d2d61"></a>
static PortableServer::POA_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a664bef894603be46e6998955246d2d61">ProxyPOA</a> ()</td></tr>
<tr class="memdesc:a664bef894603be46e6998955246d2d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default POA for all proxies. <br/></td></tr>
<tr class="separator:a664bef894603be46e6998955246d2d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ebf2eb7aaf1d82875d8e5156bbdbda"><td class="memItemLeft" align="right" valign="top">static RTT_CORBA_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1corba_1_1ApplicationServer.html#a32ebf2eb7aaf1d82875d8e5156bbdbda">InitOrb</a> (int argc, char *argv[], <a class="el" href="namespaceRTT.html#ab93965f88bfbe72fbc2ece16c047c902">Seconds</a> orb_timeout=0)</td></tr>
<tr class="memdesc:a32ebf2eb7aaf1d82875d8e5156bbdbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke this method once to initialise the Orb which will run the task servers.  <a href="#a32ebf2eb7aaf1d82875d8e5156bbdbda">More...</a><br/></td></tr>
<tr class="separator:a32ebf2eb7aaf1d82875d8e5156bbdbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa703a4cb32277a3e51539844bb4b89cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa703a4cb32277a3e51539844bb4b89cd"></a>
static PMap&#160;</td><td class="memItemRight" valign="bottom"><b>proxies</b></td></tr>
<tr class="separator:aa703a4cb32277a3e51539844bb4b89cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae610e6376e03f79fb097aacfd390aacc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae610e6376e03f79fb097aacfd390aacc"></a>
static CORBA::ORB_var&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1corba_1_1ApplicationServer.html#ae610e6376e03f79fb097aacfd390aacc">orb</a></td></tr>
<tr class="memdesc:ae610e6376e03f79fb097aacfd390aacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The orb of this process. <br/></td></tr>
<tr class="separator:ae610e6376e03f79fb097aacfd390aacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb9a81f3a8c3470d45e8464d126f470"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb9a81f3a8c3470d45e8464d126f470"></a>
static PortableServer::POA_var&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1corba_1_1ApplicationServer.html#a7eb9a81f3a8c3470d45e8464d126f470">rootPOA</a></td></tr>
<tr class="memdesc:a7eb9a81f3a8c3470d45e8464d126f470"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root POA of this process. <br/></td></tr>
<tr class="separator:a7eb9a81f3a8c3470d45e8464d126f470"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afb77d6dc2a2ba13037ff23716df5a539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb77d6dc2a2ba13037ff23716df5a539"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#afb77d6dc2a2ba13037ff23716df5a539">TaskContextProxy</a> (std::string location, bool is_ior)</td></tr>
<tr class="memdesc:afb77d6dc2a2ba13037ff23716df5a539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private constructor which creates a new connection to a stringified ior or taskname in NameServer. <br/></td></tr>
<tr class="separator:afb77d6dc2a2ba13037ff23716df5a539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09952a063807c4c700a815c6e6c2d13d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09952a063807c4c700a815c6e6c2d13d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a09952a063807c4c700a815c6e6c2d13d">TaskContextProxy</a> ()</td></tr>
<tr class="memdesc:a09952a063807c4c700a815c6e6c2d13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Private constructor which does nothing. <br/></td></tr>
<tr class="separator:a09952a063807c4c700a815c6e6c2d13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac649aaa48922f229997a127672767ab4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac649aaa48922f229997a127672767ab4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#ac649aaa48922f229997a127672767ab4">TaskContextProxy</a> (::RTT::corba::CTaskContext_ptr t)</td></tr>
<tr class="memdesc:ac649aaa48922f229997a127672767ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private constructor which creates a new connection to a corba object. <br/></td></tr>
<tr class="separator:ac649aaa48922f229997a127672767ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f38a761efa69863de69ad7ab7b74c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7f38a761efa69863de69ad7ab7b74c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#ab7f38a761efa69863de69ad7ab7b74c9">initFromURIOrTaskname</a> (std::string location, bool is_ior)</td></tr>
<tr class="memdesc:ab7f38a761efa69863de69ad7ab7b74c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes the class from a stringified ior or taskname in NameServer. <br/></td></tr>
<tr class="separator:ab7f38a761efa69863de69ad7ab7b74c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060b936bb810eb03c712b4ad2236aba4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a060b936bb810eb03c712b4ad2236aba4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synchronize</b> ()</td></tr>
<tr class="separator:a060b936bb810eb03c712b4ad2236aba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bff8d007217d32ce8cb6b94f325922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50bff8d007217d32ce8cb6b94f325922"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synchronizeRequesters</b> (ServiceRequester::shared_ptr parent, CServiceRequester_ptr csrq, const <a class="el" href="structRTT_1_1corba_1_1CServiceRequesterDescription.html">CServiceRequesterDescription</a> &amp;cdescription)</td></tr>
<tr class="separator:a50bff8d007217d32ce8cb6b94f325922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f789f98d67cbd05005cfae1f5e79c25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f789f98d67cbd05005cfae1f5e79c25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synchronizeServices</b> (Service::shared_ptr parent, CService_ptr serv, const <a class="el" href="structRTT_1_1corba_1_1CServiceDescription.html">CServiceDescription</a> &amp;cdescription)</td></tr>
<tr class="separator:a1f789f98d67cbd05005cfae1f5e79c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49f223274c5bd6128541d151974dda7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab49f223274c5bd6128541d151974dda7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synchronizePorts</b> (Service::shared_ptr parent, CDataFlowInterface_ptr dfact, const <a class="el" href="structRTT_1_1corba_1_1CServiceDescription.html">CServiceDescription</a> &amp;cdescription)</td></tr>
<tr class="separator:ab49f223274c5bd6128541d151974dda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ef45d1d0a48a1123763ed534a9b4b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a59ef45d1d0a48a1123763ed534a9b4b2">forceActivity</a> (<a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">base::ActivityInterface</a> *new_act)</td></tr>
<tr class="memdesc:a59ef45d1d0a48a1123763ed534a9b4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the current activity to become <em>new_act</em>, even if this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> is still running.  <a href="#a59ef45d1d0a48a1123763ed534a9b4b2">More...</a><br/></td></tr>
<tr class="separator:a59ef45d1d0a48a1123763ed534a9b4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4d739183c23583a00eb37b555238a4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#aaa4d739183c23583a00eb37b555238a4">dataOnPortHook</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *port)</td></tr>
<tr class="memdesc:aaa4d739183c23583a00eb37b555238a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reimplement this method to influence how writing to event ports is handled by the component.  <a href="#aaa4d739183c23583a00eb37b555238a4">More...</a><br/></td></tr>
<tr class="separator:aaa4d739183c23583a00eb37b555238a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990586cfe74123de656950365be45fea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a990586cfe74123de656950365be45fea">dataOnPortCallback</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *port)</td></tr>
<tr class="memdesc:a990586cfe74123de656950365be45fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method implements port callbacks.  <a href="#a990586cfe74123de656950365be45fea">More...</a><br/></td></tr>
<tr class="separator:a990586cfe74123de656950365be45fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9badff843c97307d2b3084c4320606c6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a9badff843c97307d2b3084c4320606c6">configureHook</a> ()</td></tr>
<tr class="memdesc:a9badff843c97307d2b3084c4320606c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method such that it contains the code which will be executed when <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a492aed947a9bb2cbc25140884bc34e1b" title="This method instructs the component to (re-)read configuration data and try to enter the Stopped stat...">configure()</a></em> is called.  <a href="#a9badff843c97307d2b3084c4320606c6">More...</a><br/></td></tr>
<tr class="separator:a9badff843c97307d2b3084c4320606c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7079becea7aa4945ba69cc202713592c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a7079becea7aa4945ba69cc202713592c">cleanupHook</a> ()</td></tr>
<tr class="memdesc:a7079becea7aa4945ba69cc202713592c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method such that it contains the code which will be executed when <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a009c3d9b097d1904ca6eac98a5b48d0c" title="This method instructs a stopped component to enter the pre-operational state again. ">cleanup()</a></em> is called.  <a href="#a7079becea7aa4945ba69cc202713592c">More...</a><br/></td></tr>
<tr class="separator:a7079becea7aa4945ba69cc202713592c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add908fc9e1fcb95dea895e6231edf075"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#add908fc9e1fcb95dea895e6231edf075">startHook</a> ()</td></tr>
<tr class="memdesc:add908fc9e1fcb95dea895e6231edf075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method such that it contains the code which will be executed when <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a975fddfc6d0fd5dfa77303c20395d87c" title="This method starts the execution of the updateHook() with each trigger or period. ...">start()</a></em> is called.  <a href="#add908fc9e1fcb95dea895e6231edf075">More...</a><br/></td></tr>
<tr class="separator:add908fc9e1fcb95dea895e6231edf075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b16151ed99062bca250ddfe667a3604"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604">updateHook</a> ()</td></tr>
<tr class="memdesc:a4b16151ed99062bca250ddfe667a3604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function where the user must insert his 'application' code.  <a href="#a4b16151ed99062bca250ddfe667a3604">More...</a><br/></td></tr>
<tr class="separator:a4b16151ed99062bca250ddfe667a3604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a3f8cbcfee40c1bc1f4394dadfcf82"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#ad4a3f8cbcfee40c1bc1f4394dadfcf82">breakUpdateHook</a> ()</td></tr>
<tr class="memdesc:ad4a3f8cbcfee40c1bc1f4394dadfcf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this function if your code might block for long times inside the <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a> function.  <a href="#ad4a3f8cbcfee40c1bc1f4394dadfcf82">More...</a><br/></td></tr>
<tr class="separator:ad4a3f8cbcfee40c1bc1f4394dadfcf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d100268cdda1f60af1e2203d155168b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a1d100268cdda1f60af1e2203d155168b">errorHook</a> ()</td></tr>
<tr class="memdesc:a1d100268cdda1f60af1e2203d155168b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to contain code that must be executed in the RunTimeError state, instead of <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a>.  <a href="#a1d100268cdda1f60af1e2203d155168b">More...</a><br/></td></tr>
<tr class="separator:a1d100268cdda1f60af1e2203d155168b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576b146a57bd81b1f5fe3a8e51f0bd16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a576b146a57bd81b1f5fe3a8e51f0bd16">exceptionHook</a> ()</td></tr>
<tr class="memdesc:a576b146a57bd81b1f5fe3a8e51f0bd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to contain code that must be executed when transitioning to the Exception state.  <a href="#a576b146a57bd81b1f5fe3a8e51f0bd16">More...</a><br/></td></tr>
<tr class="separator:a576b146a57bd81b1f5fe3a8e51f0bd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfeb7f3c3d066080d5af36baacb6648"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a8bfeb7f3c3d066080d5af36baacb6648">stopHook</a> ()</td></tr>
<tr class="memdesc:a8bfeb7f3c3d066080d5af36baacb6648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method such that it contains the code which will be executed when <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#aa69a1db58d9b3695477ac75866e4e62c" title="This method stops the execution of updateHook() of this component. ">stop()</a></em> is called.  <a href="#a8bfeb7f3c3d066080d5af36baacb6648">More...</a><br/></td></tr>
<tr class="separator:a8bfeb7f3c3d066080d5af36baacb6648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af208a7b9442ba87f42a3a52a28c5309f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#af208a7b9442ba87f42a3a52a28c5309f">fatal</a> ()</td></tr>
<tr class="memdesc:af208a7b9442ba87f42a3a52a28c5309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method from any place to indicate that this component encountered a fatal error.  <a href="#af208a7b9442ba87f42a3a52a28c5309f">More...</a><br/></td></tr>
<tr class="separator:af208a7b9442ba87f42a3a52a28c5309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243f1797bcfef248146ee02166a1eeb8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a243f1797bcfef248146ee02166a1eeb8">exception</a> ()</td></tr>
<tr class="memdesc:a243f1797bcfef248146ee02166a1eeb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method to indicate a run-time exception happend.  <a href="#a243f1797bcfef248146ee02166a1eeb8">More...</a><br/></td></tr>
<tr class="separator:a243f1797bcfef248146ee02166a1eeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afb54764824414d6de6c7255b826b51f6"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#afb54764824414d6de6c7255b826b51f6">port_proxies</a></td></tr>
<tr class="memdesc:afb54764824414d6de6c7255b826b51f6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="interfaceRTT_1_1corba_1_1CDataFlowInterface.html" title="An interface to access the dataflow of a CControlTask object. ">CDataFlowInterface</a> does not delete ports automatically, because they can then be defined as members of the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> classes.  <a href="#afb54764824414d6de6c7255b826b51f6">More...</a><br/></td></tr>
<tr class="separator:afb54764824414d6de6c7255b826b51f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d76d02ebbdc50ee9343d7a62feb25c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2d76d02ebbdc50ee9343d7a62feb25c"></a>
corba::CTaskContext_var&#160;</td><td class="memItemRight" valign="bottom"><b>mtask</b></td></tr>
<tr class="separator:af2d76d02ebbdc50ee9343d7a62feb25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeffff3d523e09a22bfcb9f43f1cc5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdeffff3d523e09a22bfcb9f43f1cc5f"></a>
<a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#afdeffff3d523e09a22bfcb9f43f1cc5f">ee</a></td></tr>
<tr class="memdesc:afdeffff3d523e09a22bfcb9f43f1cc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The execution engine which calls <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a940714024a53ffb17de749f3f909527d" title="Invoke this method to execute the ExecutionEngine and the update() method. ">update()</a> and processes our commands, events etc. <br/></td></tr>
<tr class="separator:afdeffff3d523e09a22bfcb9f43f1cc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ab91fa8b90e2c9ac95652d67730d36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29ab91fa8b90e2c9ac95652d67730d36"></a>
<a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296">TaskState</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mTaskState</b></td></tr>
<tr class="separator:a29ab91fa8b90e2c9ac95652d67730d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e439d71b36a1789f5d8738159c1c46e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e439d71b36a1789f5d8738159c1c46e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4e439d71b36a1789f5d8738159c1c46e">mTriggerOnStart</a></td></tr>
<tr class="memdesc:a4e439d71b36a1789f5d8738159c1c46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to false in order to not <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a9b2cda802da9670204fc3be88e9e4ccf" title="Invoke this method to trigger the thread of this TaskContext to execute its ExecutionEngine and the u...">trigger()</a> when calling <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a975fddfc6d0fd5dfa77303c20395d87c" title="This method starts the execution of the updateHook() with each trigger or period. ...">start()</a>. <br/></td></tr>
<tr class="separator:a4e439d71b36a1789f5d8738159c1c46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fd49b2f57fcc037366e49d6c18e6e6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a41fd49b2f57fcc037366e49d6c18e6e6">mCycleCounter</a></td></tr>
<tr class="memdesc:a41fd49b2f57fcc037366e49d6c18e6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each update cycle, this counter increments by one.  <a href="#a41fd49b2f57fcc037366e49d6c18e6e6">More...</a><br/></td></tr>
<tr class="separator:a41fd49b2f57fcc037366e49d6c18e6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abc6bb0aa4150b20f29fb8a089fbb8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2abc6bb0aa4150b20f29fb8a089fbb8b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a2abc6bb0aa4150b20f29fb8a089fbb8b">mIOCounter</a></td></tr>
<tr class="memdesc:a2abc6bb0aa4150b20f29fb8a089fbb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cycles that were caused by IOReady triggers. <br/></td></tr>
<tr class="separator:a2abc6bb0aa4150b20f29fb8a089fbb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0fd2a8e4a110f5b0170dfb7498ad06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b0fd2a8e4a110f5b0170dfb7498ad06"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a2b0fd2a8e4a110f5b0170dfb7498ad06">mTimeOutCounter</a></td></tr>
<tr class="memdesc:a2b0fd2a8e4a110f5b0170dfb7498ad06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cycles that were caused by TimeOut triggers. <br/></td></tr>
<tr class="separator:a2b0fd2a8e4a110f5b0170dfb7498ad06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053a2bf6b37d7a407532c85489251c31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a053a2bf6b37d7a407532c85489251c31"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a053a2bf6b37d7a407532c85489251c31">mTriggerCounter</a></td></tr>
<tr class="memdesc:a053a2bf6b37d7a407532c85489251c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cycles that were caused by Trigger triggers. <br/></td></tr>
<tr class="separator:a053a2bf6b37d7a407532c85489251c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a28725d9d3f6dee48da6d05dd51ac4b66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28725d9d3f6dee48da6d05dd51ac4b66"></a>
static PortableServer::POA_var&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#a28725d9d3f6dee48da6d05dd51ac4b66">proxy_poa</a></td></tr>
<tr class="memdesc:a28725d9d3f6dee48da6d05dd51ac4b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">For now one POA handles all proxies. <br/></td></tr>
<tr class="separator:a28725d9d3f6dee48da6d05dd51ac4b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Ports</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp407c4e9fac86b98147da49acd4fa0d01"></a>These functions serve to manage ports and data flow connections.</p>
<p>Use <a class="el" href="classRTT_1_1TaskContext.html#a9d0f38c658735ebce3e7dad89f9d1902" title="Get the Data flow ports of this task. ">ports()</a> to access the complete <a class="el" href="classRTT_1_1DataFlowInterface.html" title="The Interface of a TaskContext which exposes its data-flow ports. ">DataFlowInterface</a> functionality of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </p>
</td></tr>
<tr class="memitem:a8cc279940c3e1d974831413c03b7b6e5"><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; void(<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a8cc279940c3e1d974831413c03b7b6e5">SlotFunction</a></td></tr>
<tr class="memdesc:a8cc279940c3e1d974831413c03b7b6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port.  <a href="#a8cc279940c3e1d974831413c03b7b6e5">More...</a><br/></td></tr>
<tr class="separator:a8cc279940c3e1d974831413c03b7b6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729bd1810e58ac3057a41e10951fbba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a729bd1810e58ac3057a41e10951fbba3">addPort</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr class="memdesc:a729bd1810e58ac3057a41e10951fbba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port.  <a href="#a729bd1810e58ac3057a41e10951fbba3">More...</a><br/></td></tr>
<tr class="separator:a729bd1810e58ac3057a41e10951fbba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b56c1247c1dc71bdde4feafa3997fc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a3b56c1247c1dc71bdde4feafa3997fc8">addPort</a> (<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;port)</td></tr>
<tr class="memdesc:a3b56c1247c1dc71bdde4feafa3997fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port.  <a href="#a3b56c1247c1dc71bdde4feafa3997fc8">More...</a><br/></td></tr>
<tr class="separator:a3b56c1247c1dc71bdde4feafa3997fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d3991d677caee96a58bee04304afe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#af5d3991d677caee96a58bee04304afe6">addEventPort</a> (const std::string &amp;name, <a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, <a class="el" href="classRTT_1_1TaskContext.html#a8cc279940c3e1d974831413c03b7b6e5">SlotFunction</a> callback=<a class="el" href="classRTT_1_1TaskContext.html#a8cc279940c3e1d974831413c03b7b6e5">SlotFunction</a>())</td></tr>
<tr class="memdesc:af5d3991d677caee96a58bee04304afe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port.  <a href="#af5d3991d677caee96a58bee04304afe6">More...</a><br/></td></tr>
<tr class="separator:af5d3991d677caee96a58bee04304afe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b71ee3a868346b0131f0aaf4c8f74e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a0b71ee3a868346b0131f0aaf4c8f74e9">addEventPort</a> (<a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;port, <a class="el" href="classRTT_1_1TaskContext.html#a8cc279940c3e1d974831413c03b7b6e5">SlotFunction</a> callback=<a class="el" href="classRTT_1_1TaskContext.html#a8cc279940c3e1d974831413c03b7b6e5">SlotFunction</a>())</td></tr>
<tr class="memdesc:a0b71ee3a868346b0131f0aaf4c8f74e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port.  <a href="#a0b71ee3a868346b0131f0aaf4c8f74e9">More...</a><br/></td></tr>
<tr class="separator:a0b71ee3a868346b0131f0aaf4c8f74e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bdc1004f98bdb898581b5b71d126e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a76bdc1004f98bdb898581b5b71d126e0">getPort</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a76bdc1004f98bdb898581b5b71d126e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a port of this Component.  <a href="#a76bdc1004f98bdb898581b5b71d126e0">More...</a><br/></td></tr>
<tr class="separator:a76bdc1004f98bdb898581b5b71d126e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0f38c658735ebce3e7dad89f9d1902"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d0f38c658735ebce3e7dad89f9d1902"></a>
<a class="el" href="classRTT_1_1DataFlowInterface.html">DataFlowInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#a9d0f38c658735ebce3e7dad89f9d1902">ports</a> ()</td></tr>
<tr class="memdesc:a9d0f38c658735ebce3e7dad89f9d1902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Data flow ports of this task. <br/></td></tr>
<tr class="separator:a9d0f38c658735ebce3e7dad89f9d1902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8395096c3b337dbed1410b9b09ebe5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc8395096c3b337dbed1410b9b09ebe5"></a>
const <a class="el" href="classRTT_1_1DataFlowInterface.html">DataFlowInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1TaskContext.html#adc8395096c3b337dbed1410b9b09ebe5">ports</a> () const </td></tr>
<tr class="memdesc:adc8395096c3b337dbed1410b9b09ebe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Data flow ports of this task. <br/></td></tr>
<tr class="separator:adc8395096c3b337dbed1410b9b09ebe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class manages the access of remote <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> Corba Servers and a Corba Object Request Broker (Orb) which connects to these servers. </p>

<p>Definition at line <a class="el" href="TaskContextProxy_8hpp_source.html#l00082">82</a> of file <a class="el" href="TaskContextProxy_8hpp_source.html">TaskContextProxy.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a8cc279940c3e1d974831413c03b7b6e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;void(<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a>*)&gt; <a class="el" href="classRTT_1_1TaskContext.html#a8cc279940c3e1d974831413c03b7b6e5">RTT::TaskContext::SlotFunction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name and add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give to the port. </td></tr>
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00526">526</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aec42df6b1b306b7a7102fa3bf8e2a296"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296">RTT::base::TaskCore::TaskState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the different states a component can have. </p>
<p>When a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> is being constructed, it is in the <em>Init</em> state. After the construction ends, the component arrives in the <em>PreOperational</em> (additional configuration required) or the <em>Stopped</em> (ready to run) state. Invoking <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a975fddfc6d0fd5dfa77303c20395d87c" title="This method starts the execution of the updateHook() with each trigger or period. ...">start()</a></em> will make a transition to the <em>Running</em> state and <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#aa69a1db58d9b3695477ac75866e4e62c" title="This method stops the execution of updateHook() of this component. ">stop()</a></em> back to the <em>Stopped</em> state. The <em>Running</em> state executes <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a></em>. Finally, there is an <em>FatalError</em> state, in which the component can enter by calling the protected method <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#af208a7b9442ba87f42a3a52a28c5309f" title="Call this method from any place to indicate that this component encountered a fatal error...">fatal()</a></em>. In this state, the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> is stopped and <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a></em> is no longer called. The object should then be disposed by a supervision system.</p>
<p>Next to the fatal error, one run-time error level is available in the <em>Running</em> state as well. This level allows 'automatic' recovery by the component in case the problem is temporal. In case of problems, one may call the protected method <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a3c3b01dff9aa92578d1657bdc3c0fb47" title="Call this method in a Running state to indicate a run-time error condition. ">error()</a></em> when the component is <em>Running</em>. The component will enter the <em>RunTimeError</em> state and will cause the <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a1d100268cdda1f60af1e2203d155168b" title="Implement this method to contain code that must be executed in the RunTimeError state, instead of updateHook(). ">errorHook()</a></em> to be called instead of <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a></em>. When <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a28420e3f52d819fddbe0962cdef98707" title="Call this method in a RunTimeError or Exception state to indicate that the run-time error conditions ...">recover()</a></em> is called, this run-time error state is left and the nominal <em>Running</em> state is entered again.</p>
<p>In order to check if these transitions are allowed, hook functions are executed, which can be filled in by the component builder.</p>
<ul>
<li>A transition from <em>PreOperational</em> to <em>Stopped</em> is checked by calling the <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a9badff843c97307d2b3084c4320606c6" title="Implement this method such that it contains the code which will be executed when configure() is calle...">configureHook()</a></em> method. If this method returns <em>true</em>, the transition is made, otherwise, the state remains <em>PreOperational</em>.</li>
<li>A transition from <em>Stopped</em> to <em>Running</em> is checked by calling the <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#add908fc9e1fcb95dea895e6231edf075" title="Implement this method such that it contains the code which will be executed when start() is called...">startHook()</a></em> method. If this method returns <em>true</em>, the transition is made, otherwise, the state remains <em>Stopped</em>.</li>
<li>A transition from <em>Running</em> to <em>Stopped</em> is always allowed and the <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a8bfeb7f3c3d066080d5af36baacb6648" title="Implement this method such that it contains the code which will be executed when stop() is called...">stopHook()</a></em> method is called to inform the component of this transtion.</li>
<li>A transition from <em>Stopped</em> to <em>PreOperational</em> is always allowed and the <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a7079becea7aa4945ba69cc202713592c" title="Implement this method such that it contains the code which will be executed when cleanup() is called...">cleanupHook()</a></em> method is called to inform the component of this transtion. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aec42df6b1b306b7a7102fa3bf8e2a296ad0f498835f4c0d0d028f17c3dded1808"></a>Init</em>&#160;</td><td class="fielddoc">
<p>The state during component construction. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aec42df6b1b306b7a7102fa3bf8e2a296a18beb1736430c2815bb79cc43d55a5a4"></a>PreOperational</em>&#160;</td><td class="fielddoc">
<p>The state indicating additional configuration is required. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aec42df6b1b306b7a7102fa3bf8e2a296aede93da035b525de95b4682f8a986dd4"></a>FatalError</em>&#160;</td><td class="fielddoc">
<p>The state indicating the component encountered a fatal error and is unable to execute. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aec42df6b1b306b7a7102fa3bf8e2a296aaf7a566a0f56822986b292ae5e90a286"></a>Exception</em>&#160;</td><td class="fielddoc">
<p>The state indicating the component encountered a C++ exception. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aec42df6b1b306b7a7102fa3bf8e2a296a56134dbafdb46e41026cf4c7b1bbb6f8"></a>Stopped</em>&#160;</td><td class="fielddoc">
<p>The state indicating the component is ready to run. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aec42df6b1b306b7a7102fa3bf8e2a296ae9b19cff8d2fde7929812f4108ce80f4"></a>Running</em>&#160;</td><td class="fielddoc">
<p>The state indicating the component is running [green]. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aec42df6b1b306b7a7102fa3bf8e2a296a176c10977c372f2762335620a6382bb4"></a>RunTimeError</em>&#160;</td><td class="fielddoc">
<p>The state indicating that a run-time error has occured [red] and needs attention. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="TaskCore_8hpp_source.html#l00099">99</a> of file <a class="el" href="TaskCore_8hpp_source.html">TaskCore.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a702052a95f039f56c9de1519e10c0b8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::activate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method starts the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> of this component in case it was not running. </p>
<p>Normally, it is always running. There is no way to deactivate it from the public interface. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> is running (again) and false if it could not be started. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1TaskCore.html#adb5e6bc5f0eee821b3f62f9d5482c743">RTT::base::TaskCore</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00629">629</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8cpp_source.html#l00381">RTT::TaskContext::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a228ea19b9974d1ff329a2b4fe6ea3ae8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskContext::addAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a variable of any type as read/write attribute to the attribute interface. </p>
<p>An <a class="el" href="classRTT_1_1Alias.html" title="This class is the most basic Attribute implementation (only suitable for reading a internal::DataSour...">Alias</a> is created which causes contents of the <em>attr</em> variable always to be in sync with the contents of the attribute object in the interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute </td></tr>
    <tr><td class="paramname">attr</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00400">400</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9af8547a01dc1ce03a5b509e11c7638"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskContext::addAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1base_1_1AttributeBase.html" title="An attribute is a minimalistic, named placeholder for data. ">base::AttributeBase</a> which remains owned by the user. </p>
<p>This is a low-level function that can be used if you already created an <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get. ">Attribute</a> object that does not belong yet to a service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>remains owned by the user, and becomes served by the repository. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00426">426</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad610f7822f53345bf7318998c06ca31b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskContext::addConstant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a variable of any type as read-only attribute to the attribute interface. </p>
<p>An <a class="el" href="classRTT_1_1Alias.html" title="This class is the most basic Attribute implementation (only suitable for reading a internal::DataSour...">Alias</a> is created which causes contents of the attribute always to be in sync with the contents of <em>attr</em>, but it can only be read through the interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute </td></tr>
    <tr><td class="paramname">attr</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00413">413</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5d3991d677caee96a58bee04304afe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a>&amp; RTT::TaskContext::addEventPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1TaskContext.html#a8cc279940c3e1d974831413c03b7b6e5">SlotFunction</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code><a class="el" href="classRTT_1_1TaskContext.html#a8cc279940c3e1d974831413c03b7b6e5">SlotFunction</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name and add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give to the port. </td></tr>
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called asynchronously when new data arrives on this port. You can add more functions by using the port directly using base::PortInterface::getNewDataOnPort(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00536">536</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

<p>References <a class="el" href="PortInterface_8cpp_source.html#l00051">RTT::base::PortInterface::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b71ee3a868346b0131f0aaf4c8f74e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a>&amp; RTT::TaskContext::addEventPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1InputPortInterface.html">base::InputPortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1TaskContext.html#a8cc279940c3e1d974831413c03b7b6e5">SlotFunction</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code><a class="el" href="classRTT_1_1TaskContext.html#a8cc279940c3e1d974831413c03b7b6e5">SlotFunction</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an Event triggering Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
    <tr><td class="paramname">callback</td><td>(Optional) provide a function which will be called asynchronously when new data arrives on this port. You can add more functions by using the port directly using base::PortInterface::getNewDataOnPort(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00549">549</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b21856b3e67a002937194e1ed20e24c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt;Signature&gt;&amp; RTT::TaskContext::addOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an operation object to the interface. </p>
<p>This version of addOperation exports an <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a> object to the public interface of this component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation object to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it could be added. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00336">336</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b7f65a4a63331de40b94d712eb49119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Func , class Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; typename <a class="el" href="structRTT_1_1internal_1_1GetSignature.html">internal::GetSignature</a>&lt;Func&gt;::Signature &gt;&amp; RTT::TaskContext::addOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1Service.html">Service</a> *&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a C++ function as an operation. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1Service.html#abd4f94e4184b2f470053ad54c42e6dda" title="Add an operation object to the interface. ">Service::addOperation</a> </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00347">347</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab20c2fe74dd0691f7c07e72948738c8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Signature &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Operation.html">Operation</a>&lt; Signature &gt;&amp; RTT::TaskContext::addOperation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Signature *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#a5bc5629360f41b73f0afd3e901ca4915">ExecutionThread</a>&#160;</td>
          <td class="paramname"><em>et</em> = <code>ClientThread</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a C function as an operation. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1Service.html#abd4f94e4184b2f470053ad54c42e6dda" title="Add an operation object to the interface. ">Service::addOperation</a> </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00358">358</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a10ffef8be36a2ba8a74222f277b990bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::addPeer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> *&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>alias</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a one-way connection from this task to a peer task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer</td><td>The peer to add. </td></tr>
    <tr><td class="paramname">alias</td><td>An optional alias (another name) for the peer. defaults to <em>peer-&gt;<a class="el" href="classRTT_1_1TaskContext.html#a7aa7e91bf90f0793142432f74bb830a1" title="Returns the name of this TaskContext. ">getName()</a></em> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1TaskContext.html#ac3d487151ec08587c525ea66ba9cb1c0">RTT::TaskContext</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00730">730</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8cpp_source.html#l00381">RTT::TaskContext::clear()</a>, <a class="el" href="TaskContextServer_8cpp_source.html#l00409">RTT::corba::TaskContextServer::Create()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00901">server()</a>, and <a class="el" href="TaskContextServer_8cpp_source.html#l00466">RTT::corba::TaskContextServer::server()</a>.</p>

</div>
</div>
<a class="anchor" id="a729bd1810e58ac3057a41e10951fbba3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a>&amp; RTT::TaskContext::addPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name and add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give to the port. </td></tr>
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00512">512</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

<p>References <a class="el" href="PortInterface_8cpp_source.html#l00051">RTT::base::PortInterface::setName()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b56c1247c1dc71bdde4feafa3997fc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a>&amp; RTT::TaskContext::addPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a Port to the interface of this task and add a <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a> with the same name of the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00522">522</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af87c90fd9f75a3fe2e19408b1fc8df2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1Property.html">Property</a>&lt;T&gt;&amp; RTT::TaskContext::addProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a variable of any type as a property to the attribute interface. </p>
<p>A <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> is created which causes contents of the property always to be in sync with the contents of <em>attr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this property </td></tr>
    <tr><td class="paramname">attr</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> object by reference, which you can further query or document. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00468">468</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83976b20bfec26e9609e3ac38136a0b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskContext::addProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an <a class="el" href="classRTT_1_1base_1_1PropertyBase.html" title="Base class for all properties. ">base::PropertyBase</a> as a property. </p>
<dl class="section return"><dt>Returns</dt><dd>false if a property with the same name already exists. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00476">476</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4a3f8cbcfee40c1bc1f4394dadfcf82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskCore::breakUpdateHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this function if your code might block for long times inside the <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a> function. </p>
<p>Insert in this hook the code to wake up that code or signal it otherwise that <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a> is requested to return (for example by setting a flag). The method returns <em>false</em> by default. </p>
<dl class="section return"><dt>Returns</dt><dd>true if well received and <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a> will soon return. False otherwise. </dd></dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00297">297</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00448">RTT::ExecutionEngine::breakLoop()</a>.</p>

</div>
</div>
<a class="anchor" id="a93f4379b062e7286e37c225996c0b709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method instructs a stopped component to enter the pre-operational state again. </p>
<p>It calls <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a7079becea7aa4945ba69cc202713592c" title="Implement this method such that it contains the code which will be executed when cleanup() is called...">cleanupHook()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the component was in the <em>Stopped</em> state. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a009c3d9b097d1904ca6eac98a5b48d0c">RTT::base::TaskCore</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00673">673</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8cpp_source.html#l00381">RTT::TaskContext::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a7079becea7aa4945ba69cc202713592c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskCore::cleanupHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method such that it contains the code which will be executed when <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a009c3d9b097d1904ca6eac98a5b48d0c" title="This method instructs a stopped component to enter the pre-operational state again. ">cleanup()</a></em> is called. </p>
<p>The default implementation is an empty function. </p>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00233">233</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>Referenced by <a class="el" href="TaskCore_8cpp_source.html#l00116">RTT::base::TaskCore::cleanup()</a>, and <a class="el" href="TaskCore_8cpp_source.html#l00147">RTT::base::TaskCore::exception()</a>.</p>

</div>
</div>
<a class="anchor" id="a4eb5d5ee16d21907b5121b65ce7b1717"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskContext::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the complete interface of this Component. </p>
<p>This method removes all objects and all methods, commands, events, properties and ports from the interface of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </p>

<p>Definition at line <a class="el" href="TaskContext_8cpp_source.html#l00381">381</a> of file <a class="el" href="TaskContext_8cpp_source.html">TaskContext.cpp</a>.</p>

<p>Referenced by <a class="el" href="TaskContextProxy_8cpp_source.html#l00629">activate()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00730">addPeer()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00673">cleanup()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00661">configure()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00785">connectPeers()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00854">connectPorts()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00869">connectServices()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00800">disconnectPeers()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00105">initFromURIOrTaskname()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00884">ready()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00759">removePeer()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00605">start()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00617">stop()</a>, and <a class="el" href="TaskContextProxy_8cpp_source.html#l00172">TaskContextProxy()</a>.</p>

</div>
</div>
<a class="anchor" id="a302f6a3d529d29c7c1ccc60afb840441"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::configure </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method instructs the component to (re-)read configuration data and try to enter the <em>Stopped</em> state. </p>
<p>This can only succeed if the component is not running and <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a9badff843c97307d2b3084c4320606c6" title="Implement this method such that it contains the code which will be executed when configure() is calle...">configureHook()</a></em> returns true. </p>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a492aed947a9bb2cbc25140884bc34e1b">RTT::base::TaskCore</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00661">661</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8cpp_source.html#l00381">RTT::TaskContext::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a9badff843c97307d2b3084c4320606c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskCore::configureHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method such that it contains the code which will be executed when <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a492aed947a9bb2cbc25140884bc34e1b" title="This method instructs the component to (re-)read configuration data and try to enter the Stopped stat...">configure()</a></em> is called. </p>
<p>The default implementation is an empty function which returns <em>true</em>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>to indicate that configuration succeeded and the Stopped state may be entered. </td></tr>
    <tr><td class="paramname">false</td><td>to indicate that configuration failed and the Preoperational state is entered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00281">281</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>Referenced by <a class="el" href="TaskCore_8cpp_source.html#l00093">RTT::base::TaskCore::configure()</a>.</p>

</div>
</div>
<a class="anchor" id="a5221c6007b7ceb6d397b9b8bf02b5943"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html">TaskContextProxy</a> * RTT::corba::TaskContextProxy::Create </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_ior</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method: create a CORBA Proxy for an existing <a class="el" href="classRTT_1_1corba_1_1TaskContextServer.html" title="This class manages the creation of TaskContext Corba Servers and a Corba Object Request Broker (Orb) ...">TaskContextServer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classRTT_1_1corba_1_1TaskContextServer.html" title="This class manages the creation of TaskContext Corba Servers and a Corba Object Request Broker (Orb) ...">TaskContextServer</a> to connect to or the Object Reference of the object to connect to </td></tr>
    <tr><td class="paramname">is_ior</td><td>set to <em>true</em> if <em>name</em> is an IOR. Defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the ORB is not initialised </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new or previously created CORBA proxy for <em>name</em>. </dd></dl>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00520">520</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00381">RTT::Logger::nl()</a>, <a class="el" href="ApplicationServer_8hpp_source.html#l00062">RTT::corba::ApplicationServer::orb</a>, and <a class="el" href="TaskContextProxy_8cpp_source.html#l00100">TaskContextProxy()</a>.</p>

<p>Referenced by <a class="el" href="TaskContextFactory_8cpp_source.html#l00052">RTT::corba::TaskContextFactory::Create()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00543">CreateFromFile()</a>, and <a class="el" href="TaskContextProxy_8cpp_source.html#l00839">getPeer()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a66a077c9d9add68b0057b6aa71feef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> * RTT::corba::TaskContextProxy::Create </td>
          <td>(</td>
          <td class="paramtype">::RTT::corba::CTaskContext_ptr&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_remote</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method: create a CORBA Proxy for an existing <a class="el" href="classRTT_1_1corba_1_1TaskContextServer.html" title="This class manages the creation of TaskContext Corba Servers and a Corba Object Request Broker (Orb) ...">TaskContextServer</a>. </p>
<p>This method may in fact return the real <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> in case the servant of <em>task</em> is in the same process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The Object to create a proxy for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the ORB is not initialised </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new or previously created CORBA proxy for <em>task</em>, or the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> itself. </dd></dl>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00560">560</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00381">RTT::Logger::nl()</a>, <a class="el" href="ApplicationServer_8hpp_source.html#l00062">RTT::corba::ApplicationServer::orb</a>, and <a class="el" href="TaskContextProxy_8cpp_source.html#l00100">TaskContextProxy()</a>.</p>

</div>
</div>
<a class="anchor" id="af20c64c88305e2a64a8a1a778e8ebf2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html">TaskContextProxy</a> * RTT::corba::TaskContextProxy::CreateFromFile </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method: create a CORBA Proxy for an existing <a class="el" href="classRTT_1_1corba_1_1TaskContextServer.html" title="This class manages the creation of TaskContext Corba Servers and a Corba Object Request Broker (Orb) ...">TaskContextServer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A file containing an IOR which refers to the existing <a class="el" href="classRTT_1_1corba_1_1TaskContextServer.html" title="This class manages the creation of TaskContext Corba Servers and a Corba Object Request Broker (Orb) ...">TaskContextServer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the ORB is not initialised </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new or previously created CORBA proxy for <em>filename</em>. </dd></dl>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00543">543</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="TaskContextProxy_8cpp_source.html#l00520">Create()</a>, and <a class="el" href="ApplicationServer_8hpp_source.html#l00062">RTT::corba::ApplicationServer::orb</a>.</p>

<p>Referenced by <a class="el" href="TaskContextFactory_8cpp_source.html#l00057">RTT::corba::TaskContextFactory::CreateFromFile()</a>.</p>

</div>
</div>
<a class="anchor" id="a990586cfe74123de656950365be45fea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskContext::dataOnPortCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method implements port callbacks. </p>
<p>It will be called once per sample received on the port and is executed in the component's thread.</p>
<p>The default implementation invokes the user callback if one was given in the <a class="el" href="classRTT_1_1TaskContext.html#af5d3991d677caee96a58bee04304afe6" title="Name and add an Event triggering Port to the interface of this task and add a Service with the same n...">addEventPort()</a> call. It can be overwritten in a subclass to react on incoming data for all event ports. This is equivalent to adding this function as a user callback on each of the ports individually. </p>

<p>Definition at line <a class="el" href="TaskContext_8cpp_source.html#l00434">434</a> of file <a class="el" href="TaskContext_8cpp_source.html">TaskContext.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa4d739183c23583a00eb37b555238a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskContext::dataOnPortHook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a> *&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplement this method to influence how writing to event ports is handled by the component. </p>
<p>This method will be executed in the writer's thread.</p>
<p>The default implementation returns true if and only if the component is running.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>to indicate that the user callback should be invoked and trigger the component </td></tr>
    <tr><td class="paramname">false</td><td>to ignore the new data and not trigger the component or invoke a user callback </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8cpp_source.html#l00430">430</a> of file <a class="el" href="TaskContext_8cpp_source.html">TaskContext.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8cpp_source.html#l00236">RTT::base::TaskCore::isRunning()</a>.</p>

</div>
</div>
<a class="anchor" id="aa03a9ce88c728b6c996bf19f4ab3693d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskContext::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> from it's peers and ports. </p>
<p>All its Data Flow Ports are disconnected as well. This method invokes <a class="el" href="classRTT_1_1TaskContext.html#a3c3c00069dfb5ad81a343d81e7bd30c4" title="Remove a one-way connection from this task to a peer task. ">removePeer()</a> as well on the peers listed in this-&gt;<a class="el" href="classRTT_1_1TaskContext.html#a9d294341f8464b87c4609b2f89b5ecb7" title="Return a standard container which contains all the Peer names of this TaskContext. ">getPeerList()</a>. </p>

<p>Definition at line <a class="el" href="TaskContext_8cpp_source.html#l00288">288</a> of file <a class="el" href="TaskContext_8cpp_source.html">TaskContext.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8hpp_source.html#l00117">RTT::TaskContext::getName()</a>, <a class="el" href="DataFlowInterface_8cpp_source.html#l00198">RTT::DataFlowInterface::getPorts()</a>, and <a class="el" href="TaskContext_8hpp_source.html#l00566">RTT::TaskContext::ports()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c3b01dff9aa92578d1657bdc3c0fb47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskCore::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this method in a Running state to indicate a run-time error condition. </p>
<p><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a1d100268cdda1f60af1e2203d155168b" title="Implement this method to contain code that must be executed in the RunTimeError state, instead of updateHook(). ">errorHook()</a> will be called instead of <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a>. If the error condition is solved, call <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a28420e3f52d819fddbe0962cdef98707" title="Call this method in a RunTimeError or Exception state to indicate that the run-time error conditions ...">recover()</a>. </p>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00140">140</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00105">RTT::base::TaskCore::Running</a>, and <a class="el" href="TaskCore_8hpp_source.html#l00106">RTT::base::TaskCore::RunTimeError</a>.</p>

</div>
</div>
<a class="anchor" id="a1d100268cdda1f60af1e2203d155168b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskCore::errorHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to contain code that must be executed in the RunTimeError state, instead of <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a>. </p>
<p>This allows you to specify the behaviour in an erroneous component. <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a1d100268cdda1f60af1e2203d155168b" title="Implement this method to contain code that must be executed in the RunTimeError state, instead of updateHook(). ">errorHook()</a> is called as long as the component is not <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a28420e3f52d819fddbe0962cdef98707" title="Call this method in a RunTimeError or Exception state to indicate that the run-time error conditions ...">recover()</a>'ed. After <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a28420e3f52d819fddbe0962cdef98707" title="Call this method in a RunTimeError or Exception state to indicate that the run-time error conditions ...">recover()</a>'ed, the <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a> is called again. </p>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00290">290</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a243f1797bcfef248146ee02166a1eeb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskCore::exception </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this method to indicate a run-time exception happend. </p>
<p>First the TaskState is set to Exception. Next, if the taskstate was &gt;= Running, <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a8bfeb7f3c3d066080d5af36baacb6648" title="Implement this method such that it contains the code which will be executed when stop() is called...">stopHook()</a> is called. Next, if the taskstate was &gt;= Stopped, <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a7079becea7aa4945ba69cc202713592c" title="Implement this method such that it contains the code which will be executed when cleanup() is called...">cleanupHook()</a> is called. Finally, <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a576b146a57bd81b1f5fe3a8e51f0bd16" title="Implement this method to contain code that must be executed when transitioning to the Exception state...">exceptionHook()</a> is called. If any exception happens in <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a576b146a57bd81b1f5fe3a8e51f0bd16" title="Implement this method to contain code that must be executed when transitioning to the Exception state...">exceptionHook()</a>, <a class="el" href="classRTT_1_1base_1_1TaskCore.html#af208a7b9442ba87f42a3a52a28c5309f" title="Call this method from any place to indicate that this component encountered a fatal error...">fatal()</a> is called. </p>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00147">147</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8cpp_source.html#l00233">RTT::base::TaskCore::cleanupHook()</a>, <a class="el" href="TaskCore_8hpp_source.html#l00103">RTT::base::TaskCore::Exception</a>, <a class="el" href="TaskCore_8cpp_source.html#l00302">RTT::base::TaskCore::exceptionHook()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00135">RTT::base::TaskCore::fatal()</a>, <a class="el" href="TaskCore_8hpp_source.html#l00101">RTT::base::TaskCore::PreOperational</a>, <a class="el" href="TaskCore_8hpp_source.html#l00105">RTT::base::TaskCore::Running</a>, <a class="el" href="TaskCore_8cpp_source.html#l00305">RTT::base::TaskCore::stopHook()</a>, <a class="el" href="TaskCore_8hpp_source.html#l00104">RTT::base::TaskCore::Stopped</a>, and <a class="el" href="CatchConfig_8hpp_source.html#l00056">TRY</a>.</p>

<p>Referenced by <a class="el" href="TaskCore_8cpp_source.html#l00116">RTT::base::TaskCore::cleanup()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00093">RTT::base::TaskCore::configure()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00466">RTT::ExecutionEngine::setExceptionTask()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00180">RTT::base::TaskCore::start()</a>, and <a class="el" href="TaskCore_8cpp_source.html#l00203">RTT::base::TaskCore::stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a576b146a57bd81b1f5fe3a8e51f0bd16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskCore::exceptionHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to contain code that must be executed when transitioning to the Exception state. </p>
<p>This allows you to specify the last actions in an erroneous component, after <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a8bfeb7f3c3d066080d5af36baacb6648" title="Implement this method such that it contains the code which will be executed when stop() is called...">stopHook()</a> and <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a7079becea7aa4945ba69cc202713592c" title="Implement this method such that it contains the code which will be executed when cleanup() is called...">cleanupHook()</a> were called. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a28420e3f52d819fddbe0962cdef98707" title="Call this method in a RunTimeError or Exception state to indicate that the run-time error conditions ...">recover()</a> to leave the <a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296aaf7a566a0f56822986b292ae5e90a286" title="The state indicating the component encountered a C++ exception. ">Exception</a> state. </dd></dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00302">302</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>Referenced by <a class="el" href="TaskCore_8cpp_source.html#l00147">RTT::base::TaskCore::exception()</a>.</p>

</div>
</div>
<a class="anchor" id="af208a7b9442ba87f42a3a52a28c5309f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskCore::fatal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this method from any place to indicate that this component encountered a fatal error. </p>
<p>It calls no hooks, the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> is stopped and the component waits destruction. </p>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00135">135</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, <a class="el" href="TaskCore_8hpp_source.html#l00102">RTT::base::TaskCore::FatalError</a>, <a class="el" href="RunnableInterface_8hpp_source.html#l00175">RTT::base::RunnableInterface::getActivity()</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a78717d9d9533a58bac8d1f0eadf564a1">RTT::base::ActivityInterface::stop()</a>.</p>

<p>Referenced by <a class="el" href="TaskCore_8cpp_source.html#l00147">RTT::base::TaskCore::exception()</a>.</p>

</div>
</div>
<a class="anchor" id="a59ef45d1d0a48a1123763ed534a9b4b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskContext::forceActivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">base::ActivityInterface</a> *&#160;</td>
          <td class="paramname"><em>new_act</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the current activity to become <em>new_act</em>, even if this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> is still running. </p>
<p>This can be used to bypass the <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a9168525a25ec73b7240042613688b6fa" title="Inspect if the component is in the Running or RunTimeError state. ">isRunning()</a> check regular <a class="el" href="classRTT_1_1TaskContext.html#a65fa89828cdf260496f27643e4ab9344" title="Sets the activity of this TaskContext. ">setActivity()</a> does. </p>

<p>Definition at line <a class="el" href="TaskContext_8cpp_source.html#l00361">361</a> of file <a class="el" href="TaskContext_8cpp_source.html">TaskContext.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a78717d9d9533a58bac8d1f0eadf564a1">RTT::base::ActivityInterface::stop()</a>.</p>

<p>Referenced by <a class="el" href="TaskContextProxy_8cpp_source.html#l00172">TaskContextProxy()</a>.</p>

</div>
</div>
<a class="anchor" id="a6bb066129eb925e0a245509bb2c2cca1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">ActivityInterface</a> * RTT::TaskContext::getActivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the activity running this component. </p>
<dl class="section return"><dt>Returns</dt><dd>Our activity. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8cpp_source.html#l00374">374</a> of file <a class="el" href="TaskContext_8cpp_source.html">TaskContext.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, and <a class="el" href="RunnableInterface_8hpp_source.html#l00175">RTT::base::RunnableInterface::getActivity()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f4cefc2a489ea98d3d08137d8f9e97e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* RTT::TaskContext::getActivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the activity running this component. </p>
<p>Unlike the non-template version, it converts it to the activity type provided.</p>
<p>Example usage in a <a class="el" href="classRTT_1_1base_1_1TaskCore.html#add908fc9e1fcb95dea895e6231edf075" title="Implement this method such that it contains the code which will be executed when start() is called...">startHook()</a>: <code> <a class="el" href="classRTT_1_1extras_1_1FileDescriptorActivity.html" title="An activity which is triggered by the availability of data on a set of file descriptors. ">RTT::extras::FileDescriptorActivity</a>* fd_activity = <a class="el" href="classRTT_1_1TaskContext.html#a6bb066129eb925e0a245509bb2c2cca1" title="Get a pointer to the activity running this component. ">getActivity&lt;RTT::extras::FileDescriptorActivity&gt;()</a>; if (fd_activity) { // do specific setup for FDActivity } </code></p>
<dl class="section return"><dt>Returns</dt><dd>Our activity if it is of type T, NULL otherwise. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00162">162</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

<p>References <a class="el" href="TaskContext_8hpp_source.html#l00162">RTT::TaskContext::getActivity()</a>.</p>

<p>Referenced by <a class="el" href="TaskContext_8hpp_source.html#l00162">RTT::TaskContext::getActivity()</a>.</p>

</div>
</div>
<a class="anchor" id="a3406693cbcf04d5128f71286056cc06f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1AttributeBase.html">base::AttributeBase</a>* RTT::TaskContext::getAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a variable of any type as read/write attribute to the attribute interface. </p>
<p>An <a class="el" href="classRTT_1_1Alias.html" title="This class is the most basic Attribute implementation (only suitable for reading a internal::DataSour...">Alias</a> is created which causes contents of the <em>attr</em> variable always to be in sync with the contents of the attribute object in the interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this attribute </td></tr>
    <tr><td class="paramname">attr</td><td>The variable that will be aliased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00439">439</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf99cd58b81ce05216baae47e5b04364"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned RTT::TaskCore::getCpuAffinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the configured cpu affinity of this component. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#aeabaef68a4faab68d398fa2deaf9ad04" title="Get the cpu affinity of this activity. ">ActivityInterface::getCpuAffinity()</a> </dd></dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00271">271</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, <a class="el" href="RunnableInterface_8hpp_source.html#l00175">RTT::base::RunnableInterface::getActivity()</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#aeabaef68a4faab68d398fa2deaf9ad04">RTT::base::ActivityInterface::getCpuAffinity()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d6ce3034250e9673cc6c80e7d03cc92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RTT::base::TaskCore::getCycleCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each update cycle, this counter increments by one. </p>
<p>You can use this to check across (callback) functions if we're still in the same cycle or in a new one. </p>

<p>Definition at line <a class="el" href="TaskCore_8hpp_source.html#l00324">324</a> of file <a class="el" href="TaskCore_8hpp_source.html">TaskCore.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3261db01744046dfe1ad016bf4781c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1OperationInterfacePart.html">OperationInterfacePart</a>* RTT::TaskContext::getOperation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a previously added operation for use in a C++ <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> object. </p>
<p>Store the result of this function in a <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a>&lt;<em>Signature&gt;</em> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the operation to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it could be found, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00372">372</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa8422f6c124522214dd159f19b8067e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1TaskContext.html">TaskContext</a> * RTT::corba::TaskContextProxy::getPeer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>peer_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to a peer of this task. </p>
<dl class="section return"><dt>Returns</dt><dd>null if no such peer. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1TaskContext.html#a7bb58076846edaf52dd0ad6a4d64b110">RTT::TaskContext</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00839">839</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="TaskContextProxy_8cpp_source.html#l00520">Create()</a>.</p>

</div>
</div>
<a class="anchor" id="ab3f9dfd33aac3116805a8d1801c8edfe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRTT.html#ab93965f88bfbe72fbc2ece16c047c902">Seconds</a> RTT::TaskCore::getPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the configured execution period of this component. </p>
<p>Note that this value only is used when the component <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a5d20397ed24caa3beea9d981823aa9a6" title="Inspect if the component&#39;s ExecutionEngine is processing requests. ">isActive()</a> or <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a9168525a25ec73b7240042613688b6fa" title="Inspect if the component is in the Running or RunTimeError state. ">isRunning()</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0.0</td><td>if the component is non-periodic (event based). </td></tr>
    <tr><td class="paramname">a</td><td>negative number when the component is not executable. </td></tr>
    <tr><td class="paramname">a</td><td>positive value when the component is periodic. The period is expressed in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>: add a bool <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a7d3ad5b4301ec54a2357d2f8bc60e2b8" title="Sets the period of this component. ">setPeriod(double)</a> function to allow changing the period at run-time. </dd></dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00261">261</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, <a class="el" href="RunnableInterface_8hpp_source.html#l00175">RTT::base::RunnableInterface::getActivity()</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a7c98bdeaa51f490d6f61e7aea7ada91a">RTT::base::ActivityInterface::getPeriod()</a>.</p>

</div>
</div>
<a class="anchor" id="a76bdc1004f98bdb898581b5b71d126e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a>* RTT::TaskContext::getPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a port of this Component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The port name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a port or null if it does not exist. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00558">558</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ee485a4df00e9582430174a6505f538"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a>* RTT::TaskContext::getProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> with name <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the property to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a> with this name, zero if it does not exist </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00487">487</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a29ef110689fbd9a49181921136cf4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ServiceType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;ServiceType&gt; RTT::TaskContext::getProvider </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this method to be able to make <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> calls to services provided by this component. </p>
<p>In case the service does not exist in this component, it tries to load the service using the <a class="el" href="classRTT_1_1plugin_1_1PluginLoader.html" title="Loads plugins found on the filesystem and keeps track of found plugins, typekits and services...">plugin::PluginLoader</a> class. If all fails, a null pointer is returned.</p>
<p>For example: getProvider&lt;Scripting&gt;("scripting")-&gt;loadPrograms("file.ops");</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the service to get, must have been added with addService. </td></tr>
    <tr><td class="paramname">ServiceType</td><td>the <a class="el" href="classRTT_1_1ServiceRequester.html" title="An object that expresses you wish to use a service. ">ServiceRequester</a> type to use. Must have a constructor that takes TaskContext* as argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared <a class="el" href="classRTT_1_1ServiceRequester.html" title="An object that expresses you wish to use a service. ">ServiceRequester</a> object which allows to call the operations provided by service <em>name</em>. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00298">298</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c7eb9108377ea236a034970ce1882e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296">TaskCore::TaskState</a> RTT::TaskCore::getTargetState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the state this <a class="el" href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task. ">TaskCore</a> is going to, or in case no transition is taking place, returns <a class="el" href="classRTT_1_1base_1_1TaskCore.html#aeebedaf344a1eae84f34b51ba052f299" title="Returns the current state of the TaskCore. ">getTaskState()</a>. </p>
<p>For example, before <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a975fddfc6d0fd5dfa77303c20395d87c" title="This method starts the execution of the updateHook() with each trigger or period. ...">start()</a>, this function returns Stopped. During <a class="el" href="classRTT_1_1base_1_1TaskCore.html#add908fc9e1fcb95dea895e6231edf075" title="Implement this method such that it contains the code which will be executed when start() is called...">startHook()</a>, it returns Running and after <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a975fddfc6d0fd5dfa77303c20395d87c" title="This method starts the execution of the updateHook() with each trigger or period. ...">start()</a> it also returns Running.</p>
<p>If <a class="el" href="classRTT_1_1base_1_1TaskCore.html#aeebedaf344a1eae84f34b51ba052f299" title="Returns the current state of the TaskCore. ">getTaskState()</a> != getTargetState, a transition is taking place.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1base_1_1TaskCore.html#aeebedaf344a1eae84f34b51ba052f299" title="Returns the current state of the TaskCore. ">getTaskState()</a> </dd></dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00079">79</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03fd594949ef8654daa21998e313a7c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1TaskCore.html#aec42df6b1b306b7a7102fa3bf8e2a296">TaskContext::TaskState</a> RTT::corba::TaskContextProxy::getTaskState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current state of the TaskCore. </p>
<p>For example, before <a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#aa9bd244082ee0352d45f448e1b5e841a" title="This method starts the execution of the updateHook() with each trigger or period. ...">start()</a>, this function returns Stopped. During <a class="el" href="classRTT_1_1base_1_1TaskCore.html#add908fc9e1fcb95dea895e6231edf075" title="Implement this method such that it contains the code which will be executed when start() is called...">startHook()</a> it returns Stopped, and after <a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#aa9bd244082ee0352d45f448e1b5e841a" title="This method starts the execution of the updateHook() with each trigger or period. ...">start()</a> it returns Running.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a6c7eb9108377ea236a034970ce1882e5" title="Returns the state this TaskCore is going to, or in case no transition is taking place, returns getTaskState(). ">getTargetState()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1TaskCore.html#aeebedaf344a1eae84f34b51ba052f299">RTT::base::TaskCore</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00715">715</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00100">RTT::base::TaskCore::Init</a>.</p>

</div>
</div>
<a class="anchor" id="aa58e8059f29506a1c4df9bd60eb24542"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::inFatalError </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inspect if the component is in the FatalError state. </p>
<p>There is no possibility to recover from this state. You need to destroy and recreate your component. </p>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a17eced3a04772d8a2b36c9b37e5f630c">RTT::base::TaskCore</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00695">695</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32ebf2eb7aaf1d82875d8e5156bbdbda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RTT_CORBA_API bool RTT::corba::ApplicationServer::InitOrb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#ab93965f88bfbe72fbc2ece16c047c902">Seconds</a>&#160;</td>
          <td class="paramname"><em>orb_timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke this method once to initialise the Orb which will run the task servers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orb_timeout</td><td>timeout value for each remote call, expressed in seconds. The resolution is up to 100 nano seconds. Anything smaller will be interpreted as a zero. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ApplicationServer_8cpp_source.html#l00055">55</a> of file <a class="el" href="ApplicationServer_8cpp_source.html">ApplicationServer.cpp</a>.</p>

<p>References <a class="el" href="Logger_8cpp_source.html#l00117">RTT::Logger::log()</a>, <a class="el" href="Logger_8cpp_source.html#l00381">RTT::Logger::nl()</a>, <a class="el" href="ApplicationServer_8hpp_source.html#l00062">RTT::corba::ApplicationServer::orb</a>, and <a class="el" href="ApplicationServer_8hpp_source.html#l00067">RTT::corba::ApplicationServer::rootPOA</a>.</p>

<p>Referenced by <a class="el" href="TaskContextFactory_8cpp_source.html#l00042">RTT::corba::TaskContextFactory::InitOrb()</a>.</p>

</div>
</div>
<a class="anchor" id="a00904940f4bfcd7e23261a6e8325b06f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::isActive </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inspect if the component's <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> is processing requests. </p>
<p>Normally this is always the case, but user code could stop the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> manually. </p>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a5d20397ed24caa3beea9d981823aa9a6">RTT::base::TaskCore</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00641">641</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1da68cc7d2a8de66bcda32096b754735"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::isConfigured </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inspect if the component is configured, i.e. </p>
<p>in the Stopped, Active or Running state. </p>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a536c8b64294fb60bb54ada1a75045510">RTT::base::TaskCore</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00685">685</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e5ecacf2bf68d3eabee711747a12dd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::isRunning </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inspect if the component is in the Running or RunTimeError state. </p>
<p>As RunTimeError is a substate of Running, this method also returns true when the component is in one of these states. See <a class="el" href="classRTT_1_1corba_1_1TaskContextProxy.html#ae94d2e03dda53dcad5e4a2b4aea0032e" title="Inspect if the component is in the RunTimeError state. ">inRunTimeError()</a> or testing the run-time error state. </p>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a9168525a25ec73b7240042613688b6fa">RTT::base::TaskCore</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00651">651</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4faaafad020f0b5816f9ef6ae5bc87b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskContext::loadService </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this method to load a service known to <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute. ">RTT</a> into this component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>The name with which the service is registered by in the PluginLoader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the service was present already or could be loaded. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8cpp_source.html#l00229">229</a> of file <a class="el" href="TaskContext_8cpp_source.html">TaskContext.cpp</a>.</p>

<p>References <a class="el" href="PluginLoader_8cpp_source.html#l00316">RTT::plugin::PluginLoader::Instance()</a>, and <a class="el" href="TaskContext_8hpp_source.html#l00257">RTT::TaskContext::provides()</a>.</p>

</div>
</div>
<a class="anchor" id="af11b11de5bb15692305f1d1df3840540"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::TaskContext::provides </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer from this. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00257">257</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

<p>Referenced by <a class="el" href="TaskContextServer_8cpp_source.html#l00271">RTT::corba::TaskContextServer::CleanupServer()</a>, <a class="el" href="TaskContext_8cpp_source.html#l00187">RTT::TaskContext::connectServices()</a>, <a class="el" href="MarshallingService_8cpp_source.html#l00056">RTT::marsh::MarshallingService::Create()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00065">RTT::scripting::ScriptingService::Create()</a>, <a class="el" href="Service_8cpp_source.html#l00052">RTT::Service::Create()</a>, <a class="el" href="TaskContextProxy_8cpp_source.html#l00105">initFromURIOrTaskname()</a>, <a class="el" href="TaskContext_8cpp_source.html#l00229">RTT::TaskContext::loadService()</a>, <a class="el" href="Parser_8cpp_source.html#l00197">RTT::scripting::Parser::parseValueStatement()</a>, <a class="el" href="PeerParser_8cpp_source.html#l00151">RTT::scripting::PeerParser::reset()</a>, and <a class="el" href="TaskContextProxy_8cpp_source.html#l00172">TaskContextProxy()</a>.</p>

</div>
</div>
<a class="anchor" id="a25f9aabe8979225a1bf4e2825920ff66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service::shared_ptr RTT::TaskContext::provides </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sub-Service which resorts under this <a class="el" href="classRTT_1_1Service.html" title="This class allows storage and retrieval of operations, ports, attributes and properties provided by a...">Service</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_name</td><td>The name of the sub-service. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskContext_8hpp_source.html#l00264">264</a> of file <a class="el" href="TaskContext_8hpp_source.html">TaskContext.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9ca163585e0ea9480424cd59531a0aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the validity of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </p>
<p>When this method returns false, the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> should not be used and various methods may throw exceptions. Use this in case the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> could be a remote object. Will always return true when this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> is local. </p>

<p>Reimplemented from <a class="el" href="classRTT_1_1TaskContext.html#abdcbcf1f47651e911ed91ddec6ecac7d">RTT::TaskContext</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00884">884</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8cpp_source.html#l00381">RTT::TaskContext::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a28420e3f52d819fddbe0962cdef98707"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskCore::recover </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this method in a RunTimeError or Exception state to indicate that the run-time error conditions are gone and nominal operation is resumed. </p>
<p>Makes transition to Running or PreOperational, depending on the state it was in. </p>
<dl class="section return"><dt>Returns</dt><dd>false if not applicable in the current state. </dd></dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00168">168</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00103">RTT::base::TaskCore::Exception</a>, <a class="el" href="TaskCore_8hpp_source.html#l00105">RTT::base::TaskCore::Running</a>, and <a class="el" href="TaskCore_8hpp_source.html#l00106">RTT::base::TaskCore::RunTimeError</a>.</p>

</div>
</div>
<a class="anchor" id="a6d7a5238ce5bea0359ba5c2bf766584a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">corba::CTaskContext_ptr RTT::corba::TaskContextProxy::server </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Corba Object of the <a class="el" href="interfaceRTT_1_1corba_1_1CTaskContext.html" title="A CTaskContext is the main entry point of a distributed component and maps to a RTT::TaskContext. ">CTaskContext</a>. </p>
<p>You need to duplicate this object reference in case you wish to keep a reference to it. This object universally identifies the remote <a class="el" href="classRTT_1_1corba_1_1TaskContextServer.html" title="This class manages the creation of TaskContext Corba Servers and a Corba Object Request Broker (Orb) ...">TaskContextServer</a> and can be used to tell other (remote) objects where to find it. </p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00901">901</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>Referenced by <a class="el" href="TaskContextProxy_8cpp_source.html#l00730">addPeer()</a>.</p>

</div>
</div>
<a class="anchor" id="a65fa89828cdf260496f27643e4ab9344"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskContext::setActivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">base::ActivityInterface</a> *&#160;</td>
          <td class="paramname"><em>new_act</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the activity of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </p>
<p>The activity is owned by the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> and you should not hold a pointer to it after this call. Use <a class="el" href="classRTT_1_1TaskContext.html#a6bb066129eb925e0a245509bb2c2cca1" title="Get a pointer to the activity running this component. ">getActivity()</a> lateron to retrieve a safe pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_act</td><td>The new activity for this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>, which becomes owned by this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>, in case this method returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if this-&gt;<a class="el" href="classRTT_1_1base_1_1TaskCore.html#a9168525a25ec73b7240042613688b6fa" title="Inspect if the component is in the Running or RunTimeError state. ">isRunning()</a>. You can not change the activity of a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> once it is running. In that case, new_act is not destroyed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function may not be called from the current <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> thread (OwnThread), another thread (ClientThread) must call this function. </dd></dl>

<p>Definition at line <a class="el" href="TaskContext_8cpp_source.html#l00339">339</a> of file <a class="el" href="TaskContext_8cpp_source.html">TaskContext.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00236">RTT::base::TaskCore::isRunning()</a>, <a class="el" href="ActivityInterface_8cpp_source.html#l00057">RTT::base::ActivityInterface::run()</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a78717d9d9533a58bac8d1f0eadf564a1">RTT::base::ActivityInterface::stop()</a>.</p>

<p>Referenced by <a class="el" href="TaskContextProxy_8cpp_source.html#l00105">initFromURIOrTaskname()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ed3cee9867d1367b6c482a0584f5045"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskCore::setCpuAffinity </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the cpu affinity of this component. </p>
<dl class="section return"><dt>Returns</dt><dd>false if not allowed by the component's activity. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a73f4d59d811f9ec4941f5c5bf84ce643" title="Set the cpu affinity of this activity. ">ActivityInterface::setCpuAffinity()</a> </dd></dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00276">276</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, <a class="el" href="RunnableInterface_8hpp_source.html#l00175">RTT::base::RunnableInterface::getActivity()</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a73f4d59d811f9ec4941f5c5bf84ce643">RTT::base::ActivityInterface::setCpuAffinity()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d3ad5b4301ec54a2357d2f8bc60e2b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskCore::setPeriod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRTT.html#ab93965f88bfbe72fbc2ece16c047c902">Seconds</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the period of this component. </p>
<p>You may call this at any time, it is simply forwarded to the component's activity object. </p>
<dl class="section return"><dt>Returns</dt><dd>false if not allowed by the component's activity. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a8f83999d9bc8cd48a7950be3c4cb7cf9" title="Set the periodicity of this activity in Seconds. ">ActivityInterface::setPeriod()</a> </dd></dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00266">266</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, <a class="el" href="RunnableInterface_8hpp_source.html#l00175">RTT::base::RunnableInterface::getActivity()</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a8f83999d9bc8cd48a7950be3c4cb7cf9">RTT::base::ActivityInterface::setPeriod()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9bd244082ee0352d45f448e1b5e841a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method starts the execution of the <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a></em> with each trigger or period. </p>
<p>This function calls the user function <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#add908fc9e1fcb95dea895e6231edf075" title="Implement this method such that it contains the code which will be executed when start() is called...">startHook()</a></em>, which must return <em>true</em> in order to allow this component to run. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td><ul>
<li>if <a class="el" href="classRTT_1_1base_1_1TaskCore.html#add908fc9e1fcb95dea895e6231edf075" title="Implement this method such that it contains the code which will be executed when start() is called...">startHook()</a> returned false</li>
<li>if the component was not Stopped </li>
</ul>
</td></tr>
    <tr><td class="paramname">true</td><td>if the <em>Running</em> state was entered. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1TaskContext.html#a6620b7f7ed8497c4f4e4729f0be119c5">RTT::TaskContext</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00605">605</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8cpp_source.html#l00381">RTT::TaskContext::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="add908fc9e1fcb95dea895e6231edf075"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskCore::startHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method such that it contains the code which will be executed when <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#a975fddfc6d0fd5dfa77303c20395d87c" title="This method starts the execution of the updateHook() with each trigger or period. ...">start()</a></em> is called. </p>
<p>The default implementation is an empty function which returns <em>true</em>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>to indicate that the component may run and the Running state may be entered. </td></tr>
    <tr><td class="paramname">false</td><td>to indicate that the component may not run and the Stopped state is entered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00285">285</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>Referenced by <a class="el" href="TaskCore_8cpp_source.html#l00180">RTT::base::TaskCore::start()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ea56b9ed500fbf9bec7a769cd2ccae7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::corba::TaskContextProxy::stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method stops the execution of <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a4b16151ed99062bca250ddfe667a3604" title="Function where the user must insert his &#39;application&#39; code. ">updateHook()</a> of this component. </p>
<p>You can override this method to do something else or in addition. This function calls <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a8bfeb7f3c3d066080d5af36baacb6648" title="Implement this method such that it contains the code which will be executed when stop() is called...">stopHook()</a> as well. </p>
<dl class="section return"><dt>Returns</dt><dd>false if the component was not <em>Running</em> or not <em>Active</em>. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1TaskContext.html#a5808edd8ac174129cc861bfa485e8de0">RTT::TaskContext</a>.</p>

<p>Definition at line <a class="el" href="TaskContextProxy_8cpp_source.html#l00617">617</a> of file <a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a>.</p>

<p>References <a class="el" href="TaskContext_8cpp_source.html#l00381">RTT::TaskContext::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bfeb7f3c3d066080d5af36baacb6648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskCore::stopHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method such that it contains the code which will be executed when <em><a class="el" href="classRTT_1_1base_1_1TaskCore.html#aa69a1db58d9b3695477ac75866e4e62c" title="This method stops the execution of updateHook() of this component. ">stop()</a></em> is called. </p>
<p>The default implementation is an empty function. </p>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00305">305</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>Referenced by <a class="el" href="TaskCore_8cpp_source.html#l00147">RTT::base::TaskCore::exception()</a>, and <a class="el" href="TaskCore_8cpp_source.html#l00203">RTT::base::TaskCore::stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b2cda802da9670204fc3be88e9e4ccf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskCore::trigger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke this method to <em>trigger</em> the thread of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> to execute its <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> and the <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a940714024a53ffb17de749f3f909527d" title="Invoke this method to execute the ExecutionEngine and the update() method. ">update()</a> method. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if this-&gt;<a class="el" href="classRTT_1_1base_1_1TaskCore.html#ac18ebf7b987f142c8dad4413be2bbd30" title="Get a pointer to the ExecutionEngine of this Task. ">engine()</a>-&gt;getActivity()-&gt;<a class="el" href="classRTT_1_1base_1_1TaskCore.html#a9b2cda802da9670204fc3be88e9e4ccf" title="Invoke this method to trigger the thread of this TaskContext to execute its ExecutionEngine and the u...">trigger()</a> == false </td></tr>
    <tr><td class="paramname">true</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00088">88</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, <a class="el" href="RunnableInterface_8hpp_source.html#l00175">RTT::base::RunnableInterface::getActivity()</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a99f8cbfa2c5022c575e4b5e404cb02c8">RTT::base::ActivityInterface::timeout()</a>.</p>

<p>Referenced by <a class="el" href="DataFlowInterface_8cpp_source.html#l00135">RTT::DataFlowInterface::addLocalEventPort()</a>, and <a class="el" href="TaskCore_8cpp_source.html#l00180">RTT::base::TaskCore::start()</a>.</p>

</div>
</div>
<a class="anchor" id="a940714024a53ffb17de749f3f909527d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::TaskCore::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke this method to <em>execute</em> the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> and the <a class="el" href="classRTT_1_1base_1_1TaskCore.html#a940714024a53ffb17de749f3f909527d" title="Invoke this method to execute the ExecutionEngine and the update() method. ">update()</a> method. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if this-&gt;<a class="el" href="classRTT_1_1base_1_1TaskCore.html#ac18ebf7b987f142c8dad4413be2bbd30" title="Get a pointer to the ExecutionEngine of this Task. ">engine()</a>-&gt;getActivity()-&gt;execute() == false </td></tr>
    <tr><td class="paramname">true</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00083">83</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00306">RTT::base::TaskCore::engine()</a>, <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#ae490cda9ee1ef6ed7a42f8725d3af3dd">RTT::base::ActivityInterface::execute()</a>, and <a class="el" href="RunnableInterface_8hpp_source.html#l00175">RTT::base::RunnableInterface::getActivity()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b16151ed99062bca250ddfe667a3604"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::TaskCore::updateHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function where the user must insert his 'application' code. </p>
<p>When the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>'s <a class="el" href="classRTT_1_1Activity.html" title="An Activity executes a RunnableInterface object in a (periodic) thread. ">Activity</a> is a periodic, this function is called by the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> in each periodic step after all messages are processed. When it is executed by a non periodic activity, this function is called after a message is received and executed. It should not loop forever, since no commands or events are processed when this function executes. The default implementation is an empty function. </p>

<p>Definition at line <a class="el" href="TaskCore_8cpp_source.html#l00293">293</a> of file <a class="el" href="TaskCore_8cpp_source.html">TaskCore.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a41fd49b2f57fcc037366e49d6c18e6e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RTT::base::TaskCore::mCycleCounter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each update cycle, this counter increments by one. </p>
<p>You can use this to check across (callback) functions if we're still in the same cycle or in a new one. </p>

<p>Definition at line <a class="el" href="TaskCore_8hpp_source.html#l00476">476</a> of file <a class="el" href="TaskCore_8hpp_source.html">TaskCore.hpp</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00386">RTT::ExecutionEngine::work()</a>.</p>

</div>
</div>
<a class="anchor" id="afb54764824414d6de6c7255b826b51f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classRTT_1_1base_1_1PortInterface.html">base::PortInterface</a>*&gt; RTT::corba::TaskContextProxy::port_proxies</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="interfaceRTT_1_1corba_1_1CDataFlowInterface.html" title="An interface to access the dataflow of a CControlTask object. ">CDataFlowInterface</a> does not delete ports automatically, because they can then be defined as members of the <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> classes. </p>
<p>We must therefore delete in the proxy destructor the ones we are adding through synchronization </p>

<p>Definition at line <a class="el" href="TaskContextProxy_8hpp_source.html#l00114">114</a> of file <a class="el" href="TaskContextProxy_8hpp_source.html">TaskContextProxy.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rtt/transports/corba/<a class="el" href="TaskContextProxy_8hpp_source.html">TaskContextProxy.hpp</a></li>
<li>rtt/transports/corba/<a class="el" href="TaskContextProxy_8cpp_source.html">TaskContextProxy.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 28 2017 13:43:22 for Orocos Real-Time Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
