<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Orocos Real-Time Toolkit: RTT::types Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a></li><li class="navelem"><a class="el" href="namespaceRTT_1_1types.html">types</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RTT::types Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes for typekits for describing and handling user data types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1BinaryOperator.html">BinaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator which reads a two DataSources and returns a modified result.  <a href="classRTT_1_1types_1_1BinaryOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1BoolTypeInfo.html">BoolTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write boolean as 'true' or 'false'.  <a href="structRTT_1_1types_1_1BoolTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1BoostArrayTypeInfo.html">BoostArrayTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for data types that are of type boost::array&lt;U,int&gt;.  <a href="classRTT_1_1types_1_1BoostArrayTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1carray.html">carray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a C array such that we can return a C array from a DataSource.  <a href="classRTT_1_1types_1_1carray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1CArrayTypeInfo.html">CArrayTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for data types that are C-style arrays.  <a href="classRTT_1_1types_1_1CArrayTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1CompositionFactory.html">CompositionFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory for composing/decomposing and converting types to a form suitable for persistent storage, such as an XML file.  <a href="classRTT_1_1types_1_1CompositionFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1EmptySendHandle.html">EmptySendHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a placeholder for scripting purposes.  <a href="structRTT_1_1types_1_1EmptySendHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1EmptyTypeInfo.html">EmptyTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty implementation of <a class="el" href="classRTT_1_1types_1_1TypeInfo.html" title="A class for representing a user type, and which can build instances of that type. ...">TypeInfo</a> interface.  <a href="classRTT_1_1types_1_1EmptyTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1EnumTypeInfo.html">EnumTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for Enum types for which they are convertible to int.  <a href="structRTT_1_1types_1_1EnumTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1GlobalsRepository.html">GlobalsRepository</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classRTT_1_1ConfigurationInterface.html" title="A class for keeping track of Attribute, Constant and Property objects of a TaskContext. ">RTT::ConfigurationInterface</a> for holding global variables.  <a href="classRTT_1_1types_1_1GlobalsRepository.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1OperatorRepository.html">OperatorRepository</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds on upon construction all expression operators known to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a>.  <a href="classRTT_1_1types_1_1OperatorRepository.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveSequenceTypeInfo.html">PrimitiveSequenceTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">New-style <a class="el" href="classRTT_1_1types_1_1SequenceTypeInfo.html" title="Old-style SequenceTypeInfo which offers type info for sequences which can be sent over flow ports...">SequenceTypeInfo</a> which offers type info for sequences which can <b>NOT</b> be sent over flow ports.  <a href="classRTT_1_1types_1_1PrimitiveSequenceTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1PrimitiveTypeInfo.html">PrimitiveTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class allows primitive types, which are not sent over ports, to be added to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a>.  <a href="classRTT_1_1types_1_1PrimitiveTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1RealTimeTypekitPlugin.html">RealTimeTypekitPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface defines the types of the realTime package.  <a href="classRTT_1_1types_1_1RealTimeTypekitPlugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1RTStringTypeInfo.html">RTStringTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard string specialisation that removes decomposition.  <a href="structRTT_1_1types_1_1RTStringTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1sequence__constructor__datasource.html">sequence_constructor_datasource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper DataSource for constructing sequences with a variable number of parameters.  <a href="structRTT_1_1types_1_1sequence__constructor__datasource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1sequence__ctor.html">sequence_ctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence constructor which takes the number of elements in the sequence.  <a href="structRTT_1_1types_1_1sequence__ctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1sequence__ctor2.html">sequence_ctor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sequence from the number of elements and a prototype element for these elements.  <a href="structRTT_1_1types_1_1sequence__ctor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1sequence__varargs__ctor.html">sequence_varargs_ctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See NArityDataSource which requires a function object like this one.  <a href="structRTT_1_1types_1_1sequence__varargs__ctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1SequenceBuilder.html">SequenceBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an sequence with <em>n</em> elements, which are given upon construction time.  <a href="structRTT_1_1types_1_1SequenceBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1SequenceTypeInfo.html">SequenceTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Old-style <a class="el" href="classRTT_1_1types_1_1SequenceTypeInfo.html" title="Old-style SequenceTypeInfo which offers type info for sequences which can be sent over flow ports...">SequenceTypeInfo</a> which offers type info for sequences which can be sent over flow ports.  <a href="classRTT_1_1types_1_1SequenceTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1SequenceTypeInfoBase.html">SequenceTypeInfoBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for data types that are C++ STL Sequences with operator[], size() and capacity() methods.  <a href="classRTT_1_1types_1_1SequenceTypeInfoBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1StdStringTypeInfo.html">StdStringTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard string specialisation that removes decomposition.  <a href="structRTT_1_1types_1_1StdStringTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1StdTypeInfo.html">StdTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for standard C types or structs of which no introspection is required.  <a href="structRTT_1_1types_1_1StdTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1StdVectorTemplateTypeInfo.html">StdVectorTemplateTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for std::vector&lt;T&gt; typekits, providing a alternative demarshalling function for properties and optionally ostream printing.  <a href="structRTT_1_1types_1_1StdVectorTemplateTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1StdVectorTypeInfo.html">StdVectorTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class tells <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> how to handle std::vector&lt;double&gt;.  <a href="structRTT_1_1types_1_1StdVectorTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1StructTypeInfo.html">StructTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Information for data types that are structs, ie all user data types fall in this category.  <a href="classRTT_1_1types_1_1StructTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1TemplateConstructor.html">TemplateConstructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor classes allow to define type constructors or type conversions (convert type B from type A).  <a href="structRTT_1_1types_1_1TemplateConstructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TemplateTypeInfo.html">TemplateTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class allows user types to be used in all <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> primitives.  <a href="classRTT_1_1types_1_1TemplateTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TransportPlugin.html">TransportPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which registers <a class="el" href="classRTT_1_1types_1_1TypeTransporter.html" title="This interface defines the function a transport protocol must support in order to allow Orocos compon...">TypeTransporter</a> instances to types.  <a href="classRTT_1_1types_1_1TransportPlugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1type__discovery.html">type_discovery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This archive is capable of decomposing objects of serialization level 1 and 2 into part data sources.  <a href="classRTT_1_1types_1_1type__discovery.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1TypeConstructor.html">TypeConstructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface describes how constructors work.  <a href="structRTT_1_1types_1_1TypeConstructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfo.html">TypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for representing a user type, and which can build instances of that type.  <a href="classRTT_1_1types_1_1TypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfoGenerator.html">TypeInfoGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All generator classes inherit from this object in order to allow them to be added to the <a class="el" href="classRTT_1_1types_1_1TypeInfoRepository.html" title="This class contains all known types to Orocos. ">TypeInfoRepository</a>.  <a href="classRTT_1_1types_1_1TypeInfoGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1types_1_1TypeInfoName.html">TypeInfoName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper class allows only type names to be added to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a>.  <a href="structRTT_1_1types_1_1TypeInfoName.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeInfoRepository.html">TypeInfoRepository</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all known types to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a>.  <a href="classRTT_1_1types_1_1TypeInfoRepository.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypekitPlugin.html">TypekitPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface defines how additional typekits are loaded into <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a>.  <a href="classRTT_1_1types_1_1TypekitPlugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypekitRepository.html">TypekitRepository</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows the <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute. ">RTT</a> to be extended with additional typekits (<a class="el" href="classRTT_1_1types_1_1TypekitPlugin.html" title="This interface defines how additional typekits are loaded into Orocos. ">TypekitPlugin</a>), such as for kinematics or any library foreign to <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a>.  <a href="classRTT_1_1types_1_1TypekitRepository.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeMarshaller.html">TypeMarshaller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objects implementing this interface have the capability to convert data sources to and from a binary representation.  <a href="classRTT_1_1types_1_1TypeMarshaller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1TypeTransporter.html">TypeTransporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface defines the function a transport protocol must support in order to allow <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> components to remotely communicate one data type.  <a href="classRTT_1_1types_1_1TypeTransporter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1UnaryOp.html">UnaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1types_1_1UnaryOperator.html" title="An operator which reads a single internal::DataSource and returns a modified result. ">UnaryOperator</a> contains information on some unary operator that operates on one arg of a certain type.  <a href="classRTT_1_1types_1_1UnaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1UnaryOperator.html">UnaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator which reads a single <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">internal::DataSource</a> and returns a modified result.  <a href="classRTT_1_1types_1_1UnaryOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1types_1_1ValueFactory.html">ValueFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all value objects of a certain type.  <a href="classRTT_1_1types_1_1ValueFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaafb4d61a944009c8e3b6a21c1992f5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaafb4d61a944009c8e3b6a21c1992f5a"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classRTT_1_1types_1_1CompositionFactory.html">CompositionFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CompositionFactoryPtr</b></td></tr>
<tr class="separator:aaafb4d61a944009c8e3b6a21c1992f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71f0d5ae52d7d4f262f10093c35888f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af71f0d5ae52d7d4f262f10093c35888f"></a>
typedef boost::shared_ptr&lt; MemberFactory &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MemberFactoryPtr</b></td></tr>
<tr class="separator:af71f0d5ae52d7d4f262f10093c35888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a64a1c7afcaf99c7326329ae230ea2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98a64a1c7afcaf99c7326329ae230ea2"></a>
typedef boost::shared_ptr&lt; StreamFactory &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>StreamFactoryPtr</b></td></tr>
<tr class="separator:a98a64a1c7afcaf99c7326329ae230ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7162f5b4c9392fb4179cf0da9e16927"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7162f5b4c9392fb4179cf0da9e16927"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classRTT_1_1internal_1_1ConnFactory.html">internal::ConnFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConnFactoryPtr</b></td></tr>
<tr class="separator:ac7162f5b4c9392fb4179cf0da9e16927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888315813e0c2cd28aabeb08713f40cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a888315813e0c2cd28aabeb08713f40cd"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classRTT_1_1types_1_1ValueFactory.html">ValueFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ValueFactoryPtr</b></td></tr>
<tr class="separator:a888315813e0c2cd28aabeb08713f40cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae8f1d0bb04ade3eb7f1d1d833fb0e46b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8f1d0bb04ade3eb7f1d1d833fb0e46b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadStdTypes</b> (TypeInfoRepository::shared_ptr ti)</td></tr>
<tr class="separator:ae8f1d0bb04ade3eb7f1d1d833fb0e46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a149313ec66a8b90c9d0fd89646812"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7a149313ec66a8b90c9d0fd89646812"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadOrocosTypes</b> (TypeInfoRepository::shared_ptr ti)</td></tr>
<tr class="separator:ac7a149313ec66a8b90c9d0fd89646812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392a189a6f0424bf29e29d16f9ca187e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a392a189a6f0424bf29e29d16f9ca187e"></a>
RTT_API OperatorRepository::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a392a189a6f0424bf29e29d16f9ca187e">operators</a> ()</td></tr>
<tr class="memdesc:a392a189a6f0424bf29e29d16f9ca187e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This global function provides the short notation for <a class="el" href="classRTT_1_1types_1_1OperatorRepository.html#a24b7a406c7b5333ecb769a2104ff3587" title="Returns a shared pointer to the singleton of this class. ">OperatorRepository::Instance()</a> <br /></td></tr>
<tr class="separator:a392a189a6f0424bf29e29d16f9ca187e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c2ab9b5a306d8927e62625e3418bdd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8c2ab9b5a306d8927e62625e3418bdd"></a>
template&lt;typename function &gt; </td></tr>
<tr class="memitem:ae8c2ab9b5a306d8927e62625e3418bdd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1types_1_1UnaryOperator.html">UnaryOperator</a>&lt; function &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#ae8c2ab9b5a306d8927e62625e3418bdd">newUnaryOperator</a> (const char *op, function f)</td></tr>
<tr class="memdesc:ae8c2ab9b5a306d8927e62625e3418bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to create a new <a class="el" href="classRTT_1_1types_1_1UnaryOperator.html" title="An operator which reads a single internal::DataSource and returns a modified result. ">UnaryOperator</a> <br /></td></tr>
<tr class="separator:ae8c2ab9b5a306d8927e62625e3418bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad425f739fe840a86629938c80eff875e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad425f739fe840a86629938c80eff875e"></a>
template&lt;typename function &gt; </td></tr>
<tr class="memitem:ad425f739fe840a86629938c80eff875e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1types_1_1BinaryOperator.html">BinaryOperator</a>&lt; function &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#ad425f739fe840a86629938c80eff875e">newBinaryOperator</a> (const char *op, function f)</td></tr>
<tr class="memdesc:ad425f739fe840a86629938c80eff875e"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to create a new <a class="el" href="classRTT_1_1types_1_1BinaryOperator.html" title="An operator which reads a two DataSources and returns a modified result. ">BinaryOperator</a> <br /></td></tr>
<tr class="separator:ad425f739fe840a86629938c80eff875e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5b03e098a7a90c431e885076ab3dd3"><td class="memItemLeft" align="right" valign="top">bool RTT_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a0a5b03e098a7a90c431e885076ab3dd3">composePropertyBag</a> (<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> const &amp;sourcebag, <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;target)</td></tr>
<tr class="memdesc:a0a5b03e098a7a90c431e885076ab3dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the type composition to compose all typed properties from a property bag.  <a href="#a0a5b03e098a7a90c431e885076ab3dd3">More...</a><br /></td></tr>
<tr class="separator:a0a5b03e098a7a90c431e885076ab3dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea865bc70e02568b615dac086b00cc32"><td class="memItemLeft" align="right" valign="top">bool RTT_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#aea865bc70e02568b615dac086b00cc32">decomposePropertyBag</a> (<a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> const &amp;sourcebag, <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;target)</td></tr>
<tr class="memdesc:aea865bc70e02568b615dac086b00cc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of <a class="el" href="namespaceRTT_1_1types.html#a0a5b03e098a7a90c431e885076ab3dd3" title="Uses the type composition to compose all typed properties from a property bag. ">RTT::types::composePropertyBag()</a>.  <a href="#aea865bc70e02568b615dac086b00cc32">More...</a><br /></td></tr>
<tr class="separator:aea865bc70e02568b615dac086b00cc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23773014261904a984359984a28b13a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a23773014261904a984359984a28b13a8">propertyDecomposition</a> (<a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> *source, <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;targetbag, bool recurse=true)</td></tr>
<tr class="memdesc:a23773014261904a984359984a28b13a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the type decomposition to decompose a property into a property bag that refers to all its parts.  <a href="#a23773014261904a984359984a28b13a8">More...</a><br /></td></tr>
<tr class="separator:a23773014261904a984359984a28b13a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7883d9a1fe2ac6f3599641199e05a46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#ab7883d9a1fe2ac6f3599641199e05a46">typeDecomposition</a> (<a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a> source, <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;targetbag, bool recurse=true)</td></tr>
<tr class="memdesc:ab7883d9a1fe2ac6f3599641199e05a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="namespaceRTT_1_1types.html#a23773014261904a984359984a28b13a8" title="Uses the type decomposition to decompose a property into a property bag that refers to all its parts...">RTT::types::propertyDecomposition()</a>, but takes a DataSourceBase as source.  <a href="#ab7883d9a1fe2ac6f3599641199e05a46">More...</a><br /></td></tr>
<tr class="separator:ab7883d9a1fe2ac6f3599641199e05a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a86a2c5e924f1eb273d96e442e2e83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#ad0a86a2c5e924f1eb273d96e442e2e83">get_container_item</a> (std::vector&lt; bool &gt; &amp;cont, int index)</td></tr>
<tr class="memdesc:ad0a86a2c5e924f1eb273d96e442e2e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for vector&lt;bool&gt;, we don't return references to bits aka std::_Bit_reference.  <a href="#ad0a86a2c5e924f1eb273d96e442e2e83">More...</a><br /></td></tr>
<tr class="separator:ad0a86a2c5e924f1eb273d96e442e2e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785b687824230dec80c3bbc384143bba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a785b687824230dec80c3bbc384143bba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_container_item_copy</b> (const std::vector&lt; bool &gt; &amp;cont, int index)</td></tr>
<tr class="separator:a785b687824230dec80c3bbc384143bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764774ce659b7a55217088201a4e30ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a764774ce659b7a55217088201a4e30ee"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a764774ce659b7a55217088201a4e30ee">get_capacity</a> (T const &amp;cont)</td></tr>
<tr class="memdesc:a764774ce659b7a55217088201a4e30ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of an STL container which has the capacity() member function.  <a href="#a764774ce659b7a55217088201a4e30ee">More...</a><br /></td></tr>
<tr class="separator:a764774ce659b7a55217088201a4e30ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cee59bbf5a555f9806021ac2f080d9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a08cee59bbf5a555f9806021ac2f080d9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a08cee59bbf5a555f9806021ac2f080d9">get_size</a> (T const &amp;cont)</td></tr>
<tr class="memdesc:a08cee59bbf5a555f9806021ac2f080d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of an STL container which has the size() member function.  <a href="#a08cee59bbf5a555f9806021ac2f080d9">More...</a><br /></td></tr>
<tr class="separator:a08cee59bbf5a555f9806021ac2f080d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfdf5148ece54de7361bb2a9fb1814f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0bfdf5148ece54de7361bb2a9fb1814f"><td class="memTemplItemLeft" align="right" valign="top">T::reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a0bfdf5148ece54de7361bb2a9fb1814f">get_container_item</a> (T &amp;cont, int index)</td></tr>
<tr class="memdesc:a0bfdf5148ece54de7361bb2a9fb1814f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to one item in an STL container.  <a href="#a0bfdf5148ece54de7361bb2a9fb1814f">More...</a><br /></td></tr>
<tr class="separator:a0bfdf5148ece54de7361bb2a9fb1814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1beb76f0d339bcfde07be00ae09b8c5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad1beb76f0d339bcfde07be00ae09b8c5"><td class="memTemplItemLeft" align="right" valign="top">T::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#ad1beb76f0d339bcfde07be00ae09b8c5">get_container_item_copy</a> (const T &amp;cont, int index)</td></tr>
<tr class="memdesc:ad1beb76f0d339bcfde07be00ae09b8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy to one item in an STL container.  <a href="#ad1beb76f0d339bcfde07be00ae09b8c5">More...</a><br /></td></tr>
<tr class="separator:ad1beb76f0d339bcfde07be00ae09b8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8a3cdeee25589b4283dc60a28a9b95"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a2c8a3cdeee25589b4283dc60a28a9b95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structRTT_1_1types_1_1TypeConstructor.html">TypeConstructor</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a2c8a3cdeee25589b4283dc60a28a9b95">newConstructor</a> (Function *foo, bool automatic=false)</td></tr>
<tr class="memdesc:a2c8a3cdeee25589b4283dc60a28a9b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Constructor.  <a href="#a2c8a3cdeee25589b4283dc60a28a9b95">More...</a><br /></td></tr>
<tr class="separator:a2c8a3cdeee25589b4283dc60a28a9b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201408cef52456f3d237fd144247a50a"><td class="memTemplParams" colspan="2">template&lt;class Object &gt; </td></tr>
<tr class="memitem:a201408cef52456f3d237fd144247a50a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structRTT_1_1types_1_1TypeConstructor.html">TypeConstructor</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a201408cef52456f3d237fd144247a50a">newConstructor</a> (Object obj, bool automatic=false)</td></tr>
<tr class="memdesc:a201408cef52456f3d237fd144247a50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Constructor.  <a href="#a201408cef52456f3d237fd144247a50a">More...</a><br /></td></tr>
<tr class="separator:a201408cef52456f3d237fd144247a50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d379bb9503d45c1a13c5e8597dd11d"><td class="memItemLeft" align="right" valign="top">TypeInfoRepository::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1types.html#a22d379bb9503d45c1a13c5e8597dd11d">Types</a> ()</td></tr>
<tr class="memdesc:a22d379bb9503d45c1a13c5e8597dd11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a pointer to the global type system.  <a href="#a22d379bb9503d45c1a13c5e8597dd11d">More...</a><br /></td></tr>
<tr class="separator:a22d379bb9503d45c1a13c5e8597dd11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad340d7d9777db3e54c199acddb42c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ad340d7d9777db3e54c199acddb42c0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_EatSpace</b> (std::istream &amp;is, int *countp)</td></tr>
<tr class="separator:a4ad340d7d9777db3e54c199acddb42c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0556108c147547d91a9cad3eeb6fb90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0556108c147547d91a9cad3eeb6fb90"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Eat</b> (std::istream &amp;is, int delim)</td></tr>
<tr class="separator:ae0556108c147547d91a9cad3eeb6fb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b20e62280db14403caff60f77b5da5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02b20e62280db14403caff60f77b5da5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>EatEnd</b> (std::istream &amp;is, int delim)</td></tr>
<tr class="separator:a02b20e62280db14403caff60f77b5da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d821070976d7cd78237e9301f8965a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77d821070976d7cd78237e9301f8965a"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const std::vector&lt; double &gt; &amp;v)</td></tr>
<tr class="separator:a77d821070976d7cd78237e9301f8965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57130d900ef761e3d01e042cb00d643b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57130d900ef761e3d01e042cb00d643b"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;os, std::vector&lt; double &gt; &amp;v)</td></tr>
<tr class="separator:a57130d900ef761e3d01e042cb00d643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4319f86baebf190e140d545b7bfb8c65"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4319f86baebf190e140d545b7bfb8c65"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4319f86baebf190e140d545b7bfb8c65"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>composeTemplateProperty</b> (const <a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;bag, T &amp;result)</td></tr>
<tr class="separator:a4319f86baebf190e140d545b7bfb8c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Classes for typekits for describing and handling user data types. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0a5b03e098a7a90c431e885076ab3dd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::types::composePropertyBag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> const &amp;&#160;</td>
          <td class="paramname"><em>sourcebag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the type composition to compose all typed properties from a property bag. </p>
<p>For each <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties. ">PropertyBag</a> found with a type not equal to '<a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties. ">PropertyBag</a>', it will use the type's <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#affa99b5b0fa9f9a4b252b42a422473e2" title="Compose a type (target) from a DataSourceBase (source) containing its members. ">TypeInfo::composeType</a> function and return that in target if it generates a <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourcebag</td><td>Contains a <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties. ">PropertyBag</a> to be composed into a known type. </td></tr>
    <tr><td class="paramname">target</td><td>The target type to compose the source bag into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all typed PropertyBags in sourcebag could be composed to a user type, false if one or more compositions failed. </dd></dl>

<p>Definition at line <a class="el" href="PropertyComposition_8cpp_source.html#l00010">10</a> of file <a class="el" href="PropertyComposition_8cpp_source.html">PropertyComposition.cpp</a>.</p>

<p>References <a class="el" href="TypeInfo_8hpp_source.html#l00214">RTT::types::TypeInfo::buildProperty()</a>, <a class="el" href="PropertyComposition_8cpp_source.html#l00010">composePropertyBag()</a>, <a class="el" href="TypeInfo_8hpp_source.html#l00386">RTT::types::TypeInfo::composeType()</a>, <a class="el" href="PropertyBag_8hpp_source.html#l00219">RTT::PropertyBag::empty()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#aef1f9e802faddb20dc36ccb6a737869c">RTT::base::PropertyBase::getDataSource()</a>, <a class="el" href="Property_8hpp_source.html#l00393">RTT::Property&lt; T &gt;::getDataSource()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00100">RTT::base::PropertyBase::getDescription()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00088">RTT::base::PropertyBase::getName()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#a1c8554af80cc98c0d4f5ca4c9a2cefeb">RTT::base::PropertyBase::getType()</a>, <a class="el" href="PropertyBag_8cpp_source.html#l00083">RTT::PropertyBag::ownProperty()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00114">RTT::base::PropertyBase::ready()</a>, <a class="el" href="Types_8cpp_source.html#l00048">Types()</a>, and <a class="el" href="Property_8hpp_source.html#l00277">RTT::Property&lt; T &gt;::value()</a>.</p>

<p>Referenced by <a class="el" href="PropertyComposition_8cpp_source.html#l00010">composePropertyBag()</a>, <a class="el" href="BoostArrayTypeInfo_8hpp_source.html#l00154">RTT::types::BoostArrayTypeInfo&lt; T, has_ostream &gt;::composeType()</a>, <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00165">RTT::types::SequenceTypeInfoBase&lt; std::vector&lt; double &gt; &gt;::composeType()</a>, <a class="el" href="CArrayTypeInfo_8hpp_source.html#l00176">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;::composeType()</a>, <a class="el" href="PropertyLoader_8cpp_source.html#l00064">RTT::marsh::PropertyLoader::load()</a>, and <a class="el" href="PropertyLoader_8cpp_source.html#l00197">RTT::marsh::PropertyLoader::store()</a>.</p>

</div>
</div>
<a class="anchor" id="aea865bc70e02568b615dac086b00cc32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::types::decomposePropertyBag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> const &amp;&#160;</td>
          <td class="paramname"><em>sourcebag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse of <a class="el" href="namespaceRTT_1_1types.html#a0a5b03e098a7a90c431e885076ab3dd3" title="Uses the type composition to compose all typed properties from a property bag. ">RTT::types::composePropertyBag()</a>. </p>
<p>This function effectively replaces the property introspection mechanism for decomposition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourcebag</td><td>The bag from which to compose the type. </td></tr>
    <tr><td class="paramname">target</td><td>Contains a C++ type to be composed into a hierarchy of properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>RTT::types::propertyComposition </dd></dl>

<p>Definition at line <a class="el" href="PropertyComposition_8cpp_source.html#l00060">60</a> of file <a class="el" href="PropertyComposition_8cpp_source.html">PropertyComposition.cpp</a>.</p>

<p>References <a class="el" href="TypeInfo_8hpp_source.html#l00214">RTT::types::TypeInfo::buildProperty()</a>, <a class="el" href="PropertyComposition_8cpp_source.html#l00060">decomposePropertyBag()</a>, <a class="el" href="PropertyBag_8hpp_source.html#l00219">RTT::PropertyBag::empty()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00100">RTT::base::PropertyBase::getDescription()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00088">RTT::base::PropertyBase::getName()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#a1c8554af80cc98c0d4f5ca4c9a2cefeb">RTT::base::PropertyBase::getType()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#afaf365d2b2a93f2d602d82af87ac233f">RTT::base::PropertyBase::getTypeInfo()</a>, <a class="el" href="DataSource_8inl_source.html#l00066">RTT::internal::DataSource&lt; T &gt;::narrow()</a>, <a class="el" href="PropertyBag_8cpp_source.html#l00083">RTT::PropertyBag::ownProperty()</a>, <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">propertyDecomposition()</a>, <a class="el" href="PropertyBase_8hpp_source.html#l00114">RTT::base::PropertyBase::ready()</a>, <a class="el" href="classRTT_1_1internal_1_1DataSource.html#a7c10d4f18a3e7de9bbd534eb232d850e">RTT::internal::DataSource&lt; T &gt;::rvalue()</a>, <a class="el" href="Property_8hpp_source.html#l00285">RTT::Property&lt; T &gt;::rvalue()</a>, and <a class="el" href="Property_8hpp_source.html#l00277">RTT::Property&lt; T &gt;::value()</a>.</p>

<p>Referenced by <a class="el" href="PropertyComposition_8cpp_source.html#l00060">decomposePropertyBag()</a>.</p>

</div>
</div>
<a class="anchor" id="a764774ce659b7a55217088201a4e30ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int RTT::types::get_capacity </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the capacity of an STL container which has the capacity() member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>A const ref to an STL container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>its capacity. </dd></dl>

<p>Definition at line <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00061">61</a> of file <a class="el" href="SequenceTypeInfoBase_8hpp_source.html">SequenceTypeInfoBase.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0a86a2c5e924f1eb273d96e442e2e83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::types::get_container_item </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialisation for vector&lt;bool&gt;, we don't return references to bits aka std::_Bit_reference. </p>
<p>vector&lt;bool&gt; is an outlier and should not be used. Use vector&lt;int&gt; or vector&lt;char&gt; instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Is a vector&lt;bool&gt; </td></tr>
    <tr><td class="paramname">index</td><td>The item to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the value at position <em>index</em>. <b>not</b> a reference ! </dd></dl>

<p>Definition at line <a class="el" href="SequenceTypeInfoBase_8cpp_source.html#l00045">45</a> of file <a class="el" href="SequenceTypeInfoBase_8cpp_source.html">SequenceTypeInfoBase.cpp</a>.</p>

<p>Referenced by <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00100">get_container_item_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a0bfdf5148ece54de7361bb2a9fb1814f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T::reference RTT::types::get_container_item </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to one item in an STL container. </p>
<dl class="section note"><dt>Note</dt><dd>vector&lt;bool&gt; is not supported, since it's not an STL container. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The container to access </td></tr>
    <tr><td class="paramname">index</td><td>The item to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to item <em>index</em> </dd></dl>

<p>Definition at line <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00085">85</a> of file <a class="el" href="SequenceTypeInfoBase_8hpp_source.html">SequenceTypeInfoBase.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1beb76f0d339bcfde07be00ae09b8c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T::value_type RTT::types::get_container_item_copy </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy to one item in an STL container. </p>
<dl class="section note"><dt>Note</dt><dd>vector&lt;bool&gt; is not supported, since it's not an STL container. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The container to access </td></tr>
    <tr><td class="paramname">index</td><td>The item to extract from the sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of item <em>index</em> </dd></dl>

<p>Definition at line <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00100">100</a> of file <a class="el" href="SequenceTypeInfoBase_8hpp_source.html">SequenceTypeInfoBase.hpp</a>.</p>

<p>References <a class="el" href="SequenceTypeInfoBase_8cpp_source.html#l00045">get_container_item()</a>.</p>

</div>
</div>
<a class="anchor" id="a08cee59bbf5a555f9806021ac2f080d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int RTT::types::get_size </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of an STL container which has the size() member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>A const ref to an STL container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>its size. </dd></dl>

<p>Definition at line <a class="el" href="SequenceTypeInfoBase_8hpp_source.html#l00072">72</a> of file <a class="el" href="SequenceTypeInfoBase_8hpp_source.html">SequenceTypeInfoBase.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c8a3cdeee25589b4283dc60a28a9b95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRTT_1_1types_1_1TypeConstructor.html">TypeConstructor</a>* RTT::types::newConstructor </td>
          <td>(</td>
          <td class="paramtype">Function *&#160;</td>
          <td class="paramname"><em>foo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automatic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foo</td><td>A pointer to the 'C' function which creates an object. </td></tr>
    <tr><td class="paramname">automatic</td><td>Set to true to allow automatic conversion (without warning) to this type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Constructor object suitable for the type system. </dd></dl>

<p>Definition at line <a class="el" href="TemplateConstructor_8hpp_source.html#l00122">122</a> of file <a class="el" href="TemplateConstructor_8hpp_source.html">TemplateConstructor.hpp</a>.</p>

<p>Referenced by <a class="el" href="EnumTypeInfo_8hpp_source.html#l00077">RTT::types::EnumTypeInfo&lt; T &gt;::installTypeInfoObject()</a>, and <a class="el" href="RealTimeTypekitConstructors_8cpp_source.html#l00217">RTT::types::RealTimeTypekitPlugin::loadConstructors()</a>.</p>

</div>
</div>
<a class="anchor" id="a201408cef52456f3d237fd144247a50a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRTT_1_1types_1_1TypeConstructor.html">TypeConstructor</a>* RTT::types::newConstructor </td>
          <td>(</td>
          <td class="paramtype">Object&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automatic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>A function object which has operator(). </td></tr>
    <tr><td class="paramname">automatic</td><td>Set to true to allow automatic conversion (without warning) to this type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Constructor object suitable for the type system. </dd></dl>

<p>Definition at line <a class="el" href="TemplateConstructor_8hpp_source.html#l00135">135</a> of file <a class="el" href="TemplateConstructor_8hpp_source.html">TemplateConstructor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23773014261904a984359984a28b13a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT_API RTT::types::propertyDecomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1PropertyBase.html">base::PropertyBase</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;&#160;</td>
          <td class="paramname"><em>targetbag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the type decomposition to decompose a property into a property bag that refers to all its parts. </p>
<p>It will first try to use the user's <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a83cabdced96572bdb60e737e975ab1da" title="Specialize this function to return an alternate type which represents this one in a compatible way...">TypeInfo::decomposeType</a> function and return that in targetbag if it generates a <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties. ">PropertyBag</a>. If it generated something else than a <a class="el" href="classRTT_1_1PropertyBag.html" title="A container for holding references to properties. ">PropertyBag</a>, this function returns false. If decomposeType did not return anything, it will try the <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#aae55b906cd6079aa50c78bc30a019dd7" title="Returns a member of a given data source struct identified by its name. ">TypeInfo::getMember()</a> approach to decompose source into the targetbag. If no members are returned, this function fails.</p>
<p>In case the source type info supports it, each modification of a part in the <em>targetbag</em> will modify <em>source</em> too. This is so for typekits using the boost::serialization functions in combination with <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#aae55b906cd6079aa50c78bc30a019dd7" title="Returns a member of a given data source struct identified by its name. ">TypeInfo::getMember()</a>. In case the type decompositions were written manually using <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#a83cabdced96572bdb60e737e975ab1da" title="Specialize this function to return an alternate type which represents this one in a compatible way...">TypeInfo::decomposeType()</a>, this relation can no longer be guaranteed, and a composition step using <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#affa99b5b0fa9f9a4b252b42a422473e2" title="Compose a type (target) from a DataSourceBase (source) containing its members. ">TypeInfo::composeType()</a> of the same type must be tried to update <em>source</em> with the modifications in <em>targetbag</em>.</p>
<p>For the <a class="el" href="classRTT_1_1types_1_1TypeInfo.html#aae55b906cd6079aa50c78bc30a019dd7" title="Returns a member of a given data source struct identified by its name. ">TypeInfo::getMember()</a> method: This function can only work if every part of the source is known by the <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute. ">RTT</a> type system. Only the parts of source that are assignable will be decomposed. The read-only parts will be silently omitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Contains a C++ type to be decomposed into a hierarchy of properties. </td></tr>
    <tr><td class="paramname">targetbag</td><td>The bag in which to place the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">63</a> of file <a class="el" href="PropertyDecomposition_8cpp_source.html">PropertyDecomposition.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#aef1f9e802faddb20dc36ccb6a737869c">RTT::base::PropertyBase::getDataSource()</a>, <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">propertyDecomposition()</a>, and <a class="el" href="PropertyDecomposition_8cpp_source.html#l00073">typeDecomposition()</a>.</p>

<p>Referenced by <a class="el" href="PropertyComposition_8cpp_source.html#l00060">decomposePropertyBag()</a>, <a class="el" href="PropertyBagVisitor_8cpp_source.html#l00049">RTT::base::PropertyBagVisitor::introspectAndDecompose()</a>, <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">propertyDecomposition()</a>, and <a class="el" href="PropertyDecomposition_8cpp_source.html#l00073">typeDecomposition()</a>.</p>

</div>
</div>
<a class="anchor" id="ab7883d9a1fe2ac6f3599641199e05a46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT_API RTT::types::typeDecomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DataSourceBase.html#af764490461a162f4a62c63770535fb7b">base::DataSourceBase::shared_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTT_1_1PropertyBag.html">PropertyBag</a> &amp;&#160;</td>
          <td class="paramname"><em>targetbag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="namespaceRTT_1_1types.html#a23773014261904a984359984a28b13a8" title="Uses the type decomposition to decompose a property into a property bag that refers to all its parts...">RTT::types::propertyDecomposition()</a>, but takes a DataSourceBase as source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Contains a C++ type to be decomposed into a hierarchy of properties. </td></tr>
    <tr><td class="paramname">targetbag</td><td>The bag in which to place the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceRTT_1_1types.html#a23773014261904a984359984a28b13a8" title="Uses the type decomposition to decompose a property into a property bag that refers to all its parts...">RTT::types::propertyDecomposition</a> </dd></dl>

<p>Definition at line <a class="el" href="PropertyDecomposition_8cpp_source.html#l00073">73</a> of file <a class="el" href="PropertyDecomposition_8cpp_source.html">PropertyDecomposition.cpp</a>.</p>

<p>References <a class="el" href="PropertyBag_8cpp_source.html#l00073">RTT::PropertyBag::add()</a>, <a class="el" href="TypeInfo_8hpp_source.html#l00214">RTT::types::TypeInfo::buildProperty()</a>, <a class="el" href="PropertyBag_8hpp_source.html#l00219">RTT::PropertyBag::empty()</a>, <a class="el" href="classRTT_1_1internal_1_1DataSource.html#a667b4de57e8f127baa5c12925e1e24bf">RTT::internal::DataSource&lt; T &gt;::get()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#aef1f9e802faddb20dc36ccb6a737869c">RTT::base::PropertyBase::getDataSource()</a>, <a class="el" href="classRTT_1_1base_1_1PropertyBase.html#afaf365d2b2a93f2d602d82af87ac233f">RTT::base::PropertyBase::getTypeInfo()</a>, <a class="el" href="PropertyBag_8cpp_source.html#l00083">RTT::PropertyBag::ownProperty()</a>, <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">propertyDecomposition()</a>, <a class="el" href="classRTT_1_1internal_1_1DataSource.html#a7c10d4f18a3e7de9bbd534eb232d850e">RTT::internal::DataSource&lt; T &gt;::rvalue()</a>, and <a class="el" href="PropertyDecomposition_8cpp_source.html#l00073">typeDecomposition()</a>.</p>

<p>Referenced by <a class="el" href="BoostArrayTypeInfo_8hpp_source.html#l00154">RTT::types::BoostArrayTypeInfo&lt; T, has_ostream &gt;::composeType()</a>, <a class="el" href="CArrayTypeInfo_8hpp_source.html#l00176">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;::composeType()</a>, <a class="el" href="StructTypeInfo_8hpp_source.html#l00150">RTT::types::StructTypeInfo&lt; T, has_ostream &gt;::composeTypeImpl()</a>, <a class="el" href="PropertyDecomposition_8cpp_source.html#l00063">propertyDecomposition()</a>, and <a class="el" href="PropertyDecomposition_8cpp_source.html#l00073">typeDecomposition()</a>.</p>

</div>
</div>
<a class="anchor" id="a22d379bb9503d45c1a13c5e8597dd11d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTT_API TypeInfoRepository::shared_ptr RTT::types::Types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a pointer to the global type system. </p>
<p>This is a short notation for TypeInfoRepository::Instance(). </p>

<p>Definition at line <a class="el" href="Types_8cpp_source.html#l00048">48</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p>References <a class="el" href="Types_8cpp_source.html#l00048">Types()</a>.</p>

<p>Referenced by <a class="el" href="MultiVectorComposition_8hpp_source.html#l00107">RTT::extras::composeProperty()</a>, <a class="el" href="PropertyComposition_8cpp_source.html#l00010">composePropertyBag()</a>, <a class="el" href="BoostArrayTypeInfo_8hpp_source.html#l00154">RTT::types::BoostArrayTypeInfo&lt; T, has_ostream &gt;::composeType()</a>, <a class="el" href="CArrayTypeInfo_8hpp_source.html#l00176">RTT::types::CArrayTypeInfo&lt; T, has_ostream &gt;::composeType()</a>, <a class="el" href="StructTypeInfo_8hpp_source.html#l00150">RTT::types::StructTypeInfo&lt; T, has_ostream &gt;::composeTypeImpl()</a>, <a class="el" href="CorbaOperationCallerFactory_8cpp_source.html#l00084">RTT::corba::CorbaOperationCallerFactory::getArgumentType()</a>, <a class="el" href="CorbaOperationCallerFactory_8cpp_source.html#l00128">RTT::corba::CorbaOperationCallerFactory::getCollectType()</a>, <a class="el" href="EnumTypeInfo_8hpp_source.html#l00077">RTT::types::EnumTypeInfo&lt; T &gt;::installTypeInfoObject()</a>, <a class="el" href="CorbaOperationCallerFactory_8cpp_source.html#l00294">RTT::corba::CorbaOperationCallerFactory::produce()</a>, <a class="el" href="PropertyBag_8cpp_source.html#l00490">RTT::refreshProperties()</a>, <a class="el" href="Types_8cpp_source.html#l00048">Types()</a>, and <a class="el" href="PropertyBag_8cpp_source.html#l00557">RTT::updateProperties()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
