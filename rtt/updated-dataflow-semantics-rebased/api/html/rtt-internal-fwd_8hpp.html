<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Orocos Real-Time Toolkit: rtt/internal/rtt-internal-fwd.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit
   &#160;<span id="projectnumber">2.8.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b17daf279c0947dd62d31c6271e174bf.html">rtt</a></li><li class="navelem"><a class="el" href="dir_89f49d1238ce6a42e58a3b20e7ecf7c2.html">internal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">rtt-internal-fwd.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="rtt-internal-fwd_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1SharedConnection.html">RTT::internal::SharedConnection&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1UnaryDataSource.html">RTT::internal::UnaryDataSource&lt; function &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which returns the return value of a unary function.  <a href="classRTT_1_1internal_1_1UnaryDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1Signal.html">RTT::internal::Signal&lt; Signature, TSlotFunction &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very lightweight wrapper around the signalN classes that allows signals to be created where the number of arguments does not need to be part of the class name.  <a href="classRTT_1_1internal_1_1Signal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1List.html">RTT::internal::List&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object represents the default queue implementation used by <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> objects.  <a href="classRTT_1_1internal_1_1List.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ListLockFree.html">RTT::internal::ListLockFree&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>simple</em> lock-free list implementation to <em>append</em> or <em>erase</em> data of type <em>T</em>.  <a href="classRTT_1_1internal_1_1ListLockFree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ListLocked.html">RTT::internal::ListLocked&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>simple</em> lock-based list implementation to <em>append</em> or <em>erase</em> data of type <em>T</em>.  <a href="classRTT_1_1internal_1_1ListLocked.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1LockedQueue.html">RTT::internal::LockedQueue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock-based queue implementation to <em>enqueue</em> or <em>dequeue</em> a pointer of type <em>T</em>.  <a href="classRTT_1_1internal_1_1LockedQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceTypeInfo.html">RTT::internal::DataSourceTypeInfo&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> of type T has a type info class which it can ask type information.  <a href="structRTT_1_1internal_1_1DataSourceTypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceArgStorage.html">RTT::internal::DataSourceArgStorage&lt; A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisations for storing a (const) reference or not reference The trick here is to take a (const) reference data source to something that was already a reference, and copy to a value data source for something that is plain value.  <a href="structRTT_1_1internal_1_1DataSourceArgStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceStorage.html">RTT::internal::DataSourceStorage&lt; DataType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper-class for the Command implementation which stores the command and condition function objects.  <a href="structRTT_1_1internal_1_1DataSourceStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1Collect.html">RTT::internal::Collect&lt; F, BaseImpl &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct takes the user's Function signature <em>F</em> and transforms it to the form required in the <a class="el" href="structRTT_1_1internal_1_1CollectImpl.html">CollectImpl</a> template specialisations.  <a href="structRTT_1_1internal_1_1Collect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1Invoker.html">RTT::internal::Invoker&lt; F, BaseImpl &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an invocation object with a function signature to invoke and an implementation in which an operator(args) is available which has this signature.  <a href="structRTT_1_1internal_1_1Invoker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1Return.html">RTT::internal::Return&lt; F, BaseImpl &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AddMember.html">RTT::internal::AddMember&lt; F, Class &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of <a class="el" href="classRTT_1_1internal_1_1UnMember.html" title="This class converts a member function type R (X::)(Args) to a plain function type R (Args) which can ...">UnMember</a>.  <a href="classRTT_1_1internal_1_1AddMember.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ArgMember.html">RTT::internal::ArgMember&lt; F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A complexer variant of <a class="el" href="classRTT_1_1internal_1_1UnMember.html" title="This class converts a member function type R (X::)(Args) to a plain function type R (Args) which can ...">UnMember</a>: Convert a member function type to a function type which contains the object as first argument.  <a href="classRTT_1_1internal_1_1ArgMember.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1UnMember.html">RTT::internal::UnMember&lt; F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class converts a member function type R (X::)(Args) to a plain function type R (Args) which can be used by a boost::function or similar.  <a href="classRTT_1_1internal_1_1UnMember.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1UnPointer.html">RTT::internal::UnPointer&lt; F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a function R (X::)(Args) to a plain function signature R(X::,Args)  <a href="classRTT_1_1internal_1_1UnPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1CollectBase.html">RTT::internal::CollectBase&lt; F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct takes the user's Function signature <em>F</em> and transforms it to the form required in the <a class="el" href="structRTT_1_1internal_1_1CollectBaseImpl.html" title="The collection signature is formed by Ft, which is a transformed form of F. ">CollectBaseImpl</a> template specialisations.  <a href="structRTT_1_1internal_1_1CollectBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1CollectType.html">RTT::internal::CollectType&lt; F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper struct decomposes F and creates Ft, as required by <a class="el" href="structRTT_1_1internal_1_1CollectBaseImpl.html" title="The collection signature is formed by Ft, which is a transformed form of F. ">CollectBaseImpl</a>.  <a href="structRTT_1_1internal_1_1CollectType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1InvokerBase.html">RTT::internal::InvokerBase&lt; F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class that defines the interface of all invocable method implementations.  <a href="structRTT_1_1internal_1_1InvokerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1OperationCallerBinder.html">RTT::internal::OperationCallerBinder&lt; F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very simple <b>factory</b> class to bind a member function to an object pointer and leave the arguments open.  <a href="structRTT_1_1internal_1_1OperationCallerBinder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1ReturnBase.html">RTT::internal::ReturnBase&lt; F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class that defines the interface of returning data from method invocations.  <a href="structRTT_1_1internal_1_1ReturnBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html">RTT::internal::LocalOperationCallerImpl&lt; FunctionT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements call, send, collect, collectIfDone for all function arities.  <a href="classRTT_1_1internal_1_1LocalOperationCallerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1GetSignature.html">RTT::internal::GetSignature&lt; FunctionT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function signature from a C or C++ member function pointer type.  <a href="structRTT_1_1internal_1_1GetSignature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1GetSignatureDS.html">RTT::internal::GetSignatureDS&lt; FunctionT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function signature from a C or C++ member function pointer type, suitable for DS operations.  <a href="structRTT_1_1internal_1_1GetSignatureDS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1LocalOperationCaller.html">RTT::internal::LocalOperationCaller&lt; FunctionT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method which executes a local function.  <a href="structRTT_1_1internal_1_1LocalOperationCaller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1RemoteOperationCaller.html">RTT::internal::RemoteOperationCaller&lt; OperationCallerT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> implementation which delegates C++ to datasource conversions when C++ code tries to call remote operations, only available in an <a class="el" href="classRTT_1_1OperationInterfacePart.html" title="This class defines the interface for creating operation objects without using C++ templates...">OperationInterfacePart</a>, and not through an OperationBase.  <a href="classRTT_1_1internal_1_1RemoteOperationCaller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1RemoteOperationCallerImpl.html">RTT::internal::RemoteOperationCallerImpl&lt; OperationCallerT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> implementation which executes a remote function which is encapsulated in a <a class="el" href="classRTT_1_1internal_1_1OperationCallerC.html" title="A template-less manager for OperationCaller calls. ">OperationCallerC</a> and <a class="el" href="classRTT_1_1internal_1_1SendHandleC.html" title="A template-less SendHandle manager. ">SendHandleC</a> object.  <a href="classRTT_1_1internal_1_1RemoteOperationCallerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DataSourceResultStorage.html">RTT::internal::DataSourceResultStorage&lt; R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisations for storing a void, not a void or reference Wraps around <a class="el" href="structRTT_1_1internal_1_1RStore.html" title="Store a return value which may be a void, reference, const reference or any other type...">RStore</a>.  <a href="structRTT_1_1internal_1_1DataSourceResultStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1AssignHelper.html">RTT::internal::AssignHelper&lt; Seq, Data, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for avoiding assigning a bare pointer to a shared_ptr data source.  <a href="structRTT_1_1internal_1_1AssignHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1GetPointerWrap.html">RTT::internal::GetPointerWrap&lt; Seq, Data, Enable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DSWrap.html">RTT::internal::DSWrap&lt; T, Enable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AtomicQueue.html">RTT::internal::AtomicQueue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic, non-blocking single ended queue (FIFO) for storing a <b>pointer</b> to <em>T</em>.  <a href="classRTT_1_1internal_1_1AtomicQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AtomicMWMRQueue.html">RTT::internal::AtomicMWMRQueue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an atomic, non-blocking single ended queue (FIFO) for storing a <b>pointer</b> to <em>T</em>.  <a href="classRTT_1_1internal_1_1AtomicMWMRQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AtomicMWSRQueue.html">RTT::internal::AtomicMWSRQueue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an atomic, non-blocking Multi-Writer Single-Reader FIFO for storing a pointer <em>T</em> by value.  <a href="classRTT_1_1internal_1_1AtomicMWSRQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1MWSRQueue.html">RTT::internal::MWSRQueue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object represents the default Multi-Writer, Single-Reader queue implementation used by <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> objects.  <a href="classRTT_1_1internal_1_1MWSRQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1Queue.html">RTT::internal::Queue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object represents the default Multi-Writer/Multi-Reader queue implementation used by <a class="el" href="namespaceOrocos.html" title="The project wide Orocos namespace contains all user classes of various projects. ">Orocos</a> objects.  <a href="classRTT_1_1internal_1_1Queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1AStore.html">RTT::internal::AStore&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a bound argument which may be a reference, const reference or any other type.  <a href="structRTT_1_1internal_1_1AStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1DSRStore.html">RTT::internal::DSRStore&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="structRTT_1_1internal_1_1RStore.html" title="Store a return value which may be a void, reference, const reference or any other type...">RStore</a>, but specific for <a class="el" href="structRTT_1_1internal_1_1DataSourceStorage.html" title="A helper-class for the Command implementation which stores the command and condition function objects...">DataSourceStorage</a>.  <a href="structRTT_1_1internal_1_1DSRStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1NA.html">RTT::internal::NA&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to return a 'default' value when no value is available ('Not Available').  <a href="structRTT_1_1internal_1_1NA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1RStore.html">RTT::internal::RStore&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a return value which may be a void, reference, const reference or any other type.  <a href="structRTT_1_1internal_1_1RStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1UpdateHelper.html">RTT::internal::UpdateHelper&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to only update data sources that hold references.  <a href="structRTT_1_1internal_1_1UpdateHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1BindStorage.html">RTT::internal::BindStorage&lt; ToBind &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper-class for the Command implementation which stores the command and collition function objects.  <a href="structRTT_1_1internal_1_1BindStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1UnboundDataSource.html">RTT::internal::UnboundDataSource&lt; BoundType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> only to be used for if you understand the <a class="el" href="classRTT_1_1internal_1_1UnboundDataSource.html#adfd590d9e65f79a55f9474ff94f3065e">copy()</a>/clone() semantics very well.  <a href="classRTT_1_1internal_1_1UnboundDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1FusedFunctorDataSource.html">RTT::internal::FusedFunctorDataSource&lt; Signature, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> that calls a functor of signature <em>Signature</em> which gets its arguments from other data sources.  <a href="structRTT_1_1internal_1_1FusedFunctorDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1OperationInterfacePartFusedDS.html">RTT::internal::OperationInterfacePartFusedDS&lt; Signature, ObjT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1OperationInterfacePart.html" title="This class defines the interface for creating operation objects without using C++ templates...">OperationInterfacePart</a> implementation that uses boost::fusion to produce items.  <a href="classRTT_1_1internal_1_1OperationInterfacePartFusedDS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1OperationInterfacePartFused.html">RTT::internal::OperationInterfacePartFused&lt; Signature &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1OperationInterfacePart.html" title="This class defines the interface for creating operation objects without using C++ templates...">OperationInterfacePart</a> implementation that uses boost::fusion to produce items.  <a href="classRTT_1_1internal_1_1OperationInterfacePartFused.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1SynchronousOperationInterfacePartFused.html">RTT::internal::SynchronousOperationInterfacePartFused&lt; Signature &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1OperationInterfacePart.html" title="This class defines the interface for creating operation objects without using C++ templates...">OperationInterfacePart</a> implementation that only provides synchronous access to an operation.  <a href="classRTT_1_1internal_1_1SynchronousOperationInterfacePartFused.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1FusedMCallDataSource.html">RTT::internal::FusedMCallDataSource&lt; Signature &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> that calls a method which gets its arguments from other data sources.  <a href="structRTT_1_1internal_1_1FusedMCallDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1FusedMCollectDataSource.html">RTT::internal::FusedMCollectDataSource&lt; Signature &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> that collects the result of an asynchronous method which store its results in other data sources.  <a href="structRTT_1_1internal_1_1FusedMCollectDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1FusedMSendDataSource.html">RTT::internal::FusedMSendDataSource&lt; Signature &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> that sends a method which gets its arguments from other data sources.  <a href="structRTT_1_1internal_1_1FusedMSendDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTT_1_1internal_1_1FusedMSignal.html">RTT::internal::FusedMSignal&lt; Signature &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Function object that reacts to a <a class="el" href="classRTT_1_1internal_1_1Signal.html" title="Very lightweight wrapper around the signalN classes that allows signals to be created where the numbe...">Signal</a> by writing the arguments in data sources and calling an action object.  <a href="structRTT_1_1internal_1_1FusedMSignal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AssignCommand.html">RTT::internal::AssignCommand&lt; T, S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a command that will assign the value of an expression to another at runtime.  <a href="classRTT_1_1internal_1_1AssignCommand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ActionAliasAssignableDataSource.html">RTT::internal::ActionAliasAssignableDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html" title="A DataSource which has set() methods. ">AssignableDataSource</a> which is used to execute an action and then return the value of another <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a>.  <a href="classRTT_1_1internal_1_1ActionAliasAssignableDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ActionAliasDataSource.html">RTT::internal::ActionAliasDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to execute an action and then return the value of another <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a>.  <a href="classRTT_1_1internal_1_1ActionAliasDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ArrayPartDataSource.html">RTT::internal::ArrayPartDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to manipulate a reference to a part of a data source holding a C-style array of elements.  <a href="classRTT_1_1internal_1_1ArrayPartDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html">RTT::internal::AssignableDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which has <a class="el" href="classRTT_1_1internal_1_1AssignableDataSource.html#a3fbb0b9564941923b5776b413bf75813" title="Get a reference to the value of this DataSource. ">set()</a> methods.  <a href="classRTT_1_1internal_1_1AssignableDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ChannelBufferElement.html">RTT::internal::ChannelBufferElement&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A connection element that can store a fixed number of data samples.  <a href="classRTT_1_1internal_1_1ChannelBufferElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ChannelDataElement.html">RTT::internal::ChannelDataElement&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A connection element that stores a single data sample.  <a href="classRTT_1_1internal_1_1ChannelDataElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnInputEndpoint.html">RTT::internal::ConnInputEndpoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a channel element that represents the input endpoint of a connection, i.e.  <a href="classRTT_1_1internal_1_1ConnInputEndpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConnOutputEndpoint.html">RTT::internal::ConnOutputEndpoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a channel element that represents the output endpoint of a connection, i.e.  <a href="classRTT_1_1internal_1_1ConnOutputEndpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConstReferenceDataSource.html">RTT::internal::ConstReferenceDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to read a const reference to an external value.  <a href="classRTT_1_1internal_1_1ConstReferenceDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ConstantDataSource.html">RTT::internal::ConstantDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which holds a constant value and returns it in its <a class="el" href="classRTT_1_1internal_1_1ConstantDataSource.html#a274b252292bcf3ae47b41128fb05cd45" title="Return the data as type T. ">get()</a> method.  <a href="classRTT_1_1internal_1_1ConstantDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1DataSource.html">RTT::internal::DataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> is a base class representing a generic way to read data of type <em>T</em>.  <a href="classRTT_1_1internal_1_1DataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1InputPortSource.html">RTT::internal::InputPortSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a read port using the data source interface.  <a href="classRTT_1_1internal_1_1InputPortSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1LateConstReferenceDataSource.html">RTT::internal::LateConstReferenceDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to manipulate a const reference to an external value, by means of a pointer, which can be set after the data source was created.  <a href="classRTT_1_1internal_1_1LateConstReferenceDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1LateReferenceDataSource.html">RTT::internal::LateReferenceDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to manipulate a reference to an external value, by means of a pointer, which can be set after the data source was created.  <a href="classRTT_1_1internal_1_1LateReferenceDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1OffsetPartDataSource.html">RTT::internal::OffsetPartDataSource&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1PartDataSource.html">RTT::internal::PartDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to manipulate a reference to a part of a data source.  <a href="classRTT_1_1internal_1_1PartDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ReferenceDataSource.html">RTT::internal::ReferenceDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a> which is used to manipulate a reference to an external value.  <a href="classRTT_1_1internal_1_1ReferenceDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1TsPool.html">RTT::internal::TsPool&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-reader multi-writer MemoryPool implementation.  <a href="classRTT_1_1internal_1_1TsPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1ValueDataSource.html">RTT::internal::ValueDataSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple, yet very useful <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a>, which keeps a value, and returns it in its <a class="el" href="classRTT_1_1internal_1_1ValueDataSource.html#a49beaea7df1ad6bfa31bcb15e47299cc" title="Return the data as type T. ">get()</a> method.  <a href="classRTT_1_1internal_1_1ValueDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1BinaryDataSource.html">RTT::internal::BinaryDataSource&lt; function &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic binary composite <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a>.  <a href="classRTT_1_1internal_1_1BinaryDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1NArityDataSource.html">RTT::internal::NArityDataSource&lt; function &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic N-arity composite <a class="el" href="classRTT_1_1internal_1_1DataSource.html" title="DataSource is a base class representing a generic way to read data of type T. ">DataSource</a>.  <a href="classRTT_1_1internal_1_1NArityDataSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceRTT"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT.html">RTT</a></td></tr>
<tr class="memdesc:namespaceRTT"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>, <a class="el" href="classRTT_1_1Activity.html" title="An Activity is an object that represents a thread. ">Activity</a>, <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a>, <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a>, <a class="el" href="classRTT_1_1Property.html" title="A property represents a named value of any type with a description. ">Property</a>, <a class="el" href="classRTT_1_1InputPort.html" title="A component&#39;s data input port. ">InputPort</a>, <a class="el" href="classRTT_1_1OutputPort.html" title="A component&#39;s data output port. ">OutputPort</a>, <a class="el" href="classRTT_1_1Attribute.html" title="An Attribute has a name and contains data which can be set and get. ">Attribute</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRTT_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1internal.html">RTT::internal</a></td></tr>
<tr class="memdesc:namespaceRTT_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes which contain all implementation code for the <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute. ">RTT</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRTT_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRTT_1_1detail.html">RTT::detail</a></td></tr>
<tr class="memdesc:namespaceRTT_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient short notation for every sub-namespace of <a class="el" href="namespaceRTT.html" title="Contains TaskContext, Activity, OperationCaller, Operation, Property, InputPort, OutputPort, Attribute. ">RTT</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 6 2017 02:25:07 for Orocos Real-Time Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
