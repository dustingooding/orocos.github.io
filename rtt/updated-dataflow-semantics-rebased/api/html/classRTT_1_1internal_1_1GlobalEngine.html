<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Orocos Real-Time Toolkit: RTT::internal::GlobalEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Orocos Real-Time Toolkit
   &#160;<span id="projectnumber">2.8.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRTT.html">RTT</a></li><li class="navelem"><a class="el" href="namespaceRTT_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="classRTT_1_1internal_1_1GlobalEngine.html">GlobalEngine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRTT_1_1internal_1_1GlobalEngine-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RTT::internal::GlobalEngine Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A process-wide execution engine that processes every asynchronous operation that is not being processed by a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>.  
 <a href="classRTT_1_1internal_1_1GlobalEngine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="GlobalEngine_8hpp_source.html">rtt/internal/GlobalEngine.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTT::internal::GlobalEngine:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRTT_1_1internal_1_1GlobalEngine.png" usemap="#RTT::internal::GlobalEngine_map" alt=""/>
  <map id="RTT::internal::GlobalEngine_map" name="RTT::internal::GlobalEngine_map">
<area href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands..." alt="RTT::ExecutionEngine" shape="rect" coords="0,56,176,80"/>
<area href="classRTT_1_1base_1_1RunnableInterface.html" title="A class for running a certain piece of code in a thread. " alt="RTT::base::RunnableInterface" shape="rect" coords="0,0,176,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a32a0b5dbeb1b46b264a938c6d3bfe69b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32a0b5dbeb1b46b264a938c6d3bfe69b"></a>
<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a32a0b5dbeb1b46b264a938c6d3bfe69b">getParent</a> ()</td></tr>
<tr class="memdesc:a32a0b5dbeb1b46b264a938c6d3bfe69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task. ">base::TaskCore</a> which created this <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>. <br /></td></tr>
<tr class="separator:a32a0b5dbeb1b46b264a938c6d3bfe69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f75f30232e7a789a62e9391ac34889"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45f75f30232e7a789a62e9391ac34889"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a45f75f30232e7a789a62e9391ac34889">addChild</a> (<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *tc)</td></tr>
<tr class="memdesc:a45f75f30232e7a789a62e9391ac34889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task. ">base::TaskCore</a> to execute. <br /></td></tr>
<tr class="separator:a45f75f30232e7a789a62e9391ac34889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20f84c969d11c6450c0f9e244f7461f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af20f84c969d11c6450c0f9e244f7461f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#af20f84c969d11c6450c0f9e244f7461f">removeChild</a> (<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *tc)</td></tr>
<tr class="memdesc:af20f84c969d11c6450c0f9e244f7461f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a <a class="el" href="classRTT_1_1base_1_1TaskCore.html" title="The minimal Orocos task. ">base::TaskCore</a> from execution. <br /></td></tr>
<tr class="separator:af20f84c969d11c6450c0f9e244f7461f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b64998ed8a783549a53405a30b701e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b64998ed8a783549a53405a30b701e3"></a>
<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a7b64998ed8a783549a53405a30b701e3">getTaskCore</a> () const </td></tr>
<tr class="memdesc:a7b64998ed8a783549a53405a30b701e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the owner of this execution engine. <br /></td></tr>
<tr class="separator:a7b64998ed8a783549a53405a30b701e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0d36338cc3c7467325b8408f4f4648"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a9e0d36338cc3c7467325b8408f4f4648">process</a> (<a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> *c)</td></tr>
<tr class="memdesc:a9e0d36338cc3c7467325b8408f4f4648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue and execute (process) a given message.  <a href="#a9e0d36338cc3c7467325b8408f4f4648">More...</a><br /></td></tr>
<tr class="separator:a9e0d36338cc3c7467325b8408f4f4648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f7fe7c3d76cc6ab5f27e4b92b91eb7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a42f7fe7c3d76cc6ab5f27e4b92b91eb7">runFunction</a> (<a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *f)</td></tr>
<tr class="memdesc:a42f7fe7c3d76cc6ab5f27e4b92b91eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a given function in <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a> or <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread. ">loop()</a>.  <a href="#a42f7fe7c3d76cc6ab5f27e4b92b91eb7">More...</a><br /></td></tr>
<tr class="separator:a42f7fe7c3d76cc6ab5f27e4b92b91eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd4e66095262fd9f05e9f9d0f6ab32c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#afdd4e66095262fd9f05e9f9d0f6ab32c">removeFunction</a> (<a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *f)</td></tr>
<tr class="memdesc:afdd4e66095262fd9f05e9f9d0f6ab32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a running function added with runFunction.  <a href="#afdd4e66095262fd9f05e9f9d0f6ab32c">More...</a><br /></td></tr>
<tr class="separator:afdd4e66095262fd9f05e9f9d0f6ab32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed7d8245e3b8a7363b535770ffd1b45"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a9ed7d8245e3b8a7363b535770ffd1b45">removeSelfFunction</a> (<a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *f)</td></tr>
<tr class="memdesc:a9ed7d8245e3b8a7363b535770ffd1b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-removal for a running function added with runFunction.  <a href="#a9ed7d8245e3b8a7363b535770ffd1b45">More...</a><br /></td></tr>
<tr class="separator:a9ed7d8245e3b8a7363b535770ffd1b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb235144afc09805d9cd1982afac023b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#aeb235144afc09805d9cd1982afac023b">waitForMessages</a> (const boost::function&lt; bool(void)&gt; &amp;pred)</td></tr>
<tr class="memdesc:aeb235144afc09805d9cd1982afac023b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you wish to block on a message arriving in the Execution Engine.  <a href="#aeb235144afc09805d9cd1982afac023b">More...</a><br /></td></tr>
<tr class="separator:aeb235144afc09805d9cd1982afac023b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4703380e45a26dd1a0ef62c6cb3069eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a4703380e45a26dd1a0ef62c6cb3069eb">waitForFunctions</a> (const boost::function&lt; bool(void)&gt; &amp;pred)</td></tr>
<tr class="memdesc:a4703380e45a26dd1a0ef62c6cb3069eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you wish to block on a function completing in the Execution Engine.  <a href="#a4703380e45a26dd1a0ef62c6cb3069eb">More...</a><br /></td></tr>
<tr class="separator:a4703380e45a26dd1a0ef62c6cb3069eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d22ea9534992a8e6416ec6838d73b84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a1d22ea9534992a8e6416ec6838d73b84">stopTask</a> (<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *task)</td></tr>
<tr class="memdesc:a1d22ea9534992a8e6416ec6838d73b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops executing the updateHook of <em>task</em>.  <a href="#a1d22ea9534992a8e6416ec6838d73b84">More...</a><br /></td></tr>
<tr class="separator:a1d22ea9534992a8e6416ec6838d73b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af371ca99138fb1b44857e3f796fa9477"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af371ca99138fb1b44857e3f796fa9477"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#af371ca99138fb1b44857e3f796fa9477">setExceptionTask</a> ()</td></tr>
<tr class="memdesc:af371ca99138fb1b44857e3f796fa9477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the 'owner' task in the exception state. <br /></td></tr>
<tr class="separator:af371ca99138fb1b44857e3f796fa9477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9ba95daa969ce48537a862fb513bd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a6e9ba95daa969ce48537a862fb513bd7">setMaster</a> (<a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *master)</td></tr>
<tr class="memdesc:a6e9ba95daa969ce48537a862fb513bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the master <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>.  <a href="#a6e9ba95daa969ce48537a862fb513bd7">More...</a><br /></td></tr>
<tr class="separator:a6e9ba95daa969ce48537a862fb513bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b290342974c0b41c97515b1a4e9fd6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#ac8b290342974c0b41c97515b1a4e9fd6">setActivity</a> (<a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">base::ActivityInterface</a> *task)</td></tr>
<tr class="memdesc:ac8b290342974c0b41c97515b1a4e9fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overridden version of <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a563528c3275ef0631f17928a80994371" title="Set the task this interface is run in. ">RTT::base::RunnableInterface::setActivity()</a>.  <a href="#ac8b290342974c0b41c97515b1a4e9fd6">More...</a><br /></td></tr>
<tr class="separator:ac8b290342974c0b41c97515b1a4e9fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faeed04034647645557eb05f6f3eec2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2">loop</a> ()</td></tr>
<tr class="memdesc:a6faeed04034647645557eb05f6f3eec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method that will be executed once when this class is run in a non periodic thread.  <a href="#a6faeed04034647645557eb05f6f3eec2">More...</a><br /></td></tr>
<tr class="separator:a6faeed04034647645557eb05f6f3eec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c3cbd96505481cbd9c2f5081c2cd72"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRTT_1_1os_1_1ThreadInterface.html">os::ThreadInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a10c3cbd96505481cbd9c2f5081c2cd72">getThread</a> () const </td></tr>
<tr class="memdesc:a10c3cbd96505481cbd9c2f5081c2cd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread this object is run in.  <a href="#a10c3cbd96505481cbd9c2f5081c2cd72">More...</a><br /></td></tr>
<tr class="separator:a10c3cbd96505481cbd9c2f5081c2cd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c18e6321d3e6929e0097940d68c1ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">ActivityInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a70c18e6321d3e6929e0097940d68c1ef">getActivity</a> () const </td></tr>
<tr class="memdesc:a70c18e6321d3e6929e0097940d68c1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for the task this interface is run in.  <a href="#a70c18e6321d3e6929e0097940d68c1ef">More...</a><br /></td></tr>
<tr class="separator:a70c18e6321d3e6929e0097940d68c1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acd69e0c7eae8ec2010c6729e1f85d968"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd69e0c7eae8ec2010c6729e1f85d968"></a>
static RTT_API <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1internal_1_1GlobalEngine.html#acd69e0c7eae8ec2010c6729e1f85d968">Instance</a> ()</td></tr>
<tr class="memdesc:acd69e0c7eae8ec2010c6729e1f85d968"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This is kept (instead of using default parameters) for ABI compatibility. <br /></td></tr>
<tr class="separator:acd69e0c7eae8ec2010c6729e1f85d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e6ff1c2f9f8f67bf7f14645f3db6d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6e6ff1c2f9f8f67bf7f14645f3db6d8"></a>
static RTT_API <a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Instance</b> (int scheduler, int priority=<a class="el" href="namespaceRTT_1_1os.html#a75db7ced70acfd4beac6b7dcc96396b7">os::LowestPriority</a>, unsigned cpu_affinity=0)</td></tr>
<tr class="separator:ab6e6ff1c2f9f8f67bf7f14645f3db6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc00d0751444fb943f46c6f8cc0f474"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dc00d0751444fb943f46c6f8cc0f474"></a>
static RTT_API void&#160;</td><td class="memItemRight" valign="bottom"><b>Release</b> ()</td></tr>
<tr class="separator:a7dc00d0751444fb943f46c6f8cc0f474"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac489df0ded78420f7eb798dc9ce888fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#ac489df0ded78420f7eb798dc9ce888fb">waitForMessagesInternal</a> (boost::function&lt; bool(void)&gt; const &amp;pred)</td></tr>
<tr class="memdesc:ac489df0ded78420f7eb798dc9ce888fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you wish to block on a message arriving in the Execution Engine.  <a href="#ac489df0ded78420f7eb798dc9ce888fb">More...</a><br /></td></tr>
<tr class="separator:ac489df0ded78420f7eb798dc9ce888fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1435416406d34e86fb03289ea2d53e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a9b1435416406d34e86fb03289ea2d53e">waitAndProcessMessages</a> (boost::function&lt; bool(void)&gt; const &amp;pred)</td></tr>
<tr class="memdesc:a9b1435416406d34e86fb03289ea2d53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you wish to block on a message arriving in the Execution Engine and execute it.  <a href="#a9b1435416406d34e86fb03289ea2d53e">More...</a><br /></td></tr>
<tr class="separator:a9b1435416406d34e86fb03289ea2d53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1d79b5da733c511d90d8b4562de5eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a5a1d79b5da733c511d90d8b4562de5eb">waitAndProcessFunctions</a> (boost::function&lt; bool(void)&gt; const &amp;pred)</td></tr>
<tr class="memdesc:a5a1d79b5da733c511d90d8b4562de5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this if you wish to block on a function completing in the Execution Engine and execute it.  <a href="#a5a1d79b5da733c511d90d8b4562de5eb">More...</a><br /></td></tr>
<tr class="separator:a5a1d79b5da733c511d90d8b4562de5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081fe8bd03ae9984f5ff51435fa0da87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081fe8bd03ae9984f5ff51435fa0da87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>processMessages</b> ()</td></tr>
<tr class="separator:a081fe8bd03ae9984f5ff51435fa0da87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf869c0f569b1d1ddc75f5fd3e68afc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf869c0f569b1d1ddc75f5fd3e68afc6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>processFunctions</b> ()</td></tr>
<tr class="separator:adf869c0f569b1d1ddc75f5fd3e68afc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a91a3947795128d0a0cb41c6a801f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6a91a3947795128d0a0cb41c6a801f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>processChildren</b> ()</td></tr>
<tr class="separator:ae6a91a3947795128d0a0cb41c6a801f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a60f7b0673bab85e3c024903aed7ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37a60f7b0673bab85e3c024903aed7ca"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a37a60f7b0673bab85e3c024903aed7ca">initialize</a> ()</td></tr>
<tr class="memdesc:a37a60f7b0673bab85e3c024903aed7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method that will be called before the first periodical execution of <em><a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a></em> ( or non periodical execution of <em><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread. ">loop()</a></em> ), when the thread is started. <br /></td></tr>
<tr class="separator:a37a60f7b0673bab85e3c024903aed7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae452e029ed5e188ac76d9447befc6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae452e029ed5e188ac76d9447befc6a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a">step</a> ()</td></tr>
<tr class="memdesc:aaae452e029ed5e188ac76d9447befc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes (in that order) Messages, Functions and updateHook() functions of this <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a> and its children. <br /></td></tr>
<tr class="separator:aaae452e029ed5e188ac76d9447befc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26205393f406511efbf43360af25f4bb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a26205393f406511efbf43360af25f4bb">breakLoop</a> ()</td></tr>
<tr class="memdesc:a26205393f406511efbf43360af25f4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by the framework to break out of the <em><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread. ">loop()</a></em> method.  <a href="#a26205393f406511efbf43360af25f4bb">More...</a><br /></td></tr>
<tr class="separator:a26205393f406511efbf43360af25f4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968d06304e043aa67075f5da402eaa9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a968d06304e043aa67075f5da402eaa9a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a968d06304e043aa67075f5da402eaa9a">finalize</a> ()</td></tr>
<tr class="memdesc:a968d06304e043aa67075f5da402eaa9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method that will be called after the last periodical execution of <em><a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a></em> ( or non periodical execution of <em><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread. ">loop()</a></em> ), when the RunnableInterface is stopped. <br /></td></tr>
<tr class="separator:a968d06304e043aa67075f5da402eaa9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e767baa0ee365ed77142e755bc51323"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a3e767baa0ee365ed77142e755bc51323">hasWork</a> ()</td></tr>
<tr class="memdesc:a3e767baa0ee365ed77142e755bc51323"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is for 'intelligent' activity implementations that wish to see if it is required to call <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a> (again).  <a href="#a3e767baa0ee365ed77142e755bc51323">More...</a><br /></td></tr>
<tr class="separator:a3e767baa0ee365ed77142e755bc51323"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6fc9359abc8c2d9c484763618b562f50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fc9359abc8c2d9c484763618b562f50"></a>
<a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a6fc9359abc8c2d9c484763618b562f50">taskc</a></td></tr>
<tr class="memdesc:a6fc9359abc8c2d9c484763618b562f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent or 'owner' of this <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>, may be null. <br /></td></tr>
<tr class="separator:a6fc9359abc8c2d9c484763618b562f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ec437ba2d6d809b9b08472c732c9d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49ec437ba2d6d809b9b08472c732c9d8"></a>
<a class="el" href="classRTT_1_1internal_1_1MWSRQueue.html">internal::MWSRQueue</a>&lt; <a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a49ec437ba2d6d809b9b08472c732c9d8">mqueue</a></td></tr>
<tr class="memdesc:a49ec437ba2d6d809b9b08472c732c9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our Message queue. <br /></td></tr>
<tr class="separator:a49ec437ba2d6d809b9b08472c732c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a0045e0aae0529380ab938948396f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9a0045e0aae0529380ab938948396f7"></a>
std::vector&lt; <a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>children</b></td></tr>
<tr class="separator:ad9a0045e0aae0529380ab938948396f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466a68650254e029d4eea6722ba5915a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a466a68650254e029d4eea6722ba5915a"></a>
<a class="el" href="classRTT_1_1internal_1_1MWSRQueue.html">internal::MWSRQueue</a>&lt; <a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a466a68650254e029d4eea6722ba5915a">f_queue</a></td></tr>
<tr class="memdesc:a466a68650254e029d4eea6722ba5915a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all functions we're executing. <br /></td></tr>
<tr class="separator:a466a68650254e029d4eea6722ba5915a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c83aec88698b7df69f14aeb5b1d23ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c83aec88698b7df69f14aeb5b1d23ce"></a>
<a class="el" href="classRTT_1_1os_1_1Mutex.html">os::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>msg_lock</b></td></tr>
<tr class="separator:a1c83aec88698b7df69f14aeb5b1d23ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10217462ab4e022f5388768dc3c62fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad10217462ab4e022f5388768dc3c62fe"></a>
<a class="el" href="classRTT_1_1os_1_1Condition.html">os::Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>msg_cond</b></td></tr>
<tr class="separator:ad10217462ab4e022f5388768dc3c62fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d7968137f1997f83847cd5119ac5b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTT_1_1ExecutionEngine.html#a74d7968137f1997f83847cd5119ac5b6">mmaster</a></td></tr>
<tr class="memdesc:a74d7968137f1997f83847cd5119ac5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A master <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> which should process our messages.  <a href="#a74d7968137f1997f83847cd5119ac5b6">More...</a><br /></td></tr>
<tr class="separator:a74d7968137f1997f83847cd5119ac5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A process-wide execution engine that processes every asynchronous operation that is not being processed by a <a class="el" href="classRTT_1_1TaskContext.html" title="The TaskContext is the C++ representation of an Orocos component. ">TaskContext</a>. </p>
<p>In practice, this only occurs when a client does a send() on an <a class="el" href="classRTT_1_1OperationCaller.html" title="A OperationCaller serves as a placeholder (aka &#39;proxy&#39;) for a remote Operation. ">OperationCaller</a> which calls an <a class="el" href="classRTT_1_1Operation.html" title="The operation ties a C or C++ function into a component interface. ">Operation</a> with the ClientThread policy. </p>

<p>Definition at line <a class="el" href="GlobalEngine_8hpp_source.html#l00060">60</a> of file <a class="el" href="GlobalEngine_8hpp_source.html">GlobalEngine.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a26205393f406511efbf43360af25f4bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::breakLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called by the framework to break out of the <em><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread. ">loop()</a></em> method. </p>
<p>Reimplement this method to signal <em><a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread. ">loop()</a></em> to return and return true on success. When this method is not reimplemented by you, it will always return <em>false</em>, denoting that the loop can not be broken. If <a class="el" href="classRTT_1_1ExecutionEngine.html#a26205393f406511efbf43360af25f4bb" title="This method is called by the framework to break out of the loop() method. ">breakLoop()</a> returns <em>true</em>, the caller will wait until <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread. ">loop()</a> returns. </p><dl class="section return"><dt>Returns</dt><dd>true if the loop could be notified to return. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a1e8f7d948dce8a8eafd420f6a4baf574">RTT::base::RunnableInterface</a>.</p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00427">427</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8cpp_source.html#l00311">RTT::base::TaskCore::breakUpdateHook()</a>, and <a class="el" href="ExecutionEngine_8hpp_source.html#l00249">RTT::ExecutionEngine::taskc</a>.</p>

</div>
</div>
<a class="anchor" id="a70c18e6321d3e6929e0097940d68c1ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">ActivityInterface</a> * RTT::base::RunnableInterface::getActivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query for the task this interface is run in. </p>
<p>Zero denotes that no task is present to run it, and hence no detailed information is available.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classRTT_1_1Activity.html" title="An Activity is an object that represents a thread. ">Activity</a> which runs this <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html" title="A class for running a certain piece of code in a thread. ">RunnableInterface</a>. </dd></dl>

<p>Definition at line <a class="el" href="RunnableInterface_8hpp_source.html#l00167">167</a> of file <a class="el" href="RunnableInterface_8hpp_source.html">RunnableInterface.hpp</a>.</p>

<p>Referenced by <a class="el" href="TaskCore_8cpp_source.html#l00239">RTT::base::TaskCore::activate()</a>, <a class="el" href="StateMachine_8cpp_source.html#l00508">RTT::scripting::StateMachine::createEventTransition()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00146">RTT::base::TaskCore::fatal()</a>, <a class="el" href="TaskContext_8cpp_source.html#l00377">RTT::TaskContext::getActivity()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00282">RTT::base::TaskCore::getCpuAffinity()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00272">RTT::base::TaskCore::getPeriod()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00267">RTT::base::TaskCore::isActive()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00249">RTT::ExecutionEngine::process()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00168">RTT::ExecutionEngine::removeFunction()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00138">RTT::ExecutionEngine::runFunction()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00287">RTT::base::TaskCore::setCpuAffinity()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00277">RTT::base::TaskCore::setPeriod()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00357">RTT::ExecutionEngine::step()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00437">RTT::ExecutionEngine::stopTask()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00097">RTT::base::TaskCore::trigger()</a>, <a class="el" href="TaskCore_8cpp_source.html#l00090">RTT::base::TaskCore::update()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00284">RTT::ExecutionEngine::waitForFunctions()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00269">RTT::ExecutionEngine::waitForMessages()</a>.</p>

</div>
</div>
<a class="anchor" id="a10c3cbd96505481cbd9c2f5081c2cd72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1os_1_1ThreadInterface.html">os::ThreadInterface</a> * RTT::RunnableInterface::getThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the thread this object is run in. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the thread or 0 if not run by a thread. </dd></dl>

<p>Definition at line <a class="el" href="CoreRunnableInterface_8cpp_source.html#l00078">78</a> of file <a class="el" href="CoreRunnableInterface_8cpp_source.html">CoreRunnableInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a190329785c1c7e4a542db833402a7811">RTT::base::ActivityInterface::thread()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e767baa0ee365ed77142e755bc51323"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::hasWork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is for 'intelligent' activity implementations that wish to see if it is required to call <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a> (again). </p>
<p>By default, <em>false</em> is returned. You should only return <em>true</em> in case there is a temporary reason to (re-)run step. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em> if this object should be run. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRTT_1_1extras_1_1SequentialActivity.html" title="The default, thread-less activity for any newly created TaskContext. ">extras::SequentialActivity</a> implementation to see how this can be of use. </dd></dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a742d04970b31c2999e8fd7cb402947cd">RTT::base::RunnableInterface</a>.</p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00222">222</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1DisposableInterface.html#aa219e67cd5ba6c860ef90e316cc7306d">RTT::base::DisposableInterface::executeAndDispose()</a>, and <a class="el" href="ExecutionEngine_8hpp_source.html#l00254">RTT::ExecutionEngine::mqueue</a>.</p>

</div>
</div>
<a class="anchor" id="a6faeed04034647645557eb05f6f3eec2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::RunnableInterface::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The method that will be executed once when this class is run in a non periodic thread. </p>
<p>The default implementation calls <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#abec8b9e213e32c21b57266211703dc45" title="The method that will be periodically executed when this class is run in a periodic thread...">step()</a> once. </p>

<p>Reimplemented in <a class="el" href="classRTT_1_1os_1_1Timer.html#adfbcfa7d6da2bc548f6a4f5275caf0ed">RTT::os::Timer</a>.</p>

<p>Definition at line <a class="el" href="CoreRunnableInterface_8cpp_source.html#l00060">60</a> of file <a class="el" href="CoreRunnableInterface_8cpp_source.html">CoreRunnableInterface.cpp</a>.</p>

<p>References <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#abec8b9e213e32c21b57266211703dc45">RTT::base::RunnableInterface::step()</a>.</p>

<p>Referenced by <a class="el" href="SlaveActivity_8cpp_source.html#l00191">RTT::extras::SlaveActivity::execute()</a>, and <a class="el" href="Activity_8cpp_source.html#l00105">RTT::Activity::loop()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e0d36338cc3c7467325b8408f4f4648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1DisposableInterface.html">base::DisposableInterface</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue and execute (process) a given message. </p>
<p>The message is executed in <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a> or <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread. ">loop()</a> directly after all other queued ActionInterface objects. The constructor parameter <em>queue_size</em> limits how many messages can be queued in between <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a>s or <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread. ">loop()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the message got accepted, false otherwise. </dd>
<dd>
false when the MessageProcessor is not running or does not accept messages. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>acceptMessages </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00249">249</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="TaskCore_8hpp_source.html#l00102">RTT::base::TaskCore::FatalError</a>, <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, <a class="el" href="ExecutionEngine_8hpp_source.html#l00270">RTT::ExecutionEngine::mmaster</a>, <a class="el" href="ExecutionEngine_8hpp_source.html#l00254">RTT::ExecutionEngine::mqueue</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00249">RTT::ExecutionEngine::process()</a>, <a class="el" href="ExecutionEngine_8hpp_source.html#l00249">RTT::ExecutionEngine::taskc</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#acc594ecea241aee2390664e2e4a70a32">RTT::base::ActivityInterface::trigger()</a>.</p>

<p>Referenced by <a class="el" href="LocalOperationCaller_8hpp_source.html#l00126">RTT::internal::LocalOperationCallerImpl&lt; FunctionT &gt;::dispose()</a>, <a class="el" href="LocalOperationCaller_8hpp_source.html#l00099">RTT::internal::LocalOperationCallerImpl&lt; FunctionT &gt;::executeAndDispose()</a>, <a class="el" href="FusedFunctorDataSource_8hpp_source.html#l00510">RTT::internal::FusedMSignal&lt; Signature &gt;::invoke()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00249">RTT::ExecutionEngine::process()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00168">RTT::ExecutionEngine::removeFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="afdd4e66095262fd9f05e9f9d0f6ab32c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::removeFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a running function added with runFunction. </p>
<p>This method is only required if the function is to be destroyed and is still present in the Engine. </p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00168">168</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a5b728aaf49da0fefabdf099f2c42ff7a">RTT::base::ActivityInterface::isActive()</a>, <a class="el" href="ExecutableInterface_8hpp_source.html#l00095">RTT::base::ExecutableInterface::isLoaded()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00249">RTT::ExecutionEngine::process()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00198">RTT::ExecutionEngine::removeSelfFunction()</a>, <a class="el" href="ExecutableInterface_8hpp_source.html#l00078">RTT::base::ExecutableInterface::unloaded()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00269">RTT::ExecutionEngine::waitForMessages()</a>.</p>

<p>Referenced by <a class="el" href="FunctionGraph_8cpp_source.html#l00094">RTT::scripting::FunctionGraph::finish()</a>, <a class="el" href="CallFunction_8hpp_source.html#l00130">RTT::scripting::CallFunction::reset()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00383">RTT::scripting::ScriptingService::unloadProgram()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00246">RTT::scripting::ScriptingService::unloadStateMachine()</a>, and <a class="el" href="StateMachine_8cpp_source.html#l00071">RTT::scripting::StateMachine::~StateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ed7d8245e3b8a7363b535770ffd1b45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::removeSelfFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Self-removal for a running function added with runFunction. </p>
<p>You must call this variant in case you want yourself to be removed. Equivalent to returning false in <a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html#a485113b5518e732252b874b6939ca4cd" title="Executes a piece of functionality. ">ExecutableInterface::execute()</a>. </p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00198">198</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="ExecutionEngine_8hpp_source.html#l00261">RTT::ExecutionEngine::f_queue</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00168">RTT::ExecutionEngine::removeFunction()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00138">RTT::ExecutionEngine::runFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="a42f7fe7c3d76cc6ab5f27e4b92b91eb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::runFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ExecutableInterface.html">base::ExecutableInterface</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run a given function in <a class="el" href="classRTT_1_1ExecutionEngine.html#aaae452e029ed5e188ac76d9447befc6a" title="Executes (in that order) Messages, Functions and updateHook() functions of this TaskContext and its c...">step()</a> or <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a6faeed04034647645557eb05f6f3eec2" title="The method that will be executed once when this class is run in a non periodic thread. ">loop()</a>. </p>
<p>The function may only be destroyed after the <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> is stopped or <a class="el" href="classRTT_1_1ExecutionEngine.html#afdd4e66095262fd9f05e9f9d0f6ab32c" title="Remove a running function added with runFunction. ">removeFunction()</a> was invoked. The number of functions the Processor can run in parallel can be increased with setMaxFunctions(). </p><dl class="section return"><dt>Returns</dt><dd>false if the Engine is not running or the 'pending' queue is full. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRTT_1_1ExecutionEngine.html#afdd4e66095262fd9f05e9f9d0f6ab32c" title="Remove a running function added with runFunction. ">removeFunction()</a>, setMaxFunctions() </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00138">138</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="ExecutionEngine_8hpp_source.html#l00261">RTT::ExecutionEngine::f_queue</a>, <a class="el" href="TaskCore_8hpp_source.html#l00102">RTT::base::TaskCore::FatalError</a>, <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, <a class="el" href="ExecutableInterface_8hpp_source.html#l00070">RTT::base::ExecutableInterface::loaded()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00198">RTT::ExecutionEngine::removeSelfFunction()</a>, <a class="el" href="ExecutionEngine_8hpp_source.html#l00249">RTT::ExecutionEngine::taskc</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#acc594ecea241aee2390664e2e4a70a32">RTT::base::ActivityInterface::trigger()</a>.</p>

<p>Referenced by <a class="el" href="CallFunction_8hpp_source.html#l00108">RTT::scripting::CallFunction::execute()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00538">RTT::scripting::ScriptingService::loadFunctions()</a>, <a class="el" href="ScriptingService_8cpp_source.html#l00360">RTT::scripting::ScriptingService::loadProgram()</a>, and <a class="el" href="ScriptingService_8cpp_source.html#l00185">RTT::scripting::ScriptingService::loadStateMachine()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8b290342974c0b41c97515b1a4e9fd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::setActivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1ActivityInterface.html">base::ActivityInterface</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overridden version of <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a563528c3275ef0631f17928a80994371" title="Set the task this interface is run in. ">RTT::base::RunnableInterface::setActivity()</a>. </p>
<p>This version will also set the master <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> if the new activity is a SlaveActivity that runs an <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The ActivityInterface running this interface. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classRTT_1_1base_1_1RunnableInterface.html#a563528c3275ef0631f17928a80994371">RTT::base::RunnableInterface</a>.</p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00297">297</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="ActivityInterface_8cpp_source.html#l00070">RTT::base::ActivityInterface::getRunner()</a>, <a class="el" href="CoreRunnableInterface_8cpp_source.html#l00069">RTT::base::RunnableInterface::setActivity()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00292">RTT::ExecutionEngine::setMaster()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e9ba95daa969ce48537a862fb513bd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::setMaster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a> *&#160;</td>
          <td class="paramname"><em>master</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the master <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>. </p>
<p>If set, all incoming messages are forwarded to the master.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master</td><td>The new master <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00292">292</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="ExecutionEngine_8hpp_source.html#l00270">RTT::ExecutionEngine::mmaster</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00297">RTT::ExecutionEngine::setActivity()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d22ea9534992a8e6416ec6838d73b84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTT::ExecutionEngine::stopTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTT_1_1base_1_1TaskCore.html">base::TaskCore</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops executing the updateHook of <em>task</em>. </p>
<p>This is an explicit synchronisation point, which guarantees that updateHook is no longer executed when this function returns true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The Task calling this function and whose updateHook should no longer be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it's updateHook() is no longer being executed, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00437">437</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, and <a class="el" href="classRTT_1_1base_1_1ActivityInterface.html#a6ccbd039e0df4bae31fe63a988b3c2f3">RTT::base::ActivityInterface::start()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a1d79b5da733c511d90d8b4562de5eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::waitAndProcessFunctions </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; bool(void)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this if you wish to block on a function completing in the Execution Engine and execute it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>As long as !pred() waits and processes functions. If pred() == true when entering this function, then no functions will be processed and this function returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is for internal use only and is required for asynchronous function invocations.</p>
<dl class="section note"><dt>Note</dt><dd>waitAndProcessFunctions will call in turn this-&gt;processFunctions() and may as a consequence recurse if we get an asynchronous call-back. </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00339">339</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00284">RTT::ExecutionEngine::waitForFunctions()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b1435416406d34e86fb03289ea2d53e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::waitAndProcessMessages </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; bool(void)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this if you wish to block on a message arriving in the Execution Engine and execute it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>As long as !pred() waits and processes messages. If pred() == true when entering this function, then no messages will be processed and this function returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is for internal use only and is required for asynchronous method invocations.</p>
<dl class="section note"><dt>Note</dt><dd>waitAndProcessMessages will call in turn this-&gt;processMessages() and may as a consequence recurse if we get an asynchronous call-back. </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00321">321</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00269">RTT::ExecutionEngine::waitForMessages()</a>.</p>

</div>
</div>
<a class="anchor" id="a4703380e45a26dd1a0ef62c6cb3069eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::waitForFunctions </td>
          <td>(</td>
          <td class="paramtype">const boost::function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this if you wish to block on a function completing in the Execution Engine. </p>
<p>Each time a function completes, waitForFunctions will return when pred() returns true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>As long as !pred() blocks the calling thread. If pred() == true when entering this function, returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is for internal use only and is required for asynchronous function invocations. </p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00284">284</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00339">RTT::ExecutionEngine::waitAndProcessFunctions()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00309">RTT::ExecutionEngine::waitForMessagesInternal()</a>.</p>

<p>Referenced by <a class="el" href="CallFunction_8hpp_source.html#l00108">RTT::scripting::CallFunction::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb235144afc09805d9cd1982afac023b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::waitForMessages </td>
          <td>(</td>
          <td class="paramtype">const boost::function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this if you wish to block on a message arriving in the Execution Engine. </p>
<p>Each time one or more messages are processed, waitForMessages will return when pred() returns true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>As long as !pred() blocks the calling thread. If pred() == true when entering this function, returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is for internal use only and is required for asynchronous method invocations. </p>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00269">269</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>References <a class="el" href="RunnableInterface_8hpp_source.html#l00167">RTT::base::RunnableInterface::getActivity()</a>, <a class="el" href="ExecutionEngine_8hpp_source.html#l00270">RTT::ExecutionEngine::mmaster</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00321">RTT::ExecutionEngine::waitAndProcessMessages()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00269">RTT::ExecutionEngine::waitForMessages()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00309">RTT::ExecutionEngine::waitForMessagesInternal()</a>.</p>

<p>Referenced by <a class="el" href="LocalOperationCaller_8hpp_source.html#l00126">RTT::internal::LocalOperationCallerImpl&lt; FunctionT &gt;::dispose()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00168">RTT::ExecutionEngine::removeFunction()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00269">RTT::ExecutionEngine::waitForMessages()</a>.</p>

</div>
</div>
<a class="anchor" id="ac489df0ded78420f7eb798dc9ce888fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTT::ExecutionEngine::waitForMessagesInternal </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; bool(void)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this if you wish to block on a message arriving in the Execution Engine. </p>
<p>Each time one or more messages are processed, waitForMessages will return when pred() returns true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>As long as !pred() blocks the calling thread. If pred() == true when entering this function, the returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is for internal use only and is required for asynchronous method invocations.</p>
<dl class="section note"><dt>Note</dt><dd>waitForMessages requires another thread to execute processMessages() and may therefor not be called from within the component's Thread. Use <a class="el" href="classRTT_1_1ExecutionEngine.html#a9b1435416406d34e86fb03289ea2d53e" title="Call this if you wish to block on a message arriving in the Execution Engine and execute it...">waitAndProcessMessages()</a> instead. </dd></dl>

<p>Definition at line <a class="el" href="ExecutionEngine_8cpp_source.html#l00309">309</a> of file <a class="el" href="ExecutionEngine_8cpp_source.html">ExecutionEngine.cpp</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00284">RTT::ExecutionEngine::waitForFunctions()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00269">RTT::ExecutionEngine::waitForMessages()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a74d7968137f1997f83847cd5119ac5b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTT_1_1ExecutionEngine.html">ExecutionEngine</a>* RTT::ExecutionEngine::mmaster</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A master <a class="el" href="classRTT_1_1ExecutionEngine.html" title="An execution engine serialises (executes one after the other) the execution of all commands...">ExecutionEngine</a> which should process our messages. </p>
<p>This is used for ExecutionEngines running in a SlaveActivity which forward incoming messages to their master engine. </p>

<p>Definition at line <a class="el" href="ExecutionEngine_8hpp_source.html#l00270">270</a> of file <a class="el" href="ExecutionEngine_8hpp_source.html">ExecutionEngine.hpp</a>.</p>

<p>Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00249">RTT::ExecutionEngine::process()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00292">RTT::ExecutionEngine::setMaster()</a>, and <a class="el" href="ExecutionEngine_8cpp_source.html#l00269">RTT::ExecutionEngine::waitForMessages()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rtt/internal/<a class="el" href="GlobalEngine_8hpp_source.html">GlobalEngine.hpp</a></li>
<li>rtt/internal/<a class="el" href="GlobalEngine_8cpp_source.html">GlobalEngine.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
